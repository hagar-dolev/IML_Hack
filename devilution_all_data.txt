// some global definitions, found in debug release

#define DMAXX					40
#define DMAXY					40

#define LIGHTSIZE				6912 // 27 * 256

#define MAX_PLRS				4
#define MAX_CHARACTERS			10
#define MAX_LVLMTYPES			16
// #define MAX_PATH				260
#define MAX_SEND_STR_LEN		80

#define MAXDEAD					31
#define MAXDUNX					112
#define MAXDUNY					112
#define MAXITEMS				127
#define MAXMISSILES				125
#define MAXMONSTERS				200
#define MAXMULTIQUESTS			4
#define MAXOBJECTS				127
#define MAXPORTAL				4
#define MAXQUESTS				16
#define MAXTHEMES				50
#define MAXTILES				2048
#define MAXTRIGGERS				5
#define MDMAXX					40
#define MDMAXY					40


// Diablo uses a 256 color palette
// Entry 0-127 (0x00-0x7F) are level specific
// Entry 128-255 (0x80-0xFF) are global

// standard palette for all levels
// 8 or 16 shades per color
// example (dark blue): PAL16_BLUE+14, PAL8_BLUE+7
// example (light red): PAL16_RED+2, PAL8_RED
// example (orange): PAL16_ORANGE+8, PAL8_ORANGE+4
#define PAL8_BLUE		128
#define PAL8_RED		136
#define PAL8_YELLOW		144
#define PAL8_ORANGE		152
#define PAL16_BEIGE		160
#define PAL16_BLUE		176
#define PAL16_YELLOW	192
#define PAL16_ORANGE	208
#define PAL16_RED		224
#define PAL16_GRAY		240





/////////////////////////////////////////////////////////////////////////
/* temporary stuff from the decompiler */
/* remove all the garbage below in the future */
/////////////////////////////////////////////////////////////////////////
#ifndef IDA_GARBAGE
#define IDA_GARBAGE

inline void memset32(void *s, unsigned int c, size_t n)
{
	unsigned int *p = (unsigned int *)s;
	for (int i = 0; i < n; i++) {
		p[i] = c;
	}
}

typedef          __int64 ll;
typedef unsigned __int64 ull;

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64

// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif
// first unsigned macros:
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define DWORDn(x, n)  (*((_DWORD*)&(x)+n))

#define _LOBYTE(x)  BYTEn(x,LOW_IND(x,_BYTE))
#define _LOWORD(x)  WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define _HIBYTE(x)  BYTEn(x,HIGH_IND(x,_BYTE))
#define _HIWORD(x)  WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)


// now signed macros (the same but with sign extension)
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))

#define SLOBYTE(x)  SBYTEn(x,LOW_IND(x,int8))
#define SHIWORD(x)  SWORDn(x,HIGH_IND(x,int16))



// Helper functions to represent some assembly instructions.

#ifdef __cplusplus


// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
#define qmemcpy memcpy
/*
inline void *qmemcpy(void *dst, const void *src, size_t cnt)
{
  char *out = (char *)dst;
  const char *in = (const char *)src;
  while ( cnt > 0 )
  {
    *out++ = *in++;
    --cnt;
  }
  return dst;
} */

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__( int8  high, T low) { return ((( int16)high) << sizeof(high)*8) | uint8(low); }
template<class T>  int32 __PAIR__( int16 high, T low) { return ((( int32)high) << sizeof(high)*8) | uint16(low); }
template<class T>  int64 __PAIR__( int32 high, T low) { return ((( int64)high) << sizeof(high)*8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high)*8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high)*8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high)*8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, int count)
{
  const uint nbits = sizeof(T) * 8;

  if ( count > 0 )
  {
    count %= nbits;
    T high = value >> (nbits - count);
    if ( T(-1) < 0 ) // signed value
      high &= ~((T(-1) << count));
    value <<= count;
    value |= high;
  }
  else
  {
    count = -count % nbits;
    T low = value << (nbits - count);
    value >>= count;
    value |= low;
  }
  return value;
}

inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }

// sign flag
template<class T> int8 __SETS__(T x)
{
  if ( sizeof(T) == 1 )
    return int8(x) < 0;
  if ( sizeof(T) == 2 )
    return int16(x) < 0;
  if ( sizeof(T) == 4 )
    return int32(x) < 0;
  return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
  if ( sizeof(T) < sizeof(U) )
  {
    U x2 = x;
    int8 sx = __SETS__(x2);
    return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2-y));
  }
  else
  {
    T y2 = y;
    int8 sx = __SETS__(x);
    return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x-y2));
  }
}

#endif

#endif /* IDA_GARBAGE */
enum unique_base_item
{
	UITYPE_NONE = 0x0,
	UITYPE_SHORTBOW = 0x1,
	UITYPE_LONGBOW = 0x2,
	UITYPE_HUNTBOW = 0x3,
	UITYPE_COMPBOW = 0x4,
	UITYPE_WARBOW = 0x5,
	UITYPE_BATTLEBOW = 0x6,
	UITYPE_DAGGER = 0x7,
	UITYPE_FALCHION = 0x8,
	UITYPE_CLAYMORE = 0x9,
	UITYPE_BROADSWR = 0xA,
	UITYPE_SABRE = 0xB,
	UITYPE_SCIMITAR = 0xC,
	UITYPE_LONGSWR = 0xD,
	UITYPE_BASTARDSWR = 0xE,
	UITYPE_TWOHANDSWR = 0xF,
	UITYPE_GREATSWR = 0x10,
	UITYPE_CLEAVER = 0x11,
	UITYPE_LARGEAXE = 0x12,
	UITYPE_BROADAXE = 0x13,
	UITYPE_SMALLAXE = 0x14,
	UITYPE_BATTLEAXE = 0x15,
	UITYPE_GREATAXE = 0x16,
	UITYPE_MACE = 0x17,
	UITYPE_MORNSTAR = 0x18,
	UITYPE_SPIKCLUB = 0x19,
	UITYPE_MAUL = 0x1A,
	UITYPE_WARHAMMER = 0x1B,
	UITYPE_FLAIL = 0x1C,
	UITYPE_LONGSTAFF = 0x1D,
	UITYPE_SHORTSTAFF = 0x1E,
	UITYPE_COMPSTAFF = 0x1F,
	UITYPE_QUARSTAFF = 0x20,
	UITYPE_WARSTAFF = 0x21,
	UITYPE_SKULLCAP = 0x22,
	UITYPE_HELM = 0x23,
	UITYPE_GREATHELM = 0x24,
	UITYPE_CROWN = 0x25,
	UITYPE_38 = 0x26,
	UITYPE_RAGS = 0x27,
	UITYPE_STUDARMOR = 0x28,
	UITYPE_CLOAK = 0x29,
	UITYPE_ROBE = 0x2A,
	UITYPE_CHAINMAIL = 0x2B,
	UITYPE_LEATHARMOR = 0x2C,
	UITYPE_BREASTPLATE = 0x2D,
	UITYPE_CAPE = 0x2E,
	UITYPE_PLATEMAIL = 0x2F,
	UITYPE_FULLPLATE = 0x30,
	UITYPE_BUCKLER = 0x31,
	UITYPE_SMALLSHIELD = 0x32,
	UITYPE_LARGESHIELD = 0x33,
	UITYPE_KITESHIELD = 0x34,
	UITYPE_GOTHSHIELD = 0x35,
	UITYPE_RING = 0x36,
	UITYPE_55 = 0x37,
	UITYPE_AMULET = 0x38,
	UITYPE_SKCROWN = 0x39,
	UITYPE_INFRARING = 0x3A,
	UITYPE_OPTAMULET = 0x3B,
	UITYPE_TRING = 0x3C,
	UITYPE_HARCREST = 0x3D,
	UITYPE_MAPOFDOOM = 0x3E,
	UITYPE_ELIXIR = 0x3F,
	UITYPE_ARMOFVAL = 0x40,
	UITYPE_STEELVEIL = 0x41,
	UITYPE_GRISWOLD = 0x42,
	UITYPE_LGTFORGE = 0x43,
	UITYPE_LAZSTAFF = 0x44,
	UITYPE_INVALID = -1,
};

enum item_effect_type
{
	IPL_TOHIT = 0x0,
	IPL_TOHIT_CURSE = 0x1,
	IPL_DAMP = 0x2,
	IPL_DAMP_CURSE = 0x3,
	IPL_TOHIT_DAMP = 0x4,
	IPL_TOHIT_DAMP_CURSE = 0x5,
	IPL_ACP = 0x6,
	IPL_ACP_CURSE = 0x7,
	IPL_FIRERES = 0x8,
	IPL_LIGHTRES = 0x9,
	IPL_MAGICRES = 0xA,
	IPL_ALLRES = 0xB,
	IPL_SPLLVLADD = 0xE,
	IPL_CHARGES = 0xF,
	IPL_FIREDAM = 0x10,
	IPL_LIGHTDAM = 0x11,
	IPL_STR = 0x13,
	IPL_STR_CURSE = 0x14,
	IPL_MAG = 0x15,
	IPL_MAG_CURSE = 0x16,
	IPL_DEX = 0x17,
	IPL_DEX_CURSE = 0x18,
	IPL_VIT = 0x19,
	IPL_VIT_CURSE = 0x1A,
	IPL_ATTRIBS = 0x1B,
	IPL_ATTRIBS_CURSE = 0x1C,
	IPL_GETHIT_CURSE = 0x1D,
	IPL_GETHIT = 0x1E,
	IPL_LIFE = 0x1F,
	IPL_LIFE_CURSE = 0x20,
	IPL_MANA = 0x21,
	IPL_MANA_CURSE = 0x22,
	IPL_DUR = 0x23,
	IPL_DUR_CURSE = 0x24,
	IPL_INDESTRUCTIBLE = 0x25,
	IPL_LIGHT = 0x26,
	IPL_LIGHT_CURSE = 0x27,
	IPL_MULT_ARROWS = 0x29, /* only used in hellfire */
	IPL_FIRE_ARROWS = 0x2A,
	IPL_LIGHT_ARROWS = 0x2B,
	IPL_INVCURS = 0x2C,
	IPL_THORNS = 0x2D,
	IPL_NOMANA = 0x2E,
	IPL_NOHEALPLR = 0x2F,
	IPL_ABSHALFTRAP = 0x34,
	IPL_KNOCKBACK = 0x35,
	IPL_NOHEALMON = 0x36,
	IPL_STEALMANA = 0x37,
	IPL_STEALLIFE = 0x38,
	IPL_TARGAC = 0x39,
	IPL_FASTATTACK = 0x3A,
	IPL_FASTRECOVER = 0x3B,
	IPL_FASTBLOCK = 0x3C,
	IPL_DAMMOD = 0x3D,
	IPL_RNDARROWVEL = 0x3E,
	IPL_SETDAM = 0x3F,
	IPL_SETDUR = 0x40,
	IPL_NOMINSTR = 0x41,
	IPL_SPELL = 0x42,
	IPL_FASTSWING = 0x43,
	IPL_ONEHAND = 0x44,
	IPL_3XDAMVDEM = 0x45,
	IPL_ALLRESZERO = 0x46,
	IPL_DRAINLIFE = 0x48,
	IPL_RNDSTEALLIFE = 0x49,
	IPL_INFRAVISION = 0x4A,
	IPL_SETAC = 0x4B,
	IPL_ADDACLIFE = 0x4C,
	IPL_ADDMANAAC = 0x4D,
	IPL_FIRERESCLVL = 0x4E,
	IPL_AC_CURSE = 0x4F,
	IPL_INVALID = -1,
};

enum affix_item_type
{
	PLT_MISC = 0x1,
	PLT_BOW = 0x10,
	PLT_STAFF = 0x100,
	PLT_WEAP = 0x1000,
	PLT_SHLD = 0x10000,
	PLT_ARMO = 0x100000,
};

enum _sfx_id
{
	PS_WALK1 = 0x0,
	PS_WALK2 = 0x1,
	PS_WALK3 = 0x2,
	PS_WALK4 = 0x3,
	PS_BFIRE = 0x4,
	PS_FMAG = 0x5,
	PS_TMAG = 0x6,
	PS_LGHIT = 0x7,
	PS_LGHIT1 = 0x8,
	PS_SWING = 0x9,
	PS_SWING2 = 0xA,
	PS_DEAD = 0xB,
	IS_QUESTDN = 0xC,
	IS_ARMRFKD = 0xD,
	IS_BARLFIRE = 0xE,
	IS_BARREL = 0xF,
	IS_BHIT = 0x10,
	IS_BHIT1 = 0x11,
	IS_CHEST = 0x12,
	IS_DOORCLOS = 0x13,
	IS_DOOROPEN = 0x14,
	IS_FANVL = 0x15,
	IS_FAXE = 0x16,
	IS_FBLST = 0x17,
	IS_FBODY = 0x18,
	IS_FBOOK = 0x19,
	IS_FBOW = 0x1A,
	IS_FCAP = 0x1B,
	IS_FHARM = 0x1C,
	IS_FLARM = 0x1D,
	IS_FMAG = 0x1E,
	IS_FMAG1 = 0x1F,
	IS_FMUSH = 0x20,
	IS_FPOT = 0x21,
	IS_FRING = 0x22,
	IS_FROCK = 0x23,
	IS_FSCRL = 0x24,
	IS_FSHLD = 0x25,
	IS_FSIGN = 0x26,
	IS_FSTAF = 0x27,
	IS_FSWOR = 0x28,
	IS_GOLD = 0x29,
	IS_HLMTFKD = 0x2A,
	IS_IANVL = 0x2B,
	IS_IAXE = 0x2C,
	IS_IBLST = 0x2D,
	IS_IBODY = 0x2E,
	IS_IBOOK = 0x2F,
	IS_IBOW = 0x30,
	IS_ICAP = 0x31,
	IS_IGRAB = 0x32,
	IS_IHARM = 0x33,
	IS_ILARM = 0x34,
	IS_IMUSH = 0x35,
	IS_IPOT = 0x36,
	IS_IRING = 0x37,
	IS_IROCK = 0x38,
	IS_ISCROL = 0x39,
	IS_ISHIEL = 0x3A,
	IS_ISIGN = 0x3B,
	IS_ISTAF = 0x3C,
	IS_ISWORD = 0x3D,
	IS_LEVER = 0x3E,
	IS_MAGIC = 0x3F,
	IS_MAGIC1 = 0x40,
	IS_RBOOK = 0x41,
	IS_SARC = 0x42,
	IS_SHLDFKD = 0x43,
	IS_SWRDFKD = 0x44,
	IS_TITLEMOV = 0x45,
	IS_TITLSLCT = 0x46,
	SFX_SILENCE = 0x47,
	IS_TRAP = 0x48,
	IS_CAST1 = 0x49,
	IS_CAST10 = 0x4A,
	IS_CAST12 = 0x4B,
	IS_CAST2 = 0x4C,
	IS_CAST3 = 0x4D,
	IS_CAST4 = 0x4E,
	IS_CAST5 = 0x4F,
	IS_CAST6 = 0x50,
	IS_CAST7 = 0x51,
	IS_CAST8 = 0x52,
	IS_CAST9 = 0x53,
	LS_HEALING = 0x54,
	IS_REPAIR = 0x55,
	LS_ACID = 0x56,
	LS_ACIDS = 0x57,
	LS_APOC = 0x58,
	LS_ARROWALL = 0x59,
	LS_BLODBOIL = 0x5A,
	LS_BLODSTAR = 0x5B,
	LS_BLSIMPT = 0x5C,
	LS_BONESP = 0x5D,
	LS_BSIMPCT = 0x5E,
	LS_CALDRON = 0x5F,
	LS_CBOLT = 0x60,
	LS_CHLTNING = 0x61,
	LS_DSERP = 0x62,
	LS_ELECIMP1 = 0x63,
	LS_ELEMENTL = 0x64,
	LS_ETHEREAL = 0x65,
	LS_FBALL = 0x66,
	LS_FBOLT1 = 0x67,
	LS_FBOLT2 = 0x68,
	LS_FIRIMP1 = 0x69,
	LS_FIRIMP2 = 0x6A,
	LS_FLAMWAVE = 0x6B,
	LS_FLASH = 0x6C,
	LS_FOUNTAIN = 0x6D,
	LS_GOLUM = 0x6E,
	LS_GOLUMDED = 0x6F,
	LS_GSHRINE = 0x70,
	LS_GUARD = 0x71,
	LS_GUARDLAN = 0x72,
	LS_HOLYBOLT = 0x73,
	LS_HYPER = 0x74,
	LS_INFRAVIS = 0x75,
	LS_INVISIBL = 0x76,
	LS_INVPOT = 0x77,
	LS_LNING1 = 0x78,
	LS_LTNING = 0x79,
	LS_MSHIELD = 0x7A,
	LS_NOVA = 0x7B,
	LS_PORTAL = 0x7C,
	LS_PUDDLE = 0x7D,
	LS_RESUR = 0x7E,
	LS_SCURSE = 0x7F,
	LS_SCURIMP = 0x80,
	LS_SENTINEL = 0x81,
	LS_SHATTER = 0x82,
	LS_SOULFIRE = 0x83,
	LS_SPOUTLOP = 0x84,
	LS_SPOUTSTR = 0x85,
	LS_STORM = 0x86,
	LS_TRAPDIS = 0x87,
	LS_TELEPORT = 0x88,
	LS_VTHEFT = 0x89,
	LS_WALLLOOP = 0x8A,
	LS_WALLSTRT = 0x8B,
	TSFX_BMAID1 = 0x8C,
	TSFX_BMAID2 = 0x8D,
	TSFX_BMAID3 = 0x8E,
	TSFX_BMAID4 = 0x8F,
	TSFX_BMAID5 = 0x90,
	TSFX_BMAID6 = 0x91,
	TSFX_BMAID7 = 0x92,
	TSFX_BMAID8 = 0x93,
	TSFX_BMAID9 = 0x94,
	TSFX_BMAID10 = 0x95,
	TSFX_BMAID11 = 0x96,
	TSFX_BMAID12 = 0x97,
	TSFX_BMAID13 = 0x98,
	TSFX_BMAID14 = 0x99,
	TSFX_BMAID15 = 0x9A,
	TSFX_BMAID16 = 0x9B,
	TSFX_BMAID17 = 0x9C,
	TSFX_BMAID18 = 0x9D,
	TSFX_BMAID19 = 0x9E,
	TSFX_BMAID20 = 0x9F,
	TSFX_BMAID21 = 0xA0,
	TSFX_BMAID22 = 0xA1,
	TSFX_BMAID23 = 0xA2,
	TSFX_BMAID24 = 0xA3,
	TSFX_BMAID25 = 0xA4,
	TSFX_BMAID26 = 0xA5,
	TSFX_BMAID27 = 0xA6,
	TSFX_BMAID28 = 0xA7,
	TSFX_BMAID29 = 0xA8,
	TSFX_BMAID30 = 0xA9,
	TSFX_BMAID31 = 0xAA,
	TSFX_BMAID32 = 0xAB,
	TSFX_BMAID33 = 0xAC,
	TSFX_BMAID34 = 0xAD,
	TSFX_BMAID35 = 0xAE,
	TSFX_BMAID36 = 0xAF,
	TSFX_BMAID37 = 0xB0,
	TSFX_BMAID38 = 0xB1,
	TSFX_BMAID39 = 0xB2,
	TSFX_BMAID40 = 0xB3,
	TSFX_SMITH1 = 0xB4,
	TSFX_SMITH2 = 0xB5,
	TSFX_SMITH3 = 0xB6,
	TSFX_SMITH4 = 0xB7,
	TSFX_SMITH5 = 0xB8,
	TSFX_SMITH6 = 0xB9,
	TSFX_SMITH7 = 0xBA,
	TSFX_SMITH8 = 0xBB,
	TSFX_SMITH9 = 0xBC,
	TSFX_SMITH10 = 0xBD,
	TSFX_SMITH11 = 0xBE,
	TSFX_SMITH12 = 0xBF,
	TSFX_SMITH13 = 0xC0,
	TSFX_SMITH14 = 0xC1,
	TSFX_SMITH15 = 0xC2,
	TSFX_SMITH16 = 0xC3,
	TSFX_SMITH17 = 0xC4,
	TSFX_SMITH18 = 0xC5,
	TSFX_SMITH19 = 0xC6,
	TSFX_SMITH20 = 0xC7,
	TSFX_SMITH21 = 0xC8,
	TSFX_SMITH22 = 0xC9,
	TSFX_SMITH23 = 0xCA,
	TSFX_SMITH24 = 0xCB,
	TSFX_SMITH25 = 0xCC,
	TSFX_SMITH26 = 0xCD,
	TSFX_SMITH27 = 0xCE,
	TSFX_SMITH28 = 0xCF,
	TSFX_SMITH29 = 0xD0,
	TSFX_SMITH30 = 0xD1,
	TSFX_SMITH31 = 0xD2,
	TSFX_SMITH32 = 0xD3,
	TSFX_SMITH33 = 0xD4,
	TSFX_SMITH34 = 0xD5,
	TSFX_SMITH35 = 0xD6,
	TSFX_SMITH36 = 0xD7,
	TSFX_SMITH37 = 0xD8,
	TSFX_SMITH38 = 0xD9,
	TSFX_SMITH39 = 0xDA,
	TSFX_SMITH40 = 0xDB,
	TSFX_SMITH41 = 0xDC,
	TSFX_SMITH42 = 0xDD,
	TSFX_SMITH43 = 0xDE,
	TSFX_SMITH44 = 0xDF,
	TSFX_SMITH45 = 0xE0,
	TSFX_SMITH46 = 0xE1,
	TSFX_SMITH47 = 0xE2,
	TSFX_SMITH48 = 0xE3,
	TSFX_SMITH49 = 0xE4,
	TSFX_SMITH50 = 0xE5,
	TSFX_SMITH51 = 0xE6,
	TSFX_SMITH52 = 0xE7,
	TSFX_SMITH53 = 0xE8,
	TSFX_SMITH54 = 0xE9,
	TSFX_SMITH55 = 0xEA,
	TSFX_SMITH56 = 0xEB,
	TSFX_COW1 = 0xEC,
	TSFX_COW2 = 0xED,
	TSFX_DEADGUY = 0xEE,
	TSFX_DRUNK1 = 0xEF,
	TSFX_DRUNK2 = 0xF0,
	TSFX_DRUNK3 = 0xF1,
	TSFX_DRUNK4 = 0xF2,
	TSFX_DRUNK5 = 0xF3,
	TSFX_DRUNK6 = 0xF4,
	TSFX_DRUNK7 = 0xF5,
	TSFX_DRUNK8 = 0xF6,
	TSFX_DRUNK9 = 0xF7,
	TSFX_DRUNK10 = 0xF8,
	TSFX_DRUNK11 = 0xF9,
	TSFX_DRUNK12 = 0xFA,
	TSFX_DRUNK13 = 0xFB,
	TSFX_DRUNK14 = 0xFC,
	TSFX_DRUNK15 = 0xFD,
	TSFX_DRUNK16 = 0xFE,
	TSFX_DRUNK17 = 0xFF,
	TSFX_DRUNK18 = 0x100,
	TSFX_DRUNK19 = 0x101,
	TSFX_DRUNK20 = 0x102,
	TSFX_DRUNK21 = 0x103,
	TSFX_DRUNK22 = 0x104,
	TSFX_DRUNK23 = 0x105,
	TSFX_DRUNK24 = 0x106,
	TSFX_DRUNK25 = 0x107,
	TSFX_DRUNK26 = 0x108,
	TSFX_DRUNK27 = 0x109,
	TSFX_DRUNK28 = 0x10A,
	TSFX_DRUNK29 = 0x10B,
	TSFX_DRUNK30 = 0x10C,
	TSFX_DRUNK31 = 0x10D,
	TSFX_DRUNK32 = 0x10E,
	TSFX_DRUNK33 = 0x10F,
	TSFX_DRUNK34 = 0x110,
	TSFX_DRUNK35 = 0x111,
	TSFX_HEALER1 = 0x112,
	TSFX_HEALER2 = 0x113,
	TSFX_HEALER3 = 0x114,
	TSFX_HEALER4 = 0x115,
	TSFX_HEALER5 = 0x116,
	TSFX_HEALER6 = 0x117,
	TSFX_HEALER7 = 0x118,
	TSFX_HEALER8 = 0x119,
	TSFX_HEALER9 = 0x11A,
	TSFX_HEALER10 = 0x11B,
	TSFX_HEALER11 = 0x11C,
	TSFX_HEALER12 = 0x11D,
	TSFX_HEALER13 = 0x11E,
	TSFX_HEALER14 = 0x11F,
	TSFX_HEALER15 = 0x120,
	TSFX_HEALER16 = 0x121,
	TSFX_HEALER17 = 0x122,
	TSFX_HEALER18 = 0x123,
	TSFX_HEALER19 = 0x124,
	TSFX_HEALER20 = 0x125,
	TSFX_HEALER21 = 0x126,
	TSFX_HEALER22 = 0x127,
	TSFX_HEALER23 = 0x128,
	TSFX_HEALER24 = 0x129,
	TSFX_HEALER25 = 0x12A,
	TSFX_HEALER26 = 0x12B,
	TSFX_HEALER27 = 0x12C,
	TSFX_HEALER28 = 0x12D,
	TSFX_HEALER29 = 0x12E,
	TSFX_HEALER30 = 0x12F,
	TSFX_HEALER31 = 0x130,
	TSFX_HEALER32 = 0x131,
	TSFX_HEALER33 = 0x132,
	TSFX_HEALER34 = 0x133,
	TSFX_HEALER35 = 0x134,
	TSFX_HEALER36 = 0x135,
	TSFX_HEALER37 = 0x136,
	TSFX_HEALER38 = 0x137,
	TSFX_HEALER39 = 0x138,
	TSFX_HEALER40 = 0x139,
	TSFX_HEALER41 = 0x13A,
	TSFX_HEALER42 = 0x13B,
	TSFX_HEALER43 = 0x13C,
	TSFX_HEALER44 = 0x13D,
	TSFX_HEALER45 = 0x13E,
	TSFX_HEALER46 = 0x13F,
	TSFX_HEALER47 = 0x140,
	TSFX_PEGBOY1 = 0x141,
	TSFX_PEGBOY2 = 0x142,
	TSFX_PEGBOY3 = 0x143,
	TSFX_PEGBOY4 = 0x144,
	TSFX_PEGBOY5 = 0x145,
	TSFX_PEGBOY6 = 0x146,
	TSFX_PEGBOY7 = 0x147,
	TSFX_PEGBOY8 = 0x148,
	TSFX_PEGBOY9 = 0x149,
	TSFX_PEGBOY10 = 0x14A,
	TSFX_PEGBOY11 = 0x14B,
	TSFX_PEGBOY12 = 0x14C,
	TSFX_PEGBOY13 = 0x14D,
	TSFX_PEGBOY14 = 0x14E,
	TSFX_PEGBOY15 = 0x14F,
	TSFX_PEGBOY16 = 0x150,
	TSFX_PEGBOY17 = 0x151,
	TSFX_PEGBOY18 = 0x152,
	TSFX_PEGBOY19 = 0x153,
	TSFX_PEGBOY20 = 0x154,
	TSFX_PEGBOY21 = 0x155,
	TSFX_PEGBOY22 = 0x156,
	TSFX_PEGBOY23 = 0x157,
	TSFX_PEGBOY24 = 0x158,
	TSFX_PEGBOY25 = 0x159,
	TSFX_PEGBOY26 = 0x15A,
	TSFX_PEGBOY27 = 0x15B,
	TSFX_PEGBOY28 = 0x15C,
	TSFX_PEGBOY29 = 0x15D,
	TSFX_PEGBOY30 = 0x15E,
	TSFX_PEGBOY31 = 0x15F,
	TSFX_PEGBOY32 = 0x160,
	TSFX_PEGBOY33 = 0x161,
	TSFX_PEGBOY34 = 0x162,
	TSFX_PEGBOY35 = 0x163,
	TSFX_PEGBOY36 = 0x164,
	TSFX_PEGBOY37 = 0x165,
	TSFX_PEGBOY38 = 0x166,
	TSFX_PEGBOY39 = 0x167,
	TSFX_PEGBOY40 = 0x168,
	TSFX_PEGBOY41 = 0x169,
	TSFX_PEGBOY42 = 0x16A,
	TSFX_PEGBOY43 = 0x16B,
	TSFX_PRIEST0 = 0x16C,
	TSFX_PRIEST1 = 0x16D,
	TSFX_PRIEST2 = 0x16E,
	TSFX_PRIEST3 = 0x16F,
	TSFX_PRIEST4 = 0x170,
	TSFX_PRIEST5 = 0x171,
	TSFX_PRIEST6 = 0x172,
	TSFX_PRIEST7 = 0x173,
	TSFX_STORY0 = 0x174,
	TSFX_STORY1 = 0x175,
	TSFX_STORY2 = 0x176,
	TSFX_STORY3 = 0x177,
	TSFX_STORY4 = 0x178,
	TSFX_STORY5 = 0x179,
	TSFX_STORY6 = 0x17A,
	TSFX_STORY7 = 0x17B,
	TSFX_STORY8 = 0x17C,
	TSFX_STORY9 = 0x17D,
	TSFX_STORY10 = 0x17E,
	TSFX_STORY11 = 0x17F,
	TSFX_STORY12 = 0x180,
	TSFX_STORY13 = 0x181,
	TSFX_STORY14 = 0x182,
	TSFX_STORY15 = 0x183,
	TSFX_STORY16 = 0x184,
	TSFX_STORY17 = 0x185,
	TSFX_STORY18 = 0x186,
	TSFX_STORY19 = 0x187,
	TSFX_STORY20 = 0x188,
	TSFX_STORY21 = 0x189,
	TSFX_STORY22 = 0x18A,
	TSFX_STORY23 = 0x18B,
	TSFX_STORY24 = 0x18C,
	TSFX_STORY25 = 0x18D,
	TSFX_STORY26 = 0x18E,
	TSFX_STORY27 = 0x18F,
	TSFX_STORY28 = 0x190,
	TSFX_STORY29 = 0x191,
	TSFX_STORY30 = 0x192,
	TSFX_STORY31 = 0x193,
	TSFX_STORY32 = 0x194,
	TSFX_STORY33 = 0x195,
	TSFX_STORY34 = 0x196,
	TSFX_STORY35 = 0x197,
	TSFX_STORY36 = 0x198,
	TSFX_STORY37 = 0x199,
	TSFX_STORY38 = 0x19A,
	TSFX_TAVERN0 = 0x19B,
	TSFX_TAVERN1 = 0x19C,
	TSFX_TAVERN2 = 0x19D,
	TSFX_TAVERN3 = 0x19E,
	TSFX_TAVERN4 = 0x19F,
	TSFX_TAVERN5 = 0x1A0,
	TSFX_TAVERN6 = 0x1A1,
	TSFX_TAVERN7 = 0x1A2,
	TSFX_TAVERN8 = 0x1A3,
	TSFX_TAVERN9 = 0x1A4,
	TSFX_TAVERN10 = 0x1A5,
	TSFX_TAVERN11 = 0x1A6,
	TSFX_TAVERN12 = 0x1A7,
	TSFX_TAVERN13 = 0x1A8,
	TSFX_TAVERN14 = 0x1A9,
	TSFX_TAVERN15 = 0x1AA,
	TSFX_TAVERN16 = 0x1AB,
	TSFX_TAVERN17 = 0x1AC,
	TSFX_TAVERN18 = 0x1AD,
	TSFX_TAVERN19 = 0x1AE,
	TSFX_TAVERN20 = 0x1AF,
	TSFX_TAVERN21 = 0x1B0,
	TSFX_TAVERN22 = 0x1B1,
	TSFX_TAVERN23 = 0x1B2,
	TSFX_TAVERN24 = 0x1B3,
	TSFX_TAVERN25 = 0x1B4,
	TSFX_TAVERN26 = 0x1B5,
	TSFX_TAVERN27 = 0x1B6,
	TSFX_TAVERN28 = 0x1B7,
	TSFX_TAVERN29 = 0x1B8,
	TSFX_TAVERN30 = 0x1B9,
	TSFX_TAVERN31 = 0x1BA,
	TSFX_TAVERN32 = 0x1BB,
	TSFX_TAVERN33 = 0x1BC,
	TSFX_TAVERN34 = 0x1BD,
	TSFX_TAVERN35 = 0x1BE,
	TSFX_TAVERN36 = 0x1BF,
	TSFX_TAVERN37 = 0x1C0,
	TSFX_TAVERN38 = 0x1C1,
	TSFX_TAVERN39 = 0x1C2,
	TSFX_TAVERN40 = 0x1C3,
	TSFX_TAVERN41 = 0x1C4,
	TSFX_TAVERN42 = 0x1C5,
	TSFX_TAVERN43 = 0x1C6,
	TSFX_TAVERN44 = 0x1C7,
	TSFX_TAVERN45 = 0x1C8,
	TSFX_WITCH1 = 0x1C9,
	TSFX_WITCH2 = 0x1CA,
	TSFX_WITCH3 = 0x1CB,
	TSFX_WITCH4 = 0x1CC,
	TSFX_WITCH5 = 0x1CD,
	TSFX_WITCH6 = 0x1CE,
	TSFX_WITCH7 = 0x1CF,
	TSFX_WITCH8 = 0x1D0,
	TSFX_WITCH9 = 0x1D1,
	TSFX_WITCH10 = 0x1D2,
	TSFX_WITCH11 = 0x1D3,
	TSFX_WITCH12 = 0x1D4,
	TSFX_WITCH13 = 0x1D5,
	TSFX_WITCH14 = 0x1D6,
	TSFX_WITCH15 = 0x1D7,
	TSFX_WITCH16 = 0x1D8,
	TSFX_WITCH17 = 0x1D9,
	TSFX_WITCH18 = 0x1DA,
	TSFX_WITCH19 = 0x1DB,
	TSFX_WITCH20 = 0x1DC,
	TSFX_WITCH21 = 0x1DD,
	TSFX_WITCH22 = 0x1DE,
	TSFX_WITCH23 = 0x1DF,
	TSFX_WITCH24 = 0x1E0,
	TSFX_WITCH25 = 0x1E1,
	TSFX_WITCH26 = 0x1E2,
	TSFX_WITCH27 = 0x1E3,
	TSFX_WITCH28 = 0x1E4,
	TSFX_WITCH29 = 0x1E5,
	TSFX_WITCH30 = 0x1E6,
	TSFX_WITCH31 = 0x1E7,
	TSFX_WITCH32 = 0x1E8,
	TSFX_WITCH33 = 0x1E9,
	TSFX_WITCH34 = 0x1EA,
	TSFX_WITCH35 = 0x1EB,
	TSFX_WITCH36 = 0x1EC,
	TSFX_WITCH37 = 0x1ED,
	TSFX_WITCH38 = 0x1EE,
	TSFX_WITCH39 = 0x1EF,
	TSFX_WITCH40 = 0x1F0,
	TSFX_WITCH41 = 0x1F1,
	TSFX_WITCH42 = 0x1F2,
	TSFX_WITCH43 = 0x1F3,
	TSFX_WITCH44 = 0x1F4,
	TSFX_WITCH45 = 0x1F5,
	TSFX_WITCH46 = 0x1F6,
	TSFX_WITCH47 = 0x1F7,
	TSFX_WITCH48 = 0x1F8,
	TSFX_WITCH49 = 0x1F9,
	TSFX_WITCH50 = 0x1FA,
	TSFX_WOUND = 0x1FB,
	PS_MAGE1 = 0x1FC,
	PS_MAGE2 = 0x1FD,
	PS_MAGE3 = 0x1FE,
	PS_MAGE4 = 0x1FF,
	PS_MAGE5 = 0x200,
	PS_MAGE6 = 0x201,
	PS_MAGE7 = 0x202,
	PS_MAGE8 = 0x203,
	PS_MAGE9 = 0x204,
	PS_MAGE10 = 0x205,
	PS_MAGE11 = 0x206,
	PS_MAGE12 = 0x207,
	PS_MAGE13 = 0x208,
	PS_MAGE14 = 0x209,
	PS_MAGE15 = 0x20A,
	PS_MAGE16 = 0x20B,
	PS_MAGE17 = 0x20C,
	PS_MAGE18 = 0x20D,
	PS_MAGE19 = 0x20E,
	PS_MAGE20 = 0x20F,
	PS_MAGE21 = 0x210,
	PS_MAGE22 = 0x211,
	PS_MAGE23 = 0x212,
	PS_MAGE24 = 0x213,
	PS_MAGE25 = 0x214,
	PS_MAGE26 = 0x215,
	PS_MAGE27 = 0x216,
	PS_MAGE28 = 0x217,
	PS_MAGE29 = 0x218,
	PS_MAGE30 = 0x219,
	PS_MAGE31 = 0x21A,
	PS_MAGE32 = 0x21B,
	PS_MAGE33 = 0x21C,
	PS_MAGE34 = 0x21D,
	PS_MAGE35 = 0x21E,
	PS_MAGE36 = 0x21F,
	PS_MAGE37 = 0x220,
	PS_MAGE38 = 0x221,
	PS_MAGE39 = 0x222,
	PS_MAGE40 = 0x223,
	PS_MAGE41 = 0x224,
	PS_MAGE42 = 0x225,
	PS_MAGE43 = 0x226,
	PS_MAGE44 = 0x227,
	PS_MAGE45 = 0x228,
	PS_MAGE46 = 0x229,
	PS_MAGE47 = 0x22A,
	PS_MAGE48 = 0x22B,
	PS_MAGE49 = 0x22C,
	PS_MAGE50 = 0x22D,
	PS_MAGE51 = 0x22E,
	PS_MAGE52 = 0x22F,
	PS_MAGE53 = 0x230,
	PS_MAGE54 = 0x231,
	PS_MAGE55 = 0x232,
	PS_MAGE56 = 0x233,
	PS_MAGE57 = 0x234,
	PS_MAGE58 = 0x235,
	PS_MAGE59 = 0x236,
	PS_MAGE60 = 0x237,
	PS_MAGE61 = 0x238,
	PS_MAGE62 = 0x239,
	PS_MAGE63 = 0x23A,
	PS_MAGE64 = 0x23B,
	PS_MAGE65 = 0x23C,
	PS_MAGE66 = 0x23D,
	PS_MAGE67 = 0x23E,
	PS_MAGE68 = 0x23F,
	PS_MAGE69 = 0x240,
	PS_MAGE69B = 0x241,
	PS_MAGE70 = 0x242,
	PS_MAGE71 = 0x243,
	PS_MAGE72 = 0x244,
	PS_MAGE73 = 0x245,
	PS_MAGE74 = 0x246,
	PS_MAGE75 = 0x247,
	PS_MAGE76 = 0x248,
	PS_MAGE77 = 0x249,
	PS_MAGE78 = 0x24A,
	PS_MAGE79 = 0x24B,
	PS_MAGE80 = 0x24C,
	PS_MAGE81 = 0x24D,
	PS_MAGE82 = 0x24E,
	PS_MAGE83 = 0x24F,
	PS_MAGE84 = 0x250,
	PS_MAGE85 = 0x251,
	PS_MAGE86 = 0x252,
	PS_MAGE87 = 0x253,
	PS_MAGE88 = 0x254,
	PS_MAGE89 = 0x255,
	PS_MAGE90 = 0x256,
	PS_MAGE91 = 0x257,
	PS_MAGE92 = 0x258,
	PS_MAGE93 = 0x259,
	PS_MAGE94 = 0x25A,
	PS_MAGE95 = 0x25B,
	PS_MAGE96 = 0x25C,
	PS_MAGE97 = 0x25D,
	PS_MAGE98 = 0x25E,
	PS_MAGE99 = 0x25F,
	PS_MAGE100 = 0x260,
	PS_MAGE101 = 0x261,
	PS_MAGE102 = 0x262,
	PS_ROGUE1 = 0x263,
	PS_ROGUE2 = 0x264,
	PS_ROGUE3 = 0x265,
	PS_ROGUE4 = 0x266,
	PS_ROGUE5 = 0x267,
	PS_ROGUE6 = 0x268,
	PS_ROGUE7 = 0x269,
	PS_ROGUE8 = 0x26A,
	PS_ROGUE9 = 0x26B,
	PS_ROGUE10 = 0x26C,
	PS_ROGUE11 = 0x26D,
	PS_ROGUE12 = 0x26E,
	PS_ROGUE13 = 0x26F,
	PS_ROGUE14 = 0x270,
	PS_ROGUE15 = 0x271,
	PS_ROGUE16 = 0x272,
	PS_ROGUE17 = 0x273,
	PS_ROGUE18 = 0x274,
	PS_ROGUE19 = 0x275,
	PS_ROGUE20 = 0x276,
	PS_ROGUE21 = 0x277,
	PS_ROGUE22 = 0x278,
	PS_ROGUE23 = 0x279,
	PS_ROGUE24 = 0x27A,
	PS_ROGUE25 = 0x27B,
	PS_ROGUE26 = 0x27C,
	PS_ROGUE27 = 0x27D,
	PS_ROGUE28 = 0x27E,
	PS_ROGUE29 = 0x27F,
	PS_ROGUE30 = 0x280,
	PS_ROGUE31 = 0x281,
	PS_ROGUE32 = 0x282,
	PS_ROGUE33 = 0x283,
	PS_ROGUE34 = 0x284,
	PS_ROGUE35 = 0x285,
	PS_ROGUE36 = 0x286,
	PS_ROGUE37 = 0x287,
	PS_ROGUE38 = 0x288,
	PS_ROGUE39 = 0x289,
	PS_ROGUE40 = 0x28A,
	PS_ROGUE41 = 0x28B,
	PS_ROGUE42 = 0x28C,
	PS_ROGUE43 = 0x28D,
	PS_ROGUE44 = 0x28E,
	PS_ROGUE45 = 0x28F,
	PS_ROGUE46 = 0x290,
	PS_ROGUE47 = 0x291,
	PS_ROGUE48 = 0x292,
	PS_ROGUE49 = 0x293,
	PS_ROGUE50 = 0x294,
	PS_ROGUE51 = 0x295,
	PS_ROGUE52 = 0x296,
	PS_ROGUE53 = 0x297,
	PS_ROGUE54 = 0x298,
	PS_ROGUE55 = 0x299,
	PS_ROGUE56 = 0x29A,
	PS_ROGUE57 = 0x29B,
	PS_ROGUE58 = 0x29C,
	PS_ROGUE59 = 0x29D,
	PS_ROGUE60 = 0x29E,
	PS_ROGUE61 = 0x29F,
	PS_ROGUE62 = 0x2A0,
	PS_ROGUE63 = 0x2A1,
	PS_ROGUE64 = 0x2A2,
	PS_ROGUE65 = 0x2A3,
	PS_ROGUE66 = 0x2A4,
	PS_ROGUE67 = 0x2A5,
	PS_ROGUE68 = 0x2A6,
	PS_ROGUE69 = 0x2A7,
	PS_ROGUE69B = 0x2A8,
	PS_ROGUE70 = 0x2A9,
	PS_ROGUE71 = 0x2AA,
	PS_ROGUE72 = 0x2AB,
	PS_ROGUE73 = 0x2AC,
	PS_ROGUE74 = 0x2AD,
	PS_ROGUE75 = 0x2AE,
	PS_ROGUE76 = 0x2AF,
	PS_ROGUE77 = 0x2B0,
	PS_ROGUE78 = 0x2B1,
	PS_ROGUE79 = 0x2B2,
	PS_ROGUE80 = 0x2B3,
	PS_ROGUE81 = 0x2B4,
	PS_ROGUE82 = 0x2B5,
	PS_ROGUE83 = 0x2B6,
	PS_ROGUE84 = 0x2B7,
	PS_ROGUE85 = 0x2B8,
	PS_ROGUE86 = 0x2B9,
	PS_ROGUE87 = 0x2BA,
	PS_ROGUE88 = 0x2BB,
	PS_ROGUE89 = 0x2BC,
	PS_ROGUE90 = 0x2BD,
	PS_ROGUE91 = 0x2BE,
	PS_ROGUE92 = 0x2BF,
	PS_ROGUE93 = 0x2C0,
	PS_ROGUE94 = 0x2C1,
	PS_ROGUE95 = 0x2C2,
	PS_ROGUE96 = 0x2C3,
	PS_ROGUE97 = 0x2C4,
	PS_ROGUE98 = 0x2C5,
	PS_ROGUE99 = 0x2C6,
	PS_ROGUE100 = 0x2C7,
	PS_ROGUE101 = 0x2C8,
	PS_ROGUE102 = 0x2C9,
	PS_WARR1 = 0x2CA,
	PS_WARR2 = 0x2CB,
	PS_WARR3 = 0x2CC,
	PS_WARR4 = 0x2CD,
	PS_WARR5 = 0x2CE,
	PS_WARR6 = 0x2CF,
	PS_WARR7 = 0x2D0,
	PS_WARR8 = 0x2D1,
	PS_WARR9 = 0x2D2,
	PS_WARR10 = 0x2D3,
	PS_WARR11 = 0x2D4,
	PS_WARR12 = 0x2D5,
	PS_WARR13 = 0x2D6,
	PS_WARR14 = 0x2D7,
	PS_WARR14B = 0x2D8,
	PS_WARR14C = 0x2D9,
	PS_WARR15 = 0x2DA,
	PS_WARR15B = 0x2DB,
	PS_WARR15C = 0x2DC,
	PS_WARR16 = 0x2DD,
	PS_WARR16B = 0x2DE,
	PS_WARR16C = 0x2DF,
	PS_WARR17 = 0x2E0,
	PS_WARR18 = 0x2E1,
	PS_WARR19 = 0x2E2,
	PS_WARR20 = 0x2E3,
	PS_WARR21 = 0x2E4,
	PS_WARR22 = 0x2E5,
	PS_WARR23 = 0x2E6,
	PS_WARR24 = 0x2E7,
	PS_WARR25 = 0x2E8,
	PS_WARR26 = 0x2E9,
	PS_WARR27 = 0x2EA,
	PS_WARR28 = 0x2EB,
	PS_WARR29 = 0x2EC,
	PS_WARR30 = 0x2ED,
	PS_WARR31 = 0x2EE,
	PS_WARR32 = 0x2EF,
	PS_WARR33 = 0x2F0,
	PS_WARR34 = 0x2F1,
	PS_WARR35 = 0x2F2,
	PS_WARR36 = 0x2F3,
	PS_WARR37 = 0x2F4,
	PS_WARR38 = 0x2F5,
	PS_WARR39 = 0x2F6,
	PS_WARR40 = 0x2F7,
	PS_WARR41 = 0x2F8,
	PS_WARR42 = 0x2F9,
	PS_WARR43 = 0x2FA,
	PS_WARR44 = 0x2FB,
	PS_WARR45 = 0x2FC,
	PS_WARR46 = 0x2FD,
	PS_WARR47 = 0x2FE,
	PS_WARR48 = 0x2FF,
	PS_WARR49 = 0x300,
	PS_WARR50 = 0x301,
	PS_WARR51 = 0x302,
	PS_WARR52 = 0x303,
	PS_WARR53 = 0x304,
	PS_WARR54 = 0x305,
	PS_WARR55 = 0x306,
	PS_WARR56 = 0x307,
	PS_WARR57 = 0x308,
	PS_WARR58 = 0x309,
	PS_WARR59 = 0x30A,
	PS_WARR60 = 0x30B,
	PS_WARR61 = 0x30C,
	PS_WARR62 = 0x30D,
	PS_WARR63 = 0x30E,
	PS_WARR64 = 0x30F,
	PS_WARR65 = 0x310,
	PS_WARR66 = 0x311,
	PS_WARR67 = 0x312,
	PS_WARR68 = 0x313,
	PS_WARR69 = 0x314,
	PS_WARR69B = 0x315,
	PS_WARR70 = 0x316,
	PS_WARR71 = 0x317,
	PS_WARR72 = 0x318,
	PS_WARR73 = 0x319,
	PS_WARR74 = 0x31A,
	PS_WARR75 = 0x31B,
	PS_WARR76 = 0x31C,
	PS_WARR77 = 0x31D,
	PS_WARR78 = 0x31E,
	PS_WARR79 = 0x31F,
	PS_WARR80 = 0x320,
	PS_WARR81 = 0x321,
	PS_WARR82 = 0x322,
	PS_WARR83 = 0x323,
	PS_WARR84 = 0x324,
	PS_WARR85 = 0x325,
	PS_WARR86 = 0x326,
	PS_WARR87 = 0x327,
	PS_WARR88 = 0x328,
	PS_WARR89 = 0x329,
	PS_WARR90 = 0x32A,
	PS_WARR91 = 0x32B,
	PS_WARR92 = 0x32C,
	PS_WARR93 = 0x32D,
	PS_WARR94 = 0x32E,
	PS_WARR95 = 0x32F,
	PS_WARR95B = 0x330,
	PS_WARR95C = 0x331,
	PS_WARR95D = 0x332,
	PS_WARR95E = 0x333,
	PS_WARR95F = 0x334,
	PS_WARR96B = 0x335,
	PS_WARR97 = 0x336,
	PS_WARR98 = 0x337,
	PS_WARR99 = 0x338,
	PS_WARR100 = 0x339,
	PS_WARR101 = 0x33A,
	PS_WARR102 = 0x33B,
	PS_NAR1 = 0x33C,
	PS_NAR2 = 0x33D,
	PS_NAR3 = 0x33E,
	PS_NAR4 = 0x33F,
	PS_NAR5 = 0x340,
	PS_NAR6 = 0x341,
	PS_NAR7 = 0x342,
	PS_NAR8 = 0x343,
	PS_NAR9 = 0x344,
	PS_DIABLVLINT = 0x345,
	USFX_CLEAVER = 0x346,
	USFX_GARBUD1 = 0x347,
	USFX_GARBUD2 = 0x348,
	USFX_GARBUD3 = 0x349,
	USFX_GARBUD4 = 0x34A,
	USFX_IZUAL1 = 0x34B,
	USFX_LACH1 = 0x34C,
	USFX_LACH2 = 0x34D,
	USFX_LACH3 = 0x34E,
	USFX_LAZ1 = 0x34F,
	USFX_LAZ2 = 0x350,
	USFX_SKING1 = 0x351,
	USFX_SNOT1 = 0x352,
	USFX_SNOT2 = 0x353,
	USFX_SNOT3 = 0x354,
	USFX_WARLRD1 = 0x355,
	USFX_WLOCK1 = 0x356,
	USFX_ZHAR1 = 0x357,
	USFX_ZHAR2 = 0x358,
	USFX_DIABLOD = 0x359,
};

enum item_equip_type
{
	ILOC_NONE = 0x0,
	ILOC_ONEHAND = 0x1,
	ILOC_TWOHAND = 0x2,
	ILOC_ARMOR = 0x3,
	ILOC_HELM = 0x4,
	ILOC_RING = 0x5,
	ILOC_AMULET = 0x6,
	ILOC_UNEQUIPABLE = 0x7,
	ILOC_BELT = 0x8,
	ILOC_INVALID = -1,
};

enum missile_id
{
	MIS_ARROW = 0x0,
	MIS_FIREBOLT = 0x1,
	MIS_GUARDIAN = 0x2,
	MIS_RNDTELEPORT = 0x3,
	MIS_LIGHTBALL = 0x4,
	MIS_FIREWALL = 0x5,
	MIS_FIREBALL = 0x6,
	MIS_LIGHTCTRL = 0x7,
	MIS_LIGHTNING = 0x8,
	MIS_MISEXP = 0x9,
	MIS_TOWN = 0xA,
	MIS_FLASH = 0xB,
	MIS_FLASH2 = 0xC,
	MIS_MANASHIELD = 0xD,
	MIS_FIREMOVE = 0xE,
	MIS_CHAIN = 0xF,
	MIS_NULL_10 = 0x10, // sentinal?
	MIS_NULL_11 = 0x11,
	MIS_NULL_12 = 0x12,
	MIS_NULL_13 = 0x13,
	MIS_RHINO = 0x14,
	MIS_MAGMABALL = 0x15,
	MIS_LIGHTCTRL2 = 0x16,
	MIS_LIGHTNING2 = 0x17,
	MIS_FLARE = 0x18,
	MIS_MISEXP2 = 0x19,
	MIS_TELEPORT = 0x1A,
	MIS_FARROW = 0x1B,
	MIS_DOOMSERP = 0x1C,
	MIS_NULL_1D = 0x1D,
	MIS_STONE = 0x1E,
	MIS_NULL_1F = 0x1F,
	MIS_INVISIBL = 0x20,
	MIS_GOLEM = 0x21,
	MIS_ETHEREALIZE = 0x22,
	MIS_NULL_23 = 0x23,
	MIS_BOOM = 0x24,
	MIS_HEAL = 0x25,
	MIS_FIREWALLC = 0x26,
	MIS_INFRA = 0x27,
	MIS_IDENTIFY = 0x28,
	MIS_WAVE = 0x29,
	MIS_NOVA = 0x2A,
	MIS_BLODBOIL = 0x2B,
	MIS_APOCA = 0x2C,
	MIS_REPAIR = 0x2D,
	MIS_RECHARGE = 0x2E,
	MIS_DISARM = 0x2F,
	MIS_FLAME = 0x30,
	MIS_FLAMEC = 0x31,
	MIS_NULL_32 = 0x32,
	MIS_NULL_33 = 0x33,
	MIS_CBOLT = 0x34,
	MIS_HBOLT = 0x35,
	MIS_RESURRECT = 0x36,
	MIS_TELEKINESIS = 0x37,
	MIS_LARROW = 0x38,
	MIS_ACID = 0x39,
	MIS_MISEXP3 = 0x3A,
	MIS_ACIDPUD = 0x3B,
	MIS_HEALOTHER = 0x3C,
	MIS_ELEMENT = 0x3D,
	MIS_RESURRECTBEAM = 0x3E,
	MIS_BONESPIRIT = 0x3F,
	MIS_WEAPEXP = 0x40,
	MIS_RPORTAL = 0x41,
	MIS_BOOM2 = 0x42,
	MIS_DIABAPOCA = 0x43,
};

enum missile_graphic_id
{
	MFILE_ARROWS = 0x0,
	MFILE_FIREBA = 0x1,
	MFILE_GUARD = 0x2,
	MFILE_LGHNING = 0x3,
	MFILE_FIREWAL = 0x4,
	MFILE_MAGBLOS = 0x5,
	MFILE_PORTAL = 0x6,
	MFILE_BLUEXFR = 0x7,
	MFILE_BLUEXBK = 0x8,
	MFILE_MANASHLD = 0x9,
	MFILE_BLOOD = 0xA,
	MFILE_BONE = 0xB,
	MFILE_METLHIT = 0xC,
	MFILE_FARROW = 0xD,
	MFILE_DOOM = 0xE,
	MFILE_0F = 0xF,
	MFILE_BLODBUR = 0x10,
	MFILE_NEWEXP = 0x11,
	MFILE_SHATTER1 = 0x12,
	MFILE_BIGEXP = 0x13,
	MFILE_INFERNO = 0x14,
	MFILE_THINLGHT = 0x15,
	MFILE_FLARE = 0x16,
	MFILE_FLAREEXP = 0x17,
	MFILE_MAGBALL = 0x18,
	MFILE_KRULL = 0x19,
	MFILE_MINILTNG = 0x1A,
	MFILE_HOLY = 0x1B,
	MFILE_HOLYEXPL = 0x1C,
	MFILE_LARROW = 0x1D,
	MFILE_FIRARWEX = 0x1E,
	MFILE_ACIDBF = 0x1F,
	MFILE_ACIDSPLA = 0x20,
	MFILE_ACIDPUD = 0x21,
	MFILE_ETHRSHLD = 0x22,
	MFILE_FIRERUN = 0x23,
	MFILE_RESSUR1 = 0x24,
	MFILE_SKLBALL = 0x25,
	MFILE_RPORTAL = 0x26,
	MFILE_FIREPLAR = 0x27,
	MFILE_SCUBMISB = 0x28,
	MFILE_SCBSEXPB = 0x29,
	MFILE_SCUBMISC = 0x2A,
	MFILE_SCBSEXPC = 0x2B,
	MFILE_SCUBMISD = 0x2C,
	MFILE_SCBSEXPD = 0x2D,
	MFILE_NULL = 0x2E,
	MFILE_INVALID = 0x2F,
	MFILE_NONE = 0xFF,
};

enum _mai_id
{
	AI_ZOMBIE = 0,
	AI_FAT = 1,
	AI_SKELSD = 2,
	AI_SKELBOW = 3,
	AI_SCAV = 4,
	AI_RHINO = 5,
	AI_GOATMC = 6,
	AI_GOATBOW = 7,
	AI_FALLEN = 8,
	AI_MAGMA = 9,
	AI_SKELKING = 10,
	AI_BAT = 11,
	AI_GARG = 12,
	AI_CLEAVER = 13,
	AI_SUCC = 14,
	AI_SNEAK = 15,
	AI_STORM = 16,
	AI_FIREMAN = 17,
	AI_GARBUD = 18,
	AI_ACID = 19,
	AI_ACIDUNIQ = 20,
	AI_GOLUM = 21,
	AI_ZHAR = 22,
	AI_SNOTSPIL = 23,
	AI_SNAKE = 24,
	AI_COUNSLR = 25,
	AI_MEGA = 26,
	AI_DIABLO = 27,
	AI_LAZURUS = 28,
	AI_LAZHELP = 29,
	AI_LACHDAN = 30,
	AI_WARLORD = 31,
};

enum _mc_id
{
	MC_UNDEAD = 0,
	MC_DEMON = 1,
	MC_ANIMAL = 2,
};

enum _monster_id
{
	MT_NZOMBIE = 0x0,
	MT_BZOMBIE = 0x1,
	MT_GZOMBIE = 0x2,
	MT_YZOMBIE = 0x3,
	MT_RFALLSP = 0x4,
	MT_DFALLSP = 0x5,
	MT_YFALLSP = 0x6,
	MT_BFALLSP = 0x7,
	MT_WSKELAX = 0x8,
	MT_TSKELAX = 0x9,
	MT_RSKELAX = 0xA,
	MT_XSKELAX = 0xB,
	MT_RFALLSD = 0xC,
	MT_DFALLSD = 0xD,
	MT_YFALLSD = 0xE,
	MT_BFALLSD = 0xF,
	MT_NSCAV = 0x10,
	MT_BSCAV = 0x11,
	MT_WSCAV = 0x12,
	MT_YSCAV = 0x13,
	MT_WSKELBW = 0x14,
	MT_TSKELBW = 0x15,
	MT_RSKELBW = 0x16,
	MT_XSKELBW = 0x17,
	MT_WSKELSD = 0x18,
	MT_TSKELSD = 0x19,
	MT_RSKELSD = 0x1A,
	MT_XSKELSD = 0x1B,
	MT_INVILORD = 0x1C,
	MT_SNEAK = 0x1D,
	MT_STALKER = 0x1E,
	MT_UNSEEN = 0x1F,
	MT_ILLWEAV = 0x20,
	MT_LRDSAYTR = 0x21,
	MT_NGOATMC = 0x22,
	MT_BGOATMC = 0x23,
	MT_RGOATMC = 0x24,
	MT_GGOATMC = 0x25,
	MT_FIEND = 0x26,
	MT_BLINK = 0x27,
	MT_GLOOM = 0x28,
	MT_FAMILIAR = 0x29,
	MT_NGOATBW = 0x2A,
	MT_BGOATBW = 0x2B,
	MT_RGOATBW = 0x2C,
	MT_GGOATBW = 0x2D,
	MT_NACID = 0x2E,
	MT_RACID = 0x2F,
	MT_BACID = 0x30,
	MT_XACID = 0x31,
	MT_SKING = 0x32,
	MT_CLEAVER = 0x33,
	MT_FAT = 0x34,
	MT_MUDMAN = 0x35,
	MT_TOAD = 0x36,
	MT_FLAYED = 0x37,
	MT_WYRM = 0x38,
	MT_CAVSLUG = 0x39,
	MT_DVLWYRM = 0x3A,
	MT_DEVOUR = 0x3B,
	MT_NMAGMA = 0x3C,
	MT_YMAGMA = 0x3D,
	MT_BMAGMA = 0x3E,
	MT_WMAGMA = 0x3F,
	MT_HORNED = 0x40,
	MT_MUDRUN = 0x41,
	MT_FROSTC = 0x42,
	MT_OBLORD = 0x43,
	MT_BONEDMN = 0x44,
	MT_REDDTH = 0x45,
	MT_LTCHDMN = 0x46,
	MT_UDEDBLRG = 0x47,
	MT_INCIN = 0x48,
	MT_FLAMLRD = 0x49,
	MT_DOOMFIRE = 0x4A,
	MT_HELLBURN = 0x4B,
	MT_STORM = 0x4C,
	MT_RSTORM = 0x4D,
	MT_STORML = 0x4E,
	MT_MAEL = 0x4F,
	MT_BIGFALL = 0x50,
	MT_WINGED = 0x51,
	MT_GARGOYLE = 0x52,
	MT_BLOODCLW = 0x53,
	MT_DEATHW = 0x54,
	MT_MEGA = 0x55,
	MT_GUARD = 0x56,
	MT_VTEXLRD = 0x57,
	MT_BALROG = 0x58,
	MT_NSNAKE = 0x59,
	MT_RSNAKE = 0x5A,
	MT_BSNAKE = 0x5B,
	MT_GSNAKE = 0x5C,
	MT_NBLACK = 0x5D,
	MT_RTBLACK = 0x5E,
	MT_BTBLACK = 0x5F,
	MT_RBLACK = 0x60,
	MT_UNRAV = 0x61,
	MT_HOLOWONE = 0x62,
	MT_PAINMSTR = 0x63,
	MT_REALWEAV = 0x64,
	MT_SUCCUBUS = 0x65,
	MT_SNOWWICH = 0x66,
	MT_HLSPWN = 0x67,
	MT_SOLBRNR = 0x68,
	MT_COUNSLR = 0x69,
	MT_MAGISTR = 0x6A,
	MT_CABALIST = 0x6B,
	MT_ADVOCATE = 0x6C,
	MT_GOLEM = 0x6D,
	MT_DIABLO = 0x6E,
	MT_DARKMAGE = 0x6F
};

enum _speech_id
{
	QUEST_KING1 = 0x0,
	QUEST_KING2 = 0x1,
	QUEST_KING3 = 0x2,
	QUEST_KING4 = 0x3,
	QUEST_KING5 = 0x4,
	QUEST_KING6 = 0x5,
	QUEST_KING7 = 0x6,
	QUEST_KING8 = 0x7,
	QUEST_KING9 = 0x8,
	QUEST_KING10 = 0x9,
	QUEST_KING11 = 0xA,
	QUEST_BANNER1 = 0xB,
	QUEST_BANNER2 = 0xC,
	QUEST_BANNER3 = 0xD,
	QUEST_BANNER4 = 0xE,
	QUEST_BANNER5 = 0xF,
	QUEST_BANNER6 = 0x10,
	QUEST_BANNER7 = 0x11,
	QUEST_BANNER8 = 0x12,
	QUEST_BANNER9 = 0x13,
	QUEST_BANNER10 = 0x14,
	QUEST_BANNER11 = 0x15,
	QUEST_BANNER12 = 0x16,
	QUEST_VILE1 = 0x17,
	QUEST_VILE2 = 0x18,
	QUEST_VILE3 = 0x19,
	QUEST_VILE4 = 0x1A,
	QUEST_VILE5 = 0x1B,
	QUEST_VILE6 = 0x1C,
	QUEST_VILE7 = 0x1D,
	QUEST_VILE8 = 0x1E,
	QUEST_VILE9 = 0x1F,
	QUEST_VILE10 = 0x20,
	QUEST_VILE11 = 0x21,
	QUEST_VILE12 = 0x22,
	QUEST_VILE13 = 0x23,
	QUEST_VILE14 = 0x24,
	QUEST_POISON1 = 0x25,
	QUEST_POISON2 = 0x26,
	QUEST_POISON3 = 0x27,
	QUEST_POISON4 = 0x28,
	QUEST_POISON5 = 0x29,
	QUEST_POISON6 = 0x2A,
	QUEST_POISON7 = 0x2B,
	QUEST_POISON8 = 0x2C,
	QUEST_POISON9 = 0x2D,
	QUEST_POISON10 = 0x2E,
	QUEST_BONE1 = 0x2F,
	QUEST_BONE2 = 0x30,
	QUEST_BONE3 = 0x31,
	QUEST_BONE4 = 0x32,
	QUEST_BONE5 = 0x33,
	QUEST_BONE6 = 0x34,
	QUEST_BONE7 = 0x35,
	QUEST_BONE8 = 0x36,
	QUEST_BUTCH1 = 0x37,
	QUEST_BUTCH2 = 0x38,
	QUEST_BUTCH3 = 0x39,
	QUEST_BUTCH4 = 0x3A,
	QUEST_BUTCH5 = 0x3B,
	QUEST_BUTCH6 = 0x3C,
	QUEST_BUTCH7 = 0x3D,
	QUEST_BUTCH8 = 0x3E,
	QUEST_BUTCH9 = 0x3F,
	QUEST_BUTCH10 = 0x40,
	QUEST_BLIND1 = 0x41,
	QUEST_BLIND2 = 0x42,
	QUEST_BLIND3 = 0x43,
	QUEST_BLIND4 = 0x44,
	QUEST_BLIND5 = 0x45,
	QUEST_BLIND6 = 0x46,
	QUEST_BLIND7 = 0x47,
	QUEST_BLIND8 = 0x48,
	QUEST_VEIL1 = 0x49,
	QUEST_VEIL2 = 0x4A,
	QUEST_VEIL3 = 0x4B,
	QUEST_VEIL4 = 0x4C,
	QUEST_VEIL5 = 0x4D,
	QUEST_VEIL6 = 0x4E,
	QUEST_VEIL7 = 0x4F,
	QUEST_VEIL8 = 0x50,
	QUEST_VEIL9 = 0x51,
	QUEST_VEIL10 = 0x52,
	QUEST_VEIL11 = 0x53,
	QUEST_ANVIL1 = 0x54,
	QUEST_ANVIL2 = 0x55,
	QUEST_ANVIL3 = 0x56,
	QUEST_ANVIL4 = 0x57,
	QUEST_ANVIL5 = 0x58,
	QUEST_ANVIL6 = 0x59,
	QUEST_ANVIL7 = 0x5A,
	QUEST_ANVIL8 = 0x5B,
	QUEST_ANVIL9 = 0x5C,
	QUEST_ANVIL10 = 0x5D,
	QUEST_BLOOD1 = 0x5E,
	QUEST_BLOOD2 = 0x5F,
	QUEST_BLOOD3 = 0x60,
	QUEST_BLOOD4 = 0x61,
	QUEST_BLOOD5 = 0x62,
	QUEST_BLOOD6 = 0x63,
	QUEST_BLOOD7 = 0x64,
	QUEST_BLOOD8 = 0x65,
	QUEST_WARLRD1 = 0x66,
	QUEST_WARLRD2 = 0x67,
	QUEST_WARLRD3 = 0x68,
	QUEST_WARLRD4 = 0x69,
	QUEST_WARLRD5 = 0x6A,
	QUEST_WARLRD6 = 0x6B,
	QUEST_WARLRD7 = 0x6C,
	QUEST_WARLRD8 = 0x6D,
	QUEST_WARLRD9 = 0x6E,
	QUEST_INFRA1 = 0x6F,
	QUEST_INFRA2 = 0x70,
	QUEST_INFRA3 = 0x71,
	QUEST_INFRA4 = 0x72,
	QUEST_INFRA5 = 0x73,
	QUEST_INFRA6 = 0x74,
	QUEST_INFRA7 = 0x75,
	QUEST_INFRA8 = 0x76,
	QUEST_INFRA9 = 0x77,
	QUEST_INFRA10 = 0x78,
	QUEST_MUSH1 = 0x79,
	QUEST_MUSH2 = 0x7A,
	QUEST_MUSH3 = 0x7B,
	QUEST_MUSH4 = 0x7C,
	QUEST_MUSH5 = 0x7D,
	QUEST_MUSH6 = 0x7E,
	QUEST_MUSH7 = 0x7F,
	QUEST_MUSH8 = 0x80,
	QUEST_MUSH9 = 0x81,
	QUEST_MUSH10 = 0x82,
	QUEST_MUSH11 = 0x83,
	QUEST_MUSH12 = 0x84,
	QUEST_MUSH13 = 0x85,
	QUEST_DOOM1 = 0x86,
	QUEST_DOOM2 = 0x87,
	QUEST_DOOM3 = 0x88,
	QUEST_DOOM4 = 0x89,
	QUEST_DOOM5 = 0x8A,
	QUEST_DOOM6 = 0x8B,
	QUEST_DOOM7 = 0x8C,
	QUEST_DOOM8 = 0x8D,
	QUEST_DOOM9 = 0x8E,
	QUEST_DOOM10 = 0x8F,
	QUEST_GARBUD1 = 0x90,
	QUEST_GARBUD2 = 0x91,
	QUEST_GARBUD3 = 0x92,
	QUEST_GARBUD4 = 0x93,
	QUEST_ZHAR1 = 0x94,
	QUEST_ZHAR2 = 0x95,
	QUEST_STORY1 = 0x96,
	QUEST_STORY2 = 0x97,
	QUEST_STORY3 = 0x98,
	QUEST_STORY4 = 0x99,
	QUEST_STORY5 = 0x9A,
	QUEST_STORY6 = 0x9B,
	QUEST_STORY7 = 0x9C,
	QUEST_STORY9 = 0x9D,
	QUEST_STORY10 = 0x9E,
	QUEST_STORY11 = 0x9F,
	QUEST_OGDEN1 = 0xA0,
	QUEST_OGDEN2 = 0xA1,
	QUEST_OGDEN3 = 0xA2,
	QUEST_OGDEN4 = 0xA3,
	QUEST_OGDEN5 = 0xA4,
	QUEST_OGDEN6 = 0xA5,
	QUEST_OGDEN8 = 0xA6,
	QUEST_OGDEN9 = 0xA7,
	QUEST_OGDEN10 = 0xA8,
	QUEST_PEPIN1 = 0xA9,
	QUEST_PEPIN2 = 0xAA,
	QUEST_PEPIN3 = 0xAB,
	QUEST_PEPIN4 = 0xAC,
	QUEST_PEPIN5 = 0xAD,
	QUEST_PEPIN6 = 0xAE,
	QUEST_PEPIN7 = 0xAF,
	QUEST_PEPIN9 = 0xB0,
	QUEST_PEPIN10 = 0xB1,
	QUEST_PEPIN11 = 0xB2,
	QUEST_GILLIAN1 = 0xB3,
	QUEST_GILLIAN2 = 0xB4,
	QUEST_GILLIAN3 = 0xB5,
	QUEST_GILLIAN4 = 0xB6,
	QUEST_GILLIAN5 = 0xB7,
	QUEST_GILLIAN6 = 0xB8,
	QUEST_GILLIAN7 = 0xB9,
	QUEST_GILLIAN9 = 0xBA,
	QUEST_GILLIAN10 = 0xBB,
	QUEST_GRISWOLD1 = 0xBC,
	QUEST_GRISWOLD2 = 0xBD,
	QUEST_GRISWOLD3 = 0xBE,
	QUEST_GRISWOLD4 = 0xBF,
	QUEST_GRISWOLD5 = 0xC0,
	QUEST_GRISWOLD6 = 0xC1,
	QUEST_GRISWOLD7 = 0xC2,
	QUEST_GRISWOLD8 = 0xC3,
	QUEST_GRISWOLD9 = 0xC4,
	QUEST_GRISWOLD10 = 0xC5,
	QUEST_GRISWOLD12 = 0xC6,
	QUEST_GRISWOLD13 = 0xC7,
	QUEST_FARNHAM1 = 0xC8,
	QUEST_FARNHAM2 = 0xC9,
	QUEST_FARNHAM3 = 0xCA,
	QUEST_FARNHAM4 = 0xCB,
	QUEST_FARNHAM5 = 0xCC,
	QUEST_FARNHAM6 = 0xCD,
	QUEST_FARNHAM8 = 0xCE,
	QUEST_FARNHAM9 = 0xCF,
	QUEST_FARNHAM10 = 0xD0,
	QUEST_FARNHAM11 = 0xD1,
	QUEST_FARNHAM12 = 0xD2,
	QUEST_FARNHAM13 = 0xD3,
	QUEST_ADRIA1 = 0xD4,
	QUEST_ADRIA2 = 0xD5,
	QUEST_ADRIA3 = 0xD6,
	QUEST_ADRIA4 = 0xD7,
	QUEST_ADRIA5 = 0xD8,
	QUEST_ADRIA6 = 0xD9,
	QUEST_ADRIA7 = 0xDA,
	QUEST_ADRIA8 = 0xDB,
	QUEST_ADRIA9 = 0xDC,
	QUEST_ADRIA10 = 0xDD,
	QUEST_ADRIA12 = 0xDE,
	QUEST_ADRIA13 = 0xDF,
	QUEST_WIRT1 = 0xE0,
	QUEST_WIRT2 = 0xE1,
	QUEST_WIRT3 = 0xE2,
	QUEST_WIRT4 = 0xE3,
	QUEST_WIRT5 = 0xE4,
	QUEST_WIRT6 = 0xE5,
	QUEST_WIRT7 = 0xE6,
	QUEST_WIRT8 = 0xE7,
	QUEST_WIRT9 = 0xE8,
	QUEST_WIRT11 = 0xE9,
	QUEST_WIRT12 = 0xEA,
	QUEST_BONER = 0xEB,
	QUEST_BLOODY = 0xEC,
	QUEST_BLINDING = 0xED,
	QUEST_BLOODWAR = 0xEE,
	QUEST_MBONER = 0xEF,
	QUEST_MBLOODY = 0xF0,
	QUEST_MBLINDING = 0xF1,
	QUEST_MBLOODWAR = 0xF2,
	QUEST_RBONER = 0xF3,
	QUEST_RBLOODY = 0xF4,
	QUEST_RBLINDING = 0xF5,
	QUEST_RBLOODWAR = 0xF6,
	QUEST_COW1 = 0xF7,
	QUEST_COW2 = 0xF8,
	QUEST_BOOK11 = 0xF9,
	QUEST_BOOK12 = 0xFA,
	QUEST_BOOK13 = 0xFB,
	QUEST_BOOK21 = 0xFC,
	QUEST_BOOK22 = 0xFD,
	QUEST_BOOK23 = 0xFE,
	QUEST_BOOK31 = 0xFF,
	QUEST_BOOK32 = 0x100,
	QUEST_BOOK33 = 0x101,
	QUEST_INTRO = 0x102
};

enum object_graphic_id
{
	OFILE_L1BRAZ = 0x0,
	OFILE_L1DOORS = 0x1,
	OFILE_LEVER = 0x2,
	OFILE_CHEST1 = 0x3,
	OFILE_CHEST2 = 0x4,
	OFILE_BANNER = 0x5,
	OFILE_SKULPILE = 0x6,
	OFILE_SKULFIRE = 0x7,
	OFILE_SKULSTIK = 0x8,
	OFILE_CRUXSK1 = 0x9,
	OFILE_CRUXSK2 = 0xA,
	OFILE_CRUXSK3 = 0xB,
	OFILE_BOOK1 = 0xC,
	OFILE_BOOK2 = 0xD,
	OFILE_ROCKSTAN = 0xE,
	OFILE_ANGEL = 0xF,
	OFILE_CHEST3 = 0x10,
	OFILE_BURNCROS = 0x11,
	OFILE_CANDLE2 = 0x12,
	OFILE_NUDE2 = 0x13,
	OFILE_SWITCH4 = 0x14,
	OFILE_TNUDEM = 0x15,
	OFILE_TNUDEW = 0x16,
	OFILE_TSOUL = 0x17,
	OFILE_L2DOORS = 0x18,
	OFILE_WTORCH4 = 0x19,
	OFILE_WTORCH3 = 0x1A,
	OFILE_SARC = 0x1B,
	OFILE_FLAME1 = 0x1C,
	OFILE_PRSRPLT1 = 0x1D,
	OFILE_TRAPHOLE = 0x1E,
	OFILE_MINIWATR = 0x1F,
	OFILE_WTORCH2 = 0x20,
	OFILE_WTORCH1 = 0x21,
	OFILE_BCASE = 0x22,
	OFILE_BSHELF = 0x23,
	OFILE_WEAPSTND = 0x24,
	OFILE_BARREL = 0x25,
	OFILE_BARRELEX = 0x26,
	OFILE_LSHRINEG = 0x27,
	OFILE_RSHRINEG = 0x28,
	OFILE_BLOODFNT = 0x29,
	OFILE_DECAP = 0x2A,
	OFILE_PEDISTL = 0x2B,
	OFILE_L3DOORS = 0x2C,
	OFILE_PFOUNTN = 0x2D,
	OFILE_ARMSTAND = 0x2E,
	OFILE_GOATSHRN = 0x2F,
	OFILE_CAULDREN = 0x30,
	OFILE_MFOUNTN = 0x31,
	OFILE_TFOUNTN = 0x32,
	OFILE_ALTBOY = 0x33,
	OFILE_MCIRL = 0x34,
	OFILE_BKSLBRNT = 0x35,
	OFILE_MUSHPTCH = 0x36,
	OFILE_LZSTAND = 0x37,
};

enum dungeon_type
{
	DTYPE_TOWN = 0x0,
	DTYPE_CATHEDRAL = 0x1,
	DTYPE_CATACOMBS = 0x2,
	DTYPE_CAVES = 0x3,
	DTYPE_HELL = 0x4,
	DTYPE_NONE = 0xFF,
};

enum magic_type
{
	STYPE_FIRE = 0x0,
	STYPE_LIGHTNING = 0x1,
	STYPE_MAGIC = 0x2,
};

enum theme_id
{
	THEME_BARREL = 0x0,
	THEME_SHRINE = 0x1,
	THEME_MONSTPIT = 0x2,
	THEME_SKELROOM = 0x3,
	THEME_TREASURE = 0x4,
	THEME_LIBRARY = 0x5,
	THEME_TORTURE = 0x6,
	THEME_BLOODFOUNTAIN = 0x7,
	THEME_DECAPITATED = 0x8,
	THEME_PURIFYINGFOUNTAIN = 0x9,
	THEME_ARMORSTAND = 0xA,
	THEME_GOATSHRINE = 0xB,
	THEME_CAULDRON = 0xC,
	THEME_MURKYFOUNTAIN = 0xD,
	THEME_TEARFOUNTAIN = 0xE,
	THEME_BRNCROSS = 0xF,
	THEME_WEAPONRACK = 0x10,
	THEME_NONE = 0xFF,
};

enum event_type
{
	EVENT_TYPE_PLAYER_CREATE_GAME = 1,
	EVENT_TYPE_2 = 2,
	EVENT_TYPE_PLAYER_LEAVE_GAME = 3,
	EVENT_TYPE_PLAYER_MESSAGE = 4,
	EVENT_TYPE_5 = 5,
	EVENT_TYPE_6 = 6,
	EVENT_TYPE_7 = 7,
	EVENT_TYPE_8 = 8,
	EVENT_TYPE_9 = 9,
	EVENT_TYPE_10 = 10,
	EVENT_TYPE_11 = 11,
	EVENT_TYPE_12 = 12,
	EVENT_TYPE_13 = 13,
	EVENT_TYPE_14 = 14,
	EVENT_TYPE_15 = 15,
};

enum _copyprot_results
{
	COPYPROT_OK = 1,
	COPYPROT_CANCEL = 2,
};

enum text_color
{
	COL_WHITE = 0x0,
	COL_BLUE = 0x1,
	COL_RED = 0x2,
	COL_GOLD = 0x3,
};

enum _difficulty
{
	DIFF_NORMAL = 0x0,
	DIFF_NIGHTMARE = 0x1,
	DIFF_HELL = 0x2,
	NUM_DIFFICULTIES = 0x3,
};

enum MON_MODE
{
	MM_STAND = 0,
	MM_WALK = 1,
	MM_WALK2 = 2,
	MM_WALK3 = 3,
	MM_ATTACK = 4,
	MM_GOTHIT = 5,
	MM_DEATH = 6,
	MM_SATTACK = 7,
	MM_FADEIN = 8,
	MM_FADEOUT = 9,
	MM_RATTACK = 10,
	MM_SPSTAND = 11,
	MM_RSPATTACK = 12,
	MM_DELAY = 13,
	MM_CHARGE = 14,
	MM_STONE = 15,
	MM_HEAL = 16,
	MM_TALK = 17,
};

enum PLR_MODE
{
	PM_STAND = 0,
	PM_WALK = 1,
	PM_WALK2 = 2,
	PM_WALK3 = 3,
	PM_ATTACK = 4,
	PM_RATTACK = 5,
	PM_BLOCK = 6,
	PM_GOTHIT = 7,
	PM_DEATH = 8,
	PM_SPELL = 9,
	PM_NEWLVL = 10,
	PM_QUIT = 11,
};

enum template_id
{
	TEMPLATE_ERR_DX = 0x68,
	TEMPLATE_ERR_NOMEMORY = 0x69,
	TEMPLATE_ERR_NOFILE = 0x6A,
	TEMPLATE_ERR_DDRAW = 0x6B,
	TEMPLATE_ERR_DSOUND = 0x6C,
	TEMPLATE_ERR_DISKSPACE = 0x6E,
	TEMPLATE_ERR_VIDEOMODE = 0x6F,
	TEMPLATE_ERR_INSERTCD = 0x70,
	TEMPLATE_ERR_RESTRICTED = 0x71,
	TEMPLATE_ERR_READONLY = 0x72,
};

enum spell_type
{
	RSPLTYPE_SKILL = 0x0,
	RSPLTYPE_SPELL = 0x1,
	RSPLTYPE_SCROLL = 0x2,
	RSPLTYPE_CHARGES = 0x3,
	RSPLTYPE_INVALID = 0x4,
};

enum cursor_id
{
	CURSOR_NONE = 0x0,
	CURSOR_HAND = 0x1,
	CURSOR_IDENTIFY = 0x2,
	CURSOR_REPAIR = 0x3,
	CURSOR_RECHARGE = 0x4,
	CURSOR_DISARM = 0x5,
	CURSOR_OIL = 0x6,
	CURSOR_TELEKINESIS = 0x7,
	CURSOR_RESURRECT = 0x8,
	CURSOR_TELEPORT = 0x9,
	CURSOR_HEALOTHER = 0xA,
	CURSOR_HOURGLASS = 0xB,
	CURSOR_FIRSTITEM = 0xC,
};

enum direction
{
	DIR_S = 0x0,
	DIR_SW = 0x1,
	DIR_W = 0x2,
	DIR_NW = 0x3,
	DIR_N = 0x4,
	DIR_NE = 0x5,
	DIR_E = 0x6,
	DIR_SE = 0x7,
	DIR_OMNI = 0x8,
};

enum interface_mode
{
	WM_DIAB = 0x401,
	WM_DIABNEXTLVL = 0x402, // WM_USER+2
	WM_DIABPREVLVL = 0x403,
	WM_DIABRTNLVL = 0x404,
	WM_DIABSETLVL = 0x405,
	WM_DIABWARPLVL = 0x406,
	WM_DIABTOWNWARP = 0x407,
	WM_DIABTWARPUP = 0x408,
	WM_DIABRETOWN = 0x409,
	WM_DIABNEWGAME = 0x40A,
	WM_DIABLOADGAME = 0x40B
	// WM_LEIGHSKIP = 0x40C, // psx only
	// WM_DIAVNEWLVL = 0x40D, // psx only
};

enum game_info
{
	GAMEINFO_NAME           = 1,
	GAMEINFO_PASSWORD       = 2,
	GAMEINFO_STATS          = 3,
	GAMEINFO_MODEFLAG       = 4,
	GAMEINFO_GAMETEMPLATE   = 5,
	GAMEINFO_PLAYERS        = 6,
};

enum spell_id
{
	SPL_NULL = 0x0,
	SPL_FIREBOLT = 0x1,
	SPL_HEAL = 0x2,
	SPL_LIGHTNING = 0x3,
	SPL_FLASH = 0x4,
	SPL_IDENTIFY = 0x5,
	SPL_FIREWALL = 0x6,
	SPL_TOWN = 0x7,
	SPL_STONE = 0x8,
	SPL_INFRA = 0x9,
	SPL_RNDTELEPORT = 0xA,
	SPL_MANASHIELD = 0xB,
	SPL_FIREBALL = 0xC,
	SPL_GUARDIAN = 0xD,
	SPL_CHAIN = 0xE,
	SPL_WAVE = 0xF,
	SPL_DOOMSERP = 0x10,
	SPL_BLODRIT = 0x11,
	SPL_NOVA = 0x12,
	SPL_INVISIBIL = 0x13,
	SPL_FLAME = 0x14,
	SPL_GOLEM = 0x15,
	SPL_BLODBOIL = 0x16,
	SPL_TELEPORT = 0x17,
	SPL_APOCA = 0x18,
	SPL_ETHEREALIZE = 0x19,
	SPL_REPAIR = 0x1A,
	SPL_RECHARGE = 0x1B,
	SPL_DISARM = 0x1C,
	SPL_ELEMENT = 0x1D,
	SPL_CBOLT = 0x1E,
	SPL_HBOLT = 0x1F,
	SPL_RESURRECT = 0x20,
	SPL_TELEKINESIS = 0x21,
	SPL_HEALOTHER = 0x22,
	SPL_FLARE = 0x23,
	SPL_BONESPIRIT = 0x24,
	SPL_INVALID = 0xFFFFFFFF,
};

enum _cmd_id
{
	CMD_STAND = 0,
	CMD_WALKXY = 1,
	CMD_ACK_PLRINFO = 2,
	CMD_ADDSTR = 3,
	CMD_ADDMAG = 4,
	CMD_ADDDEX = 5,
	CMD_ADDVIT = 6,
	CMD_SBSPELL = 7,
	CMD_GETITEM = 8,
	CMD_AGETITEM = 9,
	CMD_PUTITEM = 10,
	CMD_RESPAWNITEM = 11,
	CMD_ATTACKXY = 12,
	CMD_RATTACKXY = 13,
	CMD_SPELLXY = 14,
	CMD_TSPELLXY = 15,
	CMD_OPOBJXY = 16,
	CMD_DISARMXY = 17,
	CMD_ATTACKID = 18,
	CMD_ATTACKPID = 19,
	CMD_RATTACKID = 20,
	CMD_RATTACKPID = 21,
	CMD_SPELLID = 22,
	CMD_SPELLPID = 23,
	CMD_TSPELLID = 24,
	CMD_TSPELLPID = 25,
	CMD_RESURRECT = 26,
	CMD_OPOBJT = 27,
	CMD_KNOCKBACK = 28,
	CMD_TALKXY = 29,
	CMD_NEWLVL = 30,
	CMD_WARP = 31,
	CMD_CHEAT_EXPERIENCE = 32,
	CMD_CHEAT_SPELL_LEVEL = 33,
	CMD_DEBUG = 34,
	CMD_SYNCDATA = 35,
	CMD_MONSTDEATH = 36,
	CMD_MONSTDAMAGE = 37,
	CMD_PLRDEAD = 38,
	CMD_REQUESTGITEM = 39,
	CMD_REQUESTAGITEM = 40,
	CMD_GOTOGETITEM = 41,
	CMD_GOTOAGETITEM = 42,
	CMD_OPENDOOR = 43,
	CMD_CLOSEDOOR = 44,
	CMD_OPERATEOBJ = 45,
	CMD_PLROPOBJ = 46,
	CMD_BREAKOBJ = 47,
	CMD_CHANGEPLRITEMS = 48,
	CMD_DELPLRITEMS = 49,
	CMD_PLRDAMAGE = 50,
	CMD_PLRLEVEL = 51,
	CMD_DROPITEM = 52,
	CMD_PLAYER_JOINLEVEL = 53,
	CMD_SEND_PLRINFO = 54,
	CMD_SATTACKXY = 55,
	CMD_ACTIVATEPORTAL = 56,
	CMD_DEACTIVATEPORTAL = 57,
	CMD_DLEVEL_0 = 58,
	CMD_DLEVEL_1 = 59,
	CMD_DLEVEL_2 = 60,
	CMD_DLEVEL_3 = 61,
	CMD_DLEVEL_4 = 62,
	CMD_DLEVEL_5 = 63,
	CMD_DLEVEL_6 = 64,
	CMD_DLEVEL_7 = 65,
	CMD_DLEVEL_8 = 66,
	CMD_DLEVEL_9 = 67,
	CMD_DLEVEL_10 = 68,
	CMD_DLEVEL_11 = 69,
	CMD_DLEVEL_12 = 70,
	CMD_DLEVEL_13 = 71,
	CMD_DLEVEL_14 = 72,
	CMD_DLEVEL_15 = 73,
	CMD_DLEVEL_16 = 74,
	CMD_DLEVEL_JUNK = 75,
	CMD_DLEVEL_END = 76,
	CMD_HEALOTHER = 77,
	CMD_STRING = 78,
	CMD_SETSTR = 79,
	CMD_SETMAG = 80,
	CMD_SETDEX = 81,
	CMD_SETVIT = 82,
	CMD_RETOWN = 83,
	CMD_SPELLXYD = 84,
	CMD_ITEMEXTRA = 85,
	CMD_SYNCPUTITEM = 86,
	CMD_KILLGOLEM = 87,
	CMD_SYNCQUEST = 88,
	CMD_ENDSHIELD = 89,
	CMD_AWAKEGOLEM = 90,
	CMD_NOVA = 91,
	CMD_SETSHIELD = 92,
	CMD_REMSHIELD = 93,
	FAKE_CMD_SETID = 94,
	FAKE_CMD_DROPID = 95,
	NUM_CMDS = 96,
};

enum _talker_id
{
	TOWN_SMITH = 0x0,
	TOWN_HEALER = 0x1,
	TOWN_DEADGUY = 0x2,
	TOWN_TAVERN = 0x3,
	TOWN_STORY = 0x4,
	TOWN_DRUNK = 0x5,
	TOWN_WITCH = 0x6,
	TOWN_BMAID = 0x7,
	TOWN_PEGBOY = 0x8,
	TOWN_COW = 0x9,
	TOWN_PRIEST = 0xA,
};

enum _music_id
{
	TMUSIC_TOWN = 0,
	TMUSIC_L1 = 1,
	TMUSIC_L2 = 2,
	TMUSIC_L3 = 3,
	TMUSIC_L4 = 4,
	TMUSIC_INTRO = 5,
	NUM_MUSIC = 6,
};

enum _mainmenu_selections
{
	MAINMENU_SINGLE_PLAYER = 1,
	MAINMENU_MULTIPLAYER = 2,
	MAINMENU_REPLAY_INTRO = 3,
	MAINMENU_SHOW_CREDITS = 4,
	MAINMENU_EXIT_DIABLO = 5,
	MAINMENU_ATTRACT_MODE = 6,
};

enum panel_button_id
{
	PANBTN_CHARINFO = 0,
	PANBTN_QLOG = 1,
	PANBTN_AUTOMAP = 2,
	PANBTN_MAINMENU = 3,
	PANBTN_INVENTORY = 4,
	PANBTN_SPELLBOOK = 5,
	PANBTN_SENDMSG = 6,
	PANBTN_FRIENDLY = 7,
};

enum attribute_id
{
	ATTRIB_STR = 0,
	ATTRIB_MAG = 1,
	ATTRIB_DEX = 2,
	ATTRIB_VIT = 3,
};

enum _object_id
{
	OBJ_L1LIGHT = 0x0,
	OBJ_L1LDOOR = 0x1,
	OBJ_L1RDOOR = 0x2,
	OBJ_SKFIRE = 0x3,
	OBJ_LEVER = 0x4,
	OBJ_CHEST1 = 0x5,
	OBJ_CHEST2 = 0x6,
	OBJ_CHEST3 = 0x7,
	OBJ_CANDLE1 = 0x8,
	OBJ_CANDLE2 = 0x9,
	OBJ_CANDLEO = 0xA,
	OBJ_BANNERL = 0xB,
	OBJ_BANNERM = 0xC,
	OBJ_BANNERR = 0xD,
	OBJ_SKPILE = 0xE,
	OBJ_SKSTICK1 = 0xF,
	OBJ_SKSTICK2 = 0x10,
	OBJ_SKSTICK3 = 0x11,
	OBJ_SKSTICK4 = 0x12,
	OBJ_SKSTICK5 = 0x13,
	OBJ_CRUX1 = 0x14,
	OBJ_CRUX2 = 0x15,
	OBJ_CRUX3 = 0x16,
	OBJ_STAND = 0x17,
	OBJ_ANGEL = 0x18,
	OBJ_BOOK2L = 0x19,
	OBJ_BCROSS = 0x1A,
	OBJ_NUDEW2R = 0x1B,
	OBJ_SWITCHSKL = 0x1C,
	OBJ_TNUDEM1 = 0x1D,
	OBJ_TNUDEM2 = 0x1E,
	OBJ_TNUDEM3 = 0x1F,
	OBJ_TNUDEM4 = 0x20,
	OBJ_TNUDEW1 = 0x21,
	OBJ_TNUDEW2 = 0x22,
	OBJ_TNUDEW3 = 0x23,
	OBJ_TORTURE1 = 0x24,
	OBJ_TORTURE2 = 0x25,
	OBJ_TORTURE3 = 0x26,
	OBJ_TORTURE4 = 0x27,
	OBJ_TORTURE5 = 0x28,
	OBJ_BOOK2R = 0x29,
	OBJ_L2LDOOR = 0x2A,
	OBJ_L2RDOOR = 0x2B,
	OBJ_TORCHL = 0x2C,
	OBJ_TORCHR = 0x2D,
	OBJ_TORCHL2 = 0x2E,
	OBJ_TORCHR2 = 0x2F,
	OBJ_SARC = 0x30,
	OBJ_FLAMEHOLE = 0x31,
	OBJ_FLAMELVR = 0x32,
	OBJ_WATER = 0x33,
	OBJ_BOOKLVR = 0x34,
	OBJ_TRAPL = 0x35,
	OBJ_TRAPR = 0x36,
	OBJ_BOOKSHELF = 0x37,
	OBJ_WEAPRACK = 0x38,
	OBJ_BARREL = 0x39,
	OBJ_BARRELEX = 0x3A,
	OBJ_SHRINEL = 0x3B,
	OBJ_SHRINER = 0x3C,
	OBJ_SKELBOOK = 0x3D,
	OBJ_BOOKCASEL = 0x3E,
	OBJ_BOOKCASER = 0x3F,
	OBJ_BOOKSTAND = 0x40,
	OBJ_BOOKCANDLE = 0x41,
	OBJ_BLOODFTN = 0x42,
	OBJ_DECAP = 0x43,
	OBJ_TCHEST1 = 0x44,
	OBJ_TCHEST2 = 0x45,
	OBJ_TCHEST3 = 0x46,
	OBJ_BLINDBOOK = 0x47,
	OBJ_BLOODBOOK = 0x48,
	OBJ_PEDISTAL = 0x49,
	OBJ_L3LDOOR = 0x4A,
	OBJ_L3RDOOR = 0x4B,
	OBJ_PURIFYINGFTN = 0x4C,
	OBJ_ARMORSTAND = 0x4D,
	OBJ_ARMORSTANDN = 0x4E,
	OBJ_GOATSHRINE = 0x4F,
	OBJ_CAULDRON = 0x50,
	OBJ_MURKYFTN = 0x51,
	OBJ_TEARFTN = 0x52,
	OBJ_ALTBOY = 0x53,
	OBJ_MCIRCLE1 = 0x54,
	OBJ_MCIRCLE2 = 0x55,
	OBJ_STORYBOOK = 0x56,
	OBJ_STORYCANDLE = 0x57,
	OBJ_STEELTOME = 0x58,
	OBJ_WARARMOR = 0x59,
	OBJ_WARWEAP = 0x5A,
	OBJ_TBCROSS = 0x5B,
	OBJ_WEAPONRACK = 0x5C,
	OBJ_WEAPONRACKN = 0x5D,
	OBJ_MUSHPATCH = 0x5E,
	OBJ_LAZSTAND = 0x5F,
	OBJ_SLAINHERO = 0x60,
	OBJ_SIGNCHEST = 0x61,
	OBJ_NULL_98 = 0x62,
};

enum item_misc_id
{
	IMISC_NONE = 0x0,
	IMISC_USEFIRST = 0x1,
	IMISC_FULLHEAL = 0x2,
	IMISC_HEAL = 0x3,
	IMISC_OLDHEAL = 0x4,
	IMISC_DEADHEAL = 0x5,
	IMISC_MANA = 0x6,
	IMISC_FULLMANA = 0x7,
	IMISC_POTEXP = 0x8, /* add experience */
	IMISC_POTFORG = 0x9, /* remove experience */
	IMISC_ELIXSTR = 0xA,
	IMISC_ELIXMAG = 0xB,
	IMISC_ELIXDEX = 0xC,
	IMISC_ELIXVIT = 0xD,
	IMISC_ELIXWEAK = 0xE, /* double check with alpha */
	IMISC_ELIXDIS = 0xF,
	IMISC_ELIXCLUM = 0x10,
	IMISC_ELIXSICK = 0x11,
	IMISC_REJUV = 0x12,
	IMISC_FULLREJUV = 0x13,
	IMISC_USELAST = 0x14,
	IMISC_SCROLL = 0x15,
	IMISC_SCROLLT = 0x16,
	IMISC_STAFF = 0x17,
	IMISC_BOOK = 0x18,
	IMISC_RING = 0x19,
	IMISC_AMULET = 0x1A,
	IMISC_UNIQUE = 0x1B,
	IMISC_HEAL_1C = 0x1C,
	IMISC_OILFIRST = 0x1D,
	IMISC_OILOF = 0x1E, /* oils are beta or hellfire only */
	IMISC_OILACC = 0x1F,
	IMISC_OILMAST = 0x20,
	IMISC_OILSHARP = 0x21,
	IMISC_OILDEATH = 0x22,
	IMISC_OILSKILL = 0x23,
	IMISC_OILBSMTH = 0x24,
	IMISC_OILFORT = 0x25,
	IMISC_OILPERM = 0x26,
	IMISC_OILHARD = 0x27,
	IMISC_OILIMP = 0x28,
	IMISC_OILLAST = 0x29,
	IMISC_MAPOFDOOM = 0x2A,
	IMISC_EAR = 0x2B,
	IMISC_SPECELIX = 0x2C,
	IMISC_INVALID = 0xFFFFFFFF,
};

enum item_type
{
	ITYPE_MISC = 0x0,
	ITYPE_SWORD = 0x1,
	ITYPE_AXE = 0x2,
	ITYPE_BOW = 0x3,
	ITYPE_MACE = 0x4,
	ITYPE_SHIELD = 0x5,
	ITYPE_LARMOR = 0x6,
	ITYPE_HELM = 0x7,
	ITYPE_MARMOR = 0x8,
	ITYPE_HARMOR = 0x9,
	ITYPE_STAFF = 0xA,
	ITYPE_GOLD = 0xB,
	ITYPE_RING = 0xC,
	ITYPE_AMULET = 0xD,
	ITYPE_0E = 0xE,
	ITYPE_NONE = 0xFFFFFFFF,
};

enum _item_indexes
{
	IDI_GOLD = 0x0,
	IDI_WARRIOR = 0x1,
	IDI_WARRSHLD = 0x2,
	IDI_WARRCLUB = 0x3,
	IDI_ROGUE = 0x4,
	IDI_SORCEROR = 0x5,
	IDI_CLEAVER = 0x6,
	IDI_FIRSTQUEST = 0x6,
	IDI_SKCROWN = 0x7,
	IDI_INFRARING = 0x8,
	IDI_ROCK = 0x9,
	IDI_OPTAMULET = 0xA,
	IDI_TRING = 0xB,
	IDI_BANNER = 0xC,
	IDI_HARCREST = 0xD,
	IDI_STEELVEIL = 0xE,
	IDI_GLDNELIX = 0xF,
	IDI_ANVIL = 0x10,
	IDI_MUSHROOM = 0x11,
	IDI_BRAIN = 0x12,
	IDI_FUNGALTM = 0x13,
	IDI_SPECELIX = 0x14,
	IDI_BLDSTONE = 0x15,
	IDI_LASTQUEST = 0x16,
	IDI_MAPOFDOOM = 0x16,
	IDI_EAR = 0x17,
	IDI_HEAL = 0x18,
	IDI_MANA = 0x19,
	IDI_IDENTIFY = 0x1A,
	IDI_PORTAL = 0x1B,
	IDI_ARMOFVAL = 0x1C,
	IDI_FULLHEAL = 0x1D,
	IDI_FULLMANA = 0x1E,
	IDI_GRISWOLD = 0x1F,
	IDI_LGTFORGE = 0x20,
	IDI_LAZSTAFF = 0x21,
	IDI_RESURRECT = 0x22,
};

enum _setlevels
{
	//SL_BUTCHCHAMB = 0x0,
	SL_SKELKING = 0x1,
	SL_BONECHAMB = 0x2,
	SL_MAZE = 0x3,
	SL_POISONWATER = 0x4,
	SL_VILEBETRAYER = 0x5,
};

enum quest_id
{
	QTYPE_INFRA = 0x0,
	QTYPE_BLKM = 0x1,
	QTYPE_GARB = 0x2,
	QTYPE_ZHAR = 0x3,
	QTYPE_VEIL = 0x4,
	QTYPE_MOD = 0x5,
	QTYPE_BUTCH = 0x6,
	QTYPE_BOL = 0x7,
	QTYPE_BLIND = 0x8,
	QTYPE_BLOOD = 0x9,
	QTYPE_ANVIL = 0xA,
	QTYPE_WARLRD = 0xB,
	QTYPE_KING = 0xC,
	QTYPE_PW = 0xD,
	QTYPE_BONE = 0xE,
	QTYPE_VB = 0xF,
	QTYPE_INVALID = 0xFFFFFFFF,
};

enum talk_id
{
	STORE_NONE = 0x0,
	STORE_SMITH = 0x1,
	STORE_SBUY = 0x2,
	STORE_SSELL = 0x3,
	STORE_SREPAIR = 0x4,
	STORE_WITCH = 0x5,
	STORE_WBUY = 0x6,
	STORE_WSELL = 0x7,
	STORE_WRECHARGE = 0x8,
	STORE_NOMONEY = 0x9,
	STORE_NOROOM = 0xA,
	STORE_CONFIRM = 0xB,
	STORE_BOY = 0xC,
	STORE_BBOY = 0xD,
	STORE_HEALER = 0xE,
	STORE_STORY = 0xF,
	STORE_HBUY = 0x10,
	STORE_SIDENTIFY = 0x11,
	STORE_SPBUY = 0x12,
	STORE_GOSSIP = 0x13,
	STORE_IDSHOW = 0x14,
	STORE_TAVERN = 0x15,
	STORE_DRUNK = 0x16,
	STORE_BARMAID = 0x17,
};

enum _unique_items
{
	UITEM_CLEAVER = 0x0,
	UITEM_SKCROWN = 0x1,
	UITEM_INFRARING = 0x2,
	UITEM_OPTAMULET = 0x3,
	UITEM_TRING = 0x4,
	UITEM_HARCREST = 0x5,
	UITEM_STEELVEIL = 0x6,
	UITEM_ARMOFVAL = 0x7,
	UITEM_GRISWOLD = 0x8,
	UITEM_LGTFORGE = 0x9,
	UITEM_RIFTBOW = 0xA,
	UITEM_NEEDLER = 0xB,
	UITEM_CELESTBOW = 0xC,
	UITEM_DEADLYHUNT = 0xD,
	UITEM_BOWOFDEAD = 0xE,
	UITEM_BLKOAKBOW = 0xF,
	UITEM_FLAMEDART = 0x10,
	UITEM_FLESHSTING = 0x11,
	UITEM_WINDFORCE = 0x12,
	UITEM_EAGLEHORN = 0x13,
	UITEM_GONNAGALDIRK = 0x14,
	UITEM_DEFENDER = 0x15,
	UITEM_GRYPHONCLAW = 0x16,
	UITEM_BLACKRAZOR = 0x17,
	UITEM_GIBBOUSMOON = 0x18,
	UITEM_ICESHANK = 0x19,
	UITEM_EXECUTIONER = 0x1A,
	UITEM_BONESAW = 0x1B,
	UITEM_SHADHAWK = 0x1C,
	UITEM_WIZSPIKE = 0x1D,
	UITEM_LGTSABRE = 0x1E,
	UITEM_FALCONTALON = 0x1F,
	UITEM_INFERNO = 0x20,
	UITEM_DOOMBRINGER = 0x21,
	UITEM_GRIZZLY = 0x22,
	UITEM_GRANDFATHER = 0x23,
	UITEM_MANGLER = 0x24,
	UITEM_SHARPBEAK = 0x25,
	UITEM_BLOODLSLAYER = 0x26,
	UITEM_CELESTAXE = 0x27,
	UITEM_WICKEDAXE = 0x28,
	UITEM_STONECLEAV = 0x29,
	UITEM_AGUHATCHET = 0x2A,
	UITEM_HELLSLAYER = 0x2B,
	UITEM_MESSERREAVER = 0x2C,
	UITEM_CRACKRUST = 0x2D,
	UITEM_JHOLMHAMM = 0x2E,
	UITEM_CIVERBS = 0x2F,
	UITEM_CELESTSTAR = 0x30,
	UITEM_BARANSTAR = 0x31,
	UITEM_GNARLROOT = 0x32,
	UITEM_CRANBASH = 0x33,
	UITEM_SCHAEFHAMM = 0x34,
	UITEM_DREAMFLANGE = 0x35,
	UITEM_STAFFOFSHAD = 0x36,
	UITEM_IMMOLATOR = 0x37,
	UITEM_STORMSPIRE = 0x38,
	UITEM_GLEAMSONG = 0x39,
	UITEM_THUNDERCALL = 0x3A,
	UITEM_PROTECTOR = 0x3B,
	UITEM_NAJPUZZLE = 0x3C,
	UITEM_MINDCRY = 0x3D,
	UITEM_RODOFONAN = 0x3E,
	UITEM_SPIRITSHELM = 0x3F,
	UITEM_THINKINGCAP = 0x40,
	UITEM_OVERLORDHELM = 0x41,
	UITEM_FOOLSCREST = 0x42,
	UITEM_GOTTERDAM = 0x43,
	UITEM_ROYCIRCLET = 0x44,
	UITEM_TORNFLESH = 0x45,
	UITEM_GLADBANE = 0x46,
	UITEM_RAINCLOAK = 0x47,
	UITEM_LEATHAUT = 0x48,
	UITEM_WISDWRAP = 0x49,
	UITEM_SPARKMAIL = 0x4A,
	UITEM_SCAVCARAP = 0x4B,
	UITEM_NIGHTSCAPE = 0x4C,
	UITEM_NAJPLATE = 0x4D,
	UITEM_DEMONSPIKE = 0x4E,
	UITEM_DEFLECTOR = 0x4F,
	UITEM_SKULLSHLD = 0x50,
	UITEM_DRAGONBRCH = 0x51,
	UITEM_BLKOAKSHLD = 0x52,
	UITEM_HOLYDEF = 0x53,
	UITEM_STORMSHLD = 0x54,
	UITEM_BRAMBLE = 0x55,
	UITEM_REGHA = 0x56,
	UITEM_BLEEDER = 0x57,
	UITEM_CONSTRICT = 0x58,
	UITEM_ENGAGE = 0x59,
	UITEM_INVALID = 0x5A,
};

enum _ui_classes
{
	UI_WARRIOR = 0x0,
	UI_ROGUE = 0x1,
	UI_SORCERER = 0x2,
	UI_NUM_CLASSES = 0x3,
};

enum _walk_path
{
	WALK_NONE = 0x0,
	WALK_NE = 0x1,
	WALK_NW = 0x2,
	WALK_SE = 0x3,
	WALK_SW = 0x4,
	WALK_N = 0x5,
	WALK_E = 0x6,
	WALK_S = 0x7,
	WALK_W = 0x8,
};

typedef enum {
	ICLASS_NONE = 0,
	ICLASS_WEAPON = 1,
	ICLASS_ARMOR = 2,
	ICLASS_MISC = 3,
	ICLASS_GOLD = 4,
	ICLASS_QUEST = 5,
} item_class;

typedef enum {
	IDROP_NEVER   = 0,
	IDROP_REGULAR = 1,
	IDROP_DOUBLE  = 2,
} item_drop_rate;

typedef enum {
	ISPL_NONE = 0x00000000,
	ISPL_INFRAVISION = 0x00000001,
	ISPL_RNDSTEALLIFE = 0x00000002,
	ISPL_RNDARROWVEL = 0x00000004,
	ISPL_FIRE_ARROWS = 0x00000008,
	ISPL_FIREDAM = 0x00000010,
	ISPL_LIGHTDAM = 0x00000020,
	ISPL_DRAINLIFE = 0x00000040,
	ISPL_UNKNOWN_1 = 0x00000080,
	ISPL_NOHEALPLR = 0x00000100,
	ISPL_UNKNOWN_2 = 0x00000200,
	ISPL_UNKNOWN_3 = 0x00000400,
	ISPL_KNOCKBACK = 0x00000800,
	ISPL_NOHEALMON = 0x00001000,
	ISPL_STEALMANA_3 = 0x00002000,
	ISPL_STEALMANA_5 = 0x00004000,
	ISPL_STEALLIFE_3 = 0x00008000,
	ISPL_STEALLIFE_5 = 0x00010000,
	ISPL_QUICKATTACK = 0x00020000,
	ISPL_FASTATTACK = 0x00040000,
	ISPL_FASTERATTACK = 0x00080000,
	ISPL_FASTESTATTACK = 0x00100000,
	ISPL_FASTRECOVER = 0x00200000,
	ISPL_FASTERRECOVER = 0x00400000,
	ISPL_FASTESTRECOVER = 0x00800000,
	ISPL_FASTBLOCK = 0x01000000,
	ISPL_LIGHT_ARROWS = 0x02000000,
	ISPL_THORNS = 0x04000000,
	ISPL_NOMANA = 0x08000000,
	ISPL_ABSHALFTRAP = 0x10000000,
	ISPL_UNKNOWN_4 = 0x20000000,
	ISPL_3XDAMVDEM = 0x40000000,
	ISPL_ALLRESZERO = 0x80000000,
} item_special_effect;
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Diablo.rc
//
#define IDI_ICON1                       101
#define IDD_DIALOG1                     104
#define IDD_DIALOG2                     105
#define IDD_DIALOG3                     106
#define IDD_DIALOG4                     107
#define IDD_DIALOG5                     108
#define IDD_DIALOG6                     109
#define IDD_DIALOG7                     110
#define IDD_DIALOG8                     111
#define IDD_DIALOG9                     112
#define IDD_DIALOG10                    113
#define IDD_DIALOG11                    114

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
struct UItemStruct
{
	char *UIName;
	char UIItemId;
	char UIMinLvl;
	char UINumPL;
	int UIValue;
	char UIPower1;
	int UIParam1;
	int UIParam2;
	char UIPower2;
	int UIParam3;
	int UIParam4;
	char UIPower3;
	int UIParam5;
	int UIParam6;
	char UIPower4;
	int UIParam7;
	int UIParam8;
	char UIPower5;
	int UIParam9;
	int UIParam10;
	char UIPower6;
	int UIParam11;
	int UIParam12;
};

struct PLStruct
{
	const char *PLName;
	char PLPower;
	int PLParam1;
	int PLParam2;
	int PLMinLvl;
	int PLIType;
	int PLGOE;
	int PLDouble;
	int PLOk;
	int PLMinVal;
	int PLMaxVal;
	int PLMultVal;
};

struct TextDataStruct
{
	char *txtstr;
	int scrlltxt;
	int txtspd;
	int sfxnr;
};

struct RECT32
{
	int x;
	int y;
	int w;
	int h;
};

struct TSnd
{
	WAVEFORMATEX fmt;
	int len;
	int offset;
	char *sound_path;
	IDirectSoundBuffer *DSB;
	int start_tc;
};

struct TSFX
{
	unsigned char bFlags;
	char *pszName;
	TSnd *pSnd;
};

struct TMenuItem
{
	unsigned int dwFlags;
	char *pszStr;
	void (__cdecl *fnMenu)(); /* fix, should have one arg */
};

struct ItemDataStruct
{
	int iRnd;
	char iClass;
	char iLoc;
	int iCurs;
	char itype;
	char iItemId;
	char *iName;
	char *iSName;
	int iMinMLvl;
	int iDurability;
	int iMinDam;
	int iMaxDam;
	int iMinAC;
	int iMaxAC;
	char iMinStr;
	char iMinMag;
	char iMinDex;
	int iFlags;
	int iMiscId;
	int iSpell;
	int iUsable;
	int iValue;
	int iMaxValue;
};

struct MissileData
{
	unsigned char mName;
	void (__fastcall *mAddProc)(int, int, int, int, int, int, int, int, int);
	void (__fastcall *mProc)(int);
	int mDraw;
	unsigned char mType;
	unsigned char mResist;
	unsigned char mFileNum;
	int mlSFX;
	int miSFX;
};

struct MisFileData
{
	unsigned char mAnimName;
	unsigned char mAnimFAmt;
	char *mName;
	int mFlags;
	int mAnimData[16]; // unsigned char *
	unsigned char mAnimDelay[16];
	unsigned char mAnimLen[16];
	int mAnimWidth[16];
	int mAnimWidth2[16];
};

struct MonsterData
{
	int flags; // width?
	int mType;
	char *GraphicType;
	int has_special;
	char *sndfile;
	int snd_special;
	int has_trans;
	char *TransFile;
	int Frames[6];
	int Rate[6];
	char *mName;
	char mMinDLvl;
	char mMaxDLvl;
	char mLevel;
	int mMinHP;
	int mMaxHP;
	char mAi;
	int mFlags;
	unsigned char mInt;
	unsigned char mHit;
	unsigned char mAFNum;
	unsigned char mMinDamage;
	unsigned char mMaxDamage;
	unsigned char mHit2;
	unsigned char mAFNum2;
	unsigned char mMinDamage2;
	unsigned char mMaxDamage2;
	char mArmorClass;
	char mMonstClass;
	unsigned short mMagicRes;
	unsigned short mMagicRes2;
	unsigned short mTreasure;
	char mSelFlag;
	unsigned short mExp;
};

struct UniqMonstStruct
{
	char mtype;
	char *mName;
	char *mMode;
	unsigned char mlevel;
	unsigned short mmaxhp;
	unsigned char mAi;
	unsigned char mint;
	unsigned char mMinDamage;
	unsigned char mMaxDamage;
	unsigned short mMagicRes;
	unsigned short mUnqAttr;
	unsigned char mUnqVar1;
	unsigned char mUnqVar2;
	int mtalkmsg;
};

struct ObjDataStruct
{
	char oload;
	char ofindex;
	char ominlvl;
	char omaxlvl;
	char olvltype;
	char otheme;
	char oquest;
	int oAnimFlag;
	int oAnimDelay;
	int oAnimLen;
	int oAnimWidth;
	int oSolidFlag;
	int oMissFlag;
	int oLightFlag;
	char oBreak;
	char oSelFlag;
	int oTrapFlag;
};

struct QuestData
{
	unsigned char _qdlvl;
	char _qdmultlvl;
	unsigned char _qlvlt;
	unsigned char _qdtype;
	unsigned char _qdrnd;
	unsigned char _qslvl;
	int _qflags; //__declspec(align(4)) /* unsigned char */
	int _qdmsg;
	char *_qlstr;
};

struct SpellData
{
	unsigned char sName;
	unsigned char sManaCost;
	unsigned char sType;
	char *sNameText;
	char *sSkillText;
	int sBookLvl;
	int sStaffLvl;
	int sTargeted;
	unsigned char sTownSpell;
	int sMinInt;
	unsigned char sSFX;
	unsigned char sMissiles[3];
	unsigned char sManaAdj;
	unsigned char sMinMana;
	int sStaffMin;
	int sStaffMax;
	int sBookCost;
	int sStaffCost;
};

struct Coord
{
	char x;
	char y;
};

struct RECT8
{
	Coord x;
	Coord y;
};

struct QuestTalkData
{
	int _qinfra;
	int _qblkm;
	int _qgarb;
	int _qzhar;
	int _qveil;
	int _qmod;
	int _qbutch;
	int _qbol;
	int _qblind;
	int _qblood;
	int _qanvil;
	int _qwarlrd;
	int _qking;
	int _qpw;
	int _qbone;
	int _qvb;
};

struct ShadowStruct
{
	unsigned char strig;
	unsigned char s1;
	unsigned char s2;
	unsigned char s3;
	unsigned char nv1;
	unsigned char nv2;
	unsigned char nv3;
};

struct POINT32 /* remove this struct */
{
	int x;
	int y;
};

struct InvXY
{
	int X;
	int Y;
};

struct ItemStruct
{
	int _iSeed;
	unsigned short _iCreateInfo;
	int _itype;
	int _ix;
	int _iy;
	int _iAnimFlag;
	int _iAnimData; // unsigned char *
	int _iAnimLen;
	int _iAnimFrame;
	int _iAnimWidth;
	int _iAnimWidth2; // width 2?
	int offs002C;
	char _iSelFlag;
	int _iPostDraw;
	int _iIdentified;
	char _iMagical;
	char _iName[64];
	char _iIName[64];
	char _iLoc;
	char _iClass;
	int _iCurs;
	int _ivalue;
	int _iIvalue;
	int _iMinDam;
	int _iMaxDam;
	int _iAC;
	int _iFlags;
	int _iMiscId;
	int _iSpell;
	int _iCharges;
	int _iMaxCharges;
	int _iDurability;
	int _iMaxDur;
	int _iPLDam;
	int _iPLToHit;
	int _iPLAC;
	int _iPLStr;
	int _iPLMag;
	int _iPLDex;
	int _iPLVit;
	int _iPLFR;
	int _iPLLR;
	int _iPLMR;
	int _iPLMana;
	int _iPLHP;
	int _iPLDamMod;
	int _iPLGetHit;
	int _iPLLight;
	char _iSplLvlAdd;
	char _iRequest;
	int _iUid;
	int _iFMinDam;
	int _iFMaxDam;
	int _iLMinDam;
	int _iLMaxDam;
	int _iPLEnAc;
	char _iPrePower;
	char _iSufPower;
	int _iVAdd1;
	int _iVMult1;
	int _iVAdd2;
	int _iVMult2;
	char _iMinStr;
	unsigned char _iMinMag;
	char _iMinDex;
	int _iStatFlag;
	int IDidx;
	int offs016C;
};

struct DeadStruct
{
	int _deadData[8]; // unsigned char *
	int _deadFrame;
	int field_24; // width
	int field_28; // cel or fnum _deadtype?
	int _deadtrans;
};

struct ScreenRow
{
	char col_unused_1[64];
	char pixels[640];
	char col_unused_2[64];
};

struct Screen
{
	ScreenRow row_unused_1[160];
	ScreenRow row[480];
	ScreenRow row_unused_2[16];
};

struct Tile
{
	short top;
	short right;
	short left;
	short bottom;
};

struct DPiece
{
	short blocks;
};

struct _SNETVERSIONDATA
{
	int size;
	char *versionstring;
	char *executablefile;
	char *originalarchivefile;
	char *patcharchivefile;
};

struct LightListStruct
{
	int _lx;
	int _ly;
	int _lradius;
	int _lid;
	int _ldel;
	int _lunflag;
	int field_18;
	int _lunx;
	int _luny;
	int _lunr;
	int _xoff;
	int _yoff;
	int _lflags;
};

struct MissileStruct
{
	int _mitype;
	int _mix;
	int _miy;
	int _mixoff;
	int _miyoff;
	int _mixvel;
	int _miyvel;
	int _misx;
	int _misy;
	int _mitxoff;
	int _mityoff;
	int _mimfnum;
	int _mispllvl;
	int _miDelFlag;
	int _miAnimType;
	int _miAnimFlags;
	int _miAnimData; // unsigned char *
	int _miAnimDelay;
	int _miAnimLen;
	int _miAnimWidth;
	int _miAnimWidth2;
	int _miAnimCnt;
	int _miAnimAdd;
	int _miAnimFrame;
	int _miDrawFlag;
	int _miLightFlag;
	int _miPreFlag;
	int _miUniqTrans;
	int _mirange;
	int _misource;
	int _micaster;
	int _midam;
	int _miHitFlag;
	int _midist;
	int _mlid;
	int _mirnd;
	int _miVar1;
	int _miVar2;
	int _miVar3;
	int _miVar4;
	int _miVar5;
	int _miVar6;
	int _miVar7;
	int _miVar8;
};

struct AnimStruct
{
	int CMem; // [unsigned] char * ??
	int Frames[8]; // unsigned char *
	int Rate;
	int Delay;
};

struct CMonster
{
	unsigned char mtype;
	unsigned char mPlaceFlags;
	AnimStruct Anims[6];
	TSnd *Snds[8];
	int flags_1; // width
	int flags_2; // width 2
	unsigned char mMinHP;
	unsigned char mMaxHP;
	int has_special;
	unsigned char mAFNum;
	char mdeadval;
	MonsterData *MData;
	void *trans_file;
};

struct MonsterStruct
{
	int _mMTidx;
	int _mmode;
	int _mgoal;
	int _mgoalvar1;
	int _mgoalvar2;
	int _mgoalvar3;
	int field_18;
	int _pathcount;
	int _mx;
	int _my;
	int _mfutx;
	int _mfuty;
	int _moldx;
	int _moldy;
	int _mxoff;
	int _myoff;
	int _mxvel;
	int _myvel;
	int _mdir;
	int _menemy;
	unsigned char _menemyx;
	unsigned char _menemyy;
	short falign_52;
	int _mAFNum;
	int _mAnimDelay;
	int _mAnimCnt;
	int _mAnimLen;
	int _mAnimFrame;
	int _meflag;
	int _mDelFlag;
	int _mVar1;
	int _mVar2;
	int _mVar3;
	int _mVar4;
	int _mVar5;
	int _mVar6;
	int _mVar7;
	int _mVar8;
	int _mmaxhp;
	int _mhitpoints;
	unsigned char _mAi;
	unsigned char _mint;
	short falign_9A;
	int _mFlags;
	int _msquelch;
	int falign_A4;
	int _lastx;
	int _lasty;
	int _mRndSeed;
	int _mAISeed;
	int falign_B8;
	unsigned char _uniqtype;
	unsigned char _uniqtrans;
	char _udeadval;
	char mWhoHit;
	short mLevel; /* char */
	unsigned short mExp;
	unsigned char mHit;
	unsigned char mMinDamage;
	unsigned char mMaxDamage;
	unsigned char mHit2;
	unsigned char mMinDamage2;
	unsigned char mMaxDamage2;
	char mArmorClass;
	char falign_CB;
	int mMagicRes; /* ushort */
	int mtalkmsg;
	unsigned char leader;
	unsigned char leaderflag;
	unsigned char unpackfilesize;
	unsigned char mlid;
	char *mName;
	CMonster *MType;
	MonsterData *MData;
};

struct DObjectStr
{
	unsigned char bCmd;
};

/* __declspec(align(1))*/
#pragma pack(push, 1)
struct  DMonsterStr
{
	char _mx; /* these might be unsigned */
	char _my;
	char _mdir;
	char _menemy;
	char _mactive;
	int _mhitpoints;
};
#pragma pack(pop)

/* __declspec(align(2))*/
#pragma pack(push, 1)
struct  TCmdPItem
{
	char bCmd; /* unsigned */
	unsigned char x;
	unsigned char y;
	unsigned short wIndx;
	unsigned short wCI;
	int dwSeed;
	unsigned char bId;
	unsigned char bDur;
	unsigned char bMDur;
	unsigned char bCh;
	unsigned char bMCh;
	unsigned short wValue;
	int dwBuff;
};
#pragma pack(pop)

/* __declspec(align(1))*/
struct  DLevel
{
	TCmdPItem item[127];
	DObjectStr object[127];
	DMonsterStr monster[200];
};

struct DPortal
{
	unsigned char x;
	unsigned char y;
	unsigned char level;
	unsigned char ltype;
	unsigned char setlvl;
};

struct MultiQuests
{
	unsigned char qstate;
	unsigned char qlog;
	unsigned char qvar1;
};

struct DJunk
{
	DPortal portal[4];
	MultiQuests quests[4];
};

/*  __declspec(align(1)) */
#pragma pack(push, 1)
struct PkItemStruct
{
	int iSeed;
	short iCreateInfo;
	short idx;
	char bId;
	char bDur;
	char bMDur;
	char bCh;
	char bMCh;
	short wValue;
	int dwBuff;
};
#pragma pack(pop)

/* __declspec(align(2)) */
#pragma pack(push, 1)
struct PkPlayerStruct
{
	FILETIME archiveTime;
	char destAction;
	char destParam1;
	char destParam2;
	char plrlevel;
	char px;
	char py;
	char targx;
	char targy;
	char pName[32];
	char pClass;
	char pBaseStr;
	char pBaseMag;
	char pBaseDex;
	char pBaseVit;
	char pLevel;
	char pStatPts;
	int pExperience;
	int pGold;
	int pHPBase;
	int pMaxHPBase;
	int pManaBase;
	int pMaxManaBase;
	char pSplLvl[37];
	int pMemSpells;
	int pMemSpells2;
	PkItemStruct InvBody[7];
	PkItemStruct InvList[40];
	char InvGrid[40];
	char _pNumInv;
	PkItemStruct SpdList[8];
	char pTownWarps;
	char pDungMsgs;
	char pLvlLoad;
	char pBattleNet;
	char pManaShield;
	char bReserved[3];
	short wReserved[8];
	int pDiabloKillLevel;
	int dwReserved[7];
};
#pragma pack(pop)

struct ObjectStruct
{
	int _otype;
	int _ox;
	int _oy;
	int _oLight;
	int _oAnimFlag;
	int _oAnimData; // unsigned char *
	int _oAnimDelay;
	int _oAnimCnt;
	int _oAnimLen;
	int _oAnimFrame;
	int _oAnimWidth;
	int _oAnimWidth2;
	int _oDelFlag;
	int _oBreak;
	int _oSolidFlag;
	int _oMissFlag;
	int _oSelFlag;
	int _oPreFlag;
	int _oTrapFlag;
	int _oDoorFlag;
	int _olid;
	int _oRndSeed;
	int _oVar1;
	int _oVar2;
	int _oVar3;
	int _oVar4;
	int _oVar5;
	int _oVar6;
	int _oVar7;
	int _oVar8;
};

struct PATHNODE
{
	char f;
	char h;
	short g;
	int x;
	int y;
	struct PATHNODE *Parent;
	struct PATHNODE *Child[8];
	struct PATHNODE *NextNode;
};

struct PlayerStruct
{
	int _pmode;
	char walkpath[25];
	unsigned char plractive;
	int destAction;
	int destParam1;
	int destParam2;
	int destParam3;
	int destParam4;
	int plrlevel;
	int WorldX;
	int WorldY;
	int _px;
	int _py;
	int _ptargx;
	int _ptargy;
	int _pownerx;
	int _pownery;
	int _poldx;
	int _poldy;
	int _pxoff;
	int _pyoff;
	int _pxvel;
	int _pyvel;
	int _pdir;
	int _nextdir;
	int _pgfxnum;
	int _pAnimData; // unsigned char *
	int _pAnimDelay;
	int _pAnimCnt;
	int _pAnimLen;
	int _pAnimFrame;
	int _pAnimWidth;
	int _pAnimWidth2;
	int _peflag;
	int _plid;
	int _pvid;
	int _pSpell;
	char _pSplType;
	char _pSplFrom;
	int _pTSpell;
	int _pTSplType;
	int _pRSpell;
	int _pRSplType;
	int _pSBkSpell;
	char _pSBkSplType;
	char _pSplLvl[64];
	int remove_1;
	int _pMemSpells[2]; // __declspec(align(8))
	int _pAblSpells[2];
	int _pScrlSpells[2];
	int _pSpellFlags;
	int _pSplHotKey[4];
	char _pSplTHotKey[4];
	int _pwtype;
	unsigned char _pBlockFlag;
	unsigned char _pInvincible;
	char _pLightRad;
	unsigned char _pLvlChanging;
	char _pName[32];
	int _pClass;
	int _pStrength;
	int _pBaseStr;
	int _pMagic;
	int _pBaseMag;
	int _pDexterity;
	int _pBaseDex;
	int _pVitality;
	int _pBaseVit;
	int _pStatPts;
	int _pDamageMod;
	int _pBaseToBlk;
	int _pHPBase;
	int _pMaxHPBase;
	int _pHitPoints;
	int _pMaxHP;
	int _pHPPer;
	int _pManaBase;
	int _pMaxManaBase;
	int _pMana;
	int _pMaxMana;
	int _pManaPer;
	char _pLevel;
	char _pMaxLvl;
	int _pExperience;
	int _pMaxExp;
	int _pNextExper;
	char _pArmorClass;
	char _pMagResist;
	char _pFireResist;
	char _pLghtResist;
	int _pGold;
	int _pInfraFlag;
	int _pVar1;
	int _pVar2;
	int _pVar3;
	int _pVar4;
	int _pVar5;
	int _pVar6;
	int _pVar7;
	int _pVar8;
	unsigned char _pLvlVisited[17];
	unsigned char _pSLvlVisited[10];
	char gap20F[9];
	int _pGFXLoad;
	int _pNAnim[8]; // unsigned char *
	int _pNFrames;
	int _pNWidth;
	int _pWAnim[8]; // unsigned char *
	int _pWFrames;
	int _pWWidth;
	int _pAAnim[8]; // unsigned char *
	int _pAFrames;
	int _pAWidth;
	int _pAFNum;
	int _pLAnim[8]; // unsigned char *
	int _pFAnim[8]; // unsigned char *
	int _pTAnim[8]; // unsigned char *
	int _pSFrames;
	int _pSWidth;
	int _pSFNum;
	int _pHAnim[8]; // unsigned char *
	int _pHFrames;
	int _pHWidth;
	int _pDAnim[8]; // unsigned char *
	int _pDFrames;
	int _pDWidth;
	int _pBAnim[8]; // unsigned char *
	int _pBFrames;
	int _pBWidth;
	ItemStruct InvBody[7];
	ItemStruct InvList[40];
	int _pNumInv;
	char InvGrid[40];
	ItemStruct SpdList[8];
	ItemStruct HoldItem;
	int _pIMinDam;
	int _pIMaxDam;
	int _pIAC;
	int _pIBonusDam;
	int _pIBonusToHit;
	int _pIBonusAC;
	int _pIBonusDamMod;
	int remove_2;
	int _pISpells[2]; //__declspec(align(8))
	int _pIFlags;
	int _pIGetHit;
	char _pISplLvlAdd;
	char _pISplCost;
	int _pISplDur;
	int _pIEnAc;
	int _pIFMinDam;
	int _pIFMaxDam;
	int _pILMinDam;
	int _pILMaxDam;
	int _pOilType;
	unsigned char pTownWarps;
	unsigned char pDungMsgs;
	unsigned char pLvlLoad;
	unsigned char pBattleNet;
	unsigned char pManaShield;
	char bReserved[3];
	short wReserved[8];
	int pDiabloKillLevel;
	int dwReserved[7];
	void *_pNData;
	void *_pWData;
	void *_pAData;
	void *_pLData;
	void *_pFData;
	void *_pTData;
	void *_pHData;
	void *_pDData;
	void *_pBData;
	int unused_54D4;
};

struct QuestStruct
{
	unsigned char _qlevel;
	unsigned char _qtype;
	unsigned char _qactive;
	unsigned char _qlvltype;
	int _qtx;
	int _qty;
	unsigned char _qslvl;
	unsigned char _qidx;
	unsigned char _qmsg;
	unsigned char _qvar1;
	unsigned char _qvar2;
	int _qlog; /* char */
};

struct SHA1Context
{
	int state[5];
	int count[2];
	char buffer[64];
};

struct ThemeStruct
{
	int ttype; /* char, aligned 4 */
	int ttval;
};

struct TMsgHeader
{
	char next;
	char start_tc;
	char len;
};

struct TMsg
{
	TMsgHeader hdr;
	char data;
};

struct TNQ
{
	unsigned char _qsttype;
	unsigned char _qstmsg;
	unsigned char _qstmsgact;
};

struct TownerStruct
{
	int _tmode;
	int _ttype;
	int _tx;
	int _ty;
	int _txoff;
	int _tyoff;
	int _txvel;
	int _tyvel;
	int _tdir;
	void *_tAnimData; // unsigned char *
	int _tAnimDelay;
	int _tAnimCnt;
	int _tAnimLen;
	int _tAnimFrame;
	int _tAnimFrameCnt;
	int _tAnimOrder;
	int _tAnimWidth;
	int _tAnimWidth2;
	int _tTenPer;
	int _teflag;
	int _tbtcnt;
	int _tSelFlag;
	int _tMsgSaid;
	TNQ qsts[16];
	int _tSeed;
	int _tVar1;
	int _tVar2;
	int _tVar3;
	int _tVar4;
	char _tName[32];
	int _tNAnim[8]; // unsigned char *
	int _tNFrames;
	char *_tNData; // unsigned char *
};

struct _SNETUIDATA
{
	int size;
	int uiflags;
	HWND parentwindow;
	void (__cdecl *artcallback)();
	void (__cdecl *authcallback)();
	void (__cdecl *createcallback)();
	void (__cdecl *drawdesccallback)();
	void (__cdecl *selectedcallback)();
	void (__cdecl *messageboxcallback)();
	void (__cdecl *soundcallback)();
	void (__cdecl *statuscallback)();
	void (__cdecl *getdatacallback)();
	void (__cdecl *categorycallback)();
	void (__cdecl *field_34)();
	void (__cdecl *field_38)();
	void (__cdecl *profilecallback)();
	int profilegetstring;
	void (__cdecl *profiledraw)();
	void (__cdecl *selecthero)();
	void (__cdecl *createhero)();
};

struct _SNETPROGRAMDATA
{
	int size;
	char *programname;
	char *programdescription;
	int programid;
	int versionid;
	int reserved1;
	int maxplayers;
	int multi_seed;
	void *initdata;
	int initdatabytes;
	void *reserved2;
	int optcategorybits;
	int reserved3;
	int reserved4;
	int languageid;
};

struct _uiheroinfo
{
	_uiheroinfo *next;
	char name[16];
	unsigned short level;
	unsigned char heroclass;
	unsigned char herorank;
	unsigned short strength;
	unsigned short magic;
	unsigned short dexterity;
	unsigned short vitality;
	int gold;
	int hassaved;
	int spawned;
};

struct _HASHENTRY
{
	int hashcheck[2];
	int lcid;
	int block;
};

struct _BLOCKENTRY
{
	int offset;
	int sizealloc;
	int sizefile;
	int flags;
};

/* __declspec(align(2)) */
#pragma pack(push, 1)
struct TCmdGItem
{
	unsigned char bCmd;
	unsigned char bMaster;
	unsigned char bPnum;
	unsigned char bCursitem;
	unsigned char bLevel;
	unsigned char x;
	unsigned char y;
	unsigned short wIndx;
	unsigned short wCI;
	int dwSeed;
	unsigned char bId;
	unsigned char bDur;
	unsigned char bMDur;
	unsigned char bCh;
	unsigned char bMCh;
	unsigned short wValue;
	int dwBuff;
	int dwTime;
};
#pragma pack(pop)

struct TCmdLoc
{
	unsigned char bCmd;
	unsigned char x;
	unsigned char y;
};

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdParam1
{
	unsigned char bCmd;
	unsigned short wParam1;
};
#pragma pack(pop)

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdLocParam1
{
	unsigned char bCmd;
	unsigned char x;
	unsigned char y;
	unsigned short wParam1;
};
#pragma pack(pop)

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TPktHdr
{
	unsigned char px;
	unsigned char py;
	unsigned char targx;
	unsigned char targy;
	int php;
	int pmhp;
	unsigned char bstr;
	unsigned char bmag;
	unsigned char bdex;
	unsigned short wCheck;
	unsigned short wLen;
};
#pragma pack(pop)

struct _SNETEVENT
{
	int eventid;
	int playerid;
	void *data;
	int databytes;
};

struct _SNETPLAYERDATA
{
	int size;
	char *playername;
	char *playerdescription;
	int field_C;
};

struct _SNETCAPS
{
	int size;
	int flags;
	int maxmessagesize;
	int maxqueuesize;
	int maxplayers;
	int bytessec;
	int latencyms;
	int defaultturnssec;
	int defaultturnsintransit;
};

struct TMPQHeader // _FILEHEADER
{
	int dwID;
	int dwHeaderSize;
	int dwArchiveSize;
	short wFormatVersion;
	short wSectorSize;
	int dwHashTablePos;
	int dwBlockTablePos;
	int dwHashTableSize;
	int dwBlockTableSize;
	char field_20[72];
};

struct _uidefaultstats
{
	unsigned short strength;
	unsigned short magic;
	unsigned short dexterity;
	unsigned short vitality;
};

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdLocParam2
{
	unsigned char bCmd;
	unsigned char x;
	unsigned char y;
	unsigned short wParam1;
	unsigned short wParam2;
};
#pragma pack(pop)

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdLocParam3
{
	unsigned char bCmd;
	unsigned char x;
	unsigned char y;
	unsigned short wParam1;
	unsigned short wParam2;
	unsigned short wParam3;
};
#pragma pack(pop)

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdParam2
{
	unsigned char bCmd;
	unsigned short wParam1;
	unsigned short wParam2;
};
#pragma pack(pop)

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdParam3
{
	unsigned char bCmd;
	unsigned short wParam1;
	unsigned short wParam2;
	unsigned short wParam3;
};
#pragma pack(pop)

struct TCmd
{
	unsigned char bCmd;
};

/* __declspec(align(2)) */
#pragma pack(push, 1)
struct TCmdGolem
{
	unsigned char bCmd;
	unsigned char _mx;
	unsigned char _my;
	unsigned char _mdir;
	unsigned char _menemy;
	int _mhitpoints;
	unsigned char _currlevel;
};
#pragma pack(pop)

struct TCmdQuest
{
	unsigned char bCmd;
	unsigned char q;
	unsigned char qstate;
	unsigned char qlog;
	unsigned char qvar1;
};

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdChItem
{
	unsigned char bCmd;
	unsigned char bLoc;
	unsigned short wIndx;
	unsigned short wCI;
	int dwSeed;
	unsigned char bId;
};
#pragma pack(pop)

struct TCmdDelItem
{
	unsigned char bCmd;
	unsigned char bLoc;
};

/* __declspec(align(2)) */
#pragma pack(push, 1)
struct TCmdDamage
{
	unsigned char bCmd;
	unsigned char bPlr;
	int dwDam;
};
#pragma pack(pop)

struct TFakeCmdPlr
{
	unsigned char bCmd;
	unsigned char bPlr;
};

/* __declspec(align(2)) */
#pragma pack(push, 1)
struct TFakeDropPlr
{
	unsigned char bCmd;
	unsigned char bPlr;
	int dwReason;
};
#pragma pack(pop)

struct TCmdString
{
	unsigned char bCmd;
	char str[80];
};

/* __declspec(align(1)) */
#pragma pack(push, 1)
struct TCmdPlrInfoHdr
{
	unsigned char bCmd;
	unsigned short wOffset;
	unsigned short wBytes;
};
#pragma pack(pop)

struct PortalStruct
{
	int open;
	int x;
	int y;
	int level;
	int ltype;
	int setlvl;
};

struct CircleCoord
{
	unsigned char n_1;
	Coord delta_1[1];
	unsigned char n_4;
	Coord delta_4[4];
	unsigned char n_16;
	Coord delta_16[16];
	unsigned char n_24;
	Coord delta_24[24];
	unsigned char n_32;
	Coord delta_32[32];
	unsigned char n_40;
	Coord delta_40[40];
	unsigned char n_48;
	Coord delta_48[48];
	unsigned char n_56;
	Coord delta_56[56];
	unsigned char n_64;
	Coord delta_64[64];
	unsigned char n_72;
	Coord delta_72[72];
	unsigned char n_80;
	Coord delta_80[80];
	unsigned char n_88;
	Coord delta_88[88];
	unsigned char n_96;
	Coord delta_96[96];
	unsigned char n_104;
	Coord delta_104[104];
	unsigned char n_112;
	Coord delta_112[112];
	unsigned char n_120;
	Coord delta_120[120];
	unsigned char n_128;
	Coord delta_128[128];
	unsigned char n_136;
	Coord delta_136[136];
	unsigned char n_144;
	Coord delta_144[144];
};

struct TriggerStruct
{
	int _tx;
	int _ty;
	int _tmsg;
	int _tlvl;
};

struct THEME_LOC
{
	int x;
	int y;
	int ttval;
	int width;
	int height;
};

struct STextStruct
{
	int _sx;
	int _syoff;
	char _sstr[128];
	int _sjust;
	int _sclr;
	int _sline;
	int _ssel;
	int _sval;
};

struct HALLNODE
{
	int nHallx1;
	int nHally1;
	int nHallx2;
	int nHally2;
	int nHalldir;
	HALLNODE *pNext;
};

struct ROOMNODE
{
	int nRoomx1;
	int nRoomy1;
	int nRoomx2;
	int nRoomy2;
	int nRoomDest;
};

struct LocalLevel
{
	unsigned char automapsv[40][40];
};

struct TMegaPkt
{
	TMegaPkt *pNext;
	int dwSpaceLeft;
	unsigned char data[32000];
};

struct ScrollStruct
{
	int _sxoff;
	int _syoff;
	int _sdx;
	int _sdy;
	int _sdir;
};

struct _gamedata
{
	int dwSeed;
	unsigned char bDiff;
};

struct TPkt
{
	TPktHdr hdr;
	unsigned char body[493];
};

struct MEMFILE
{
	int end;
	int offset;
	int buf_len;
	int dist;
	int bytes_to_read;
	char *buf;
	int file;
};

struct _plrmsg
{
	int time;
	char player;
	char str[144];
};

struct ItemGetRecordStruct
{
	int nSeed;
	unsigned short wCI;
	int nIndex;
	int dwTimestamp;
};

struct unk_missile_struct
{
	int field_0;
	int field_4;
	int field_8;
};

struct TSyncMonster
{
	unsigned char _mndx;
	unsigned char _mx;
	unsigned char _my;
	unsigned char _menemy;
	unsigned char _mdelta;
};

struct TSyncHeader
{
	unsigned char bCmd;
	unsigned char bLevel;
	unsigned short wLen;
	unsigned char bObjId;
	unsigned char bObjCmd;
	unsigned char bItemI;
	unsigned char bItemX;
	unsigned char bItemY;
	unsigned short wItemIndx;
	unsigned short wItemCI;
	int dwItemSeed;
	unsigned char bItemId;
	unsigned char bItemDur;
	unsigned char bItemMDur;
	unsigned char bItemCh;
	unsigned char bItemMCh;
	unsigned short wItemVal;
	unsigned int dwItemBuff;
	unsigned char bPInvLoc;
	unsigned short wPInvIndx;
	unsigned short wPInvCI;
	int dwPInvSeed;
	unsigned char bPInvId;
};

struct PCXHeader
{
	char manufacturer;
	char version;
	char encoding;
	char bitsPerPixel;
	short xmin, ymin;
	short xmax, ymax;
	short horzRes, vertRes;
	char palette[48];
	char reserved;
	char numColorPlanes;
	short bytesPerScanLine;
	short paletteType;
	short horzSize, vertSize;
	char padding[54];
};

typedef struct
{
	unsigned char * pbInBuff;           // Pointer to input data buffer
	unsigned char * pbInBuffEnd;        // End of the input buffer
	unsigned char * pbOutBuff;          // Pointer to output data buffer
	unsigned char * pbOutBuffEnd;       // Pointer to output data buffer
	unsigned char * pbSize;
} TDataInfo;

typedef struct {
	int field_0;
	int field_4;
	char command[128];
} ServerCommand;

typedef struct ChatCmd {
	struct ChatCmd *next;
	ServerCommand *extern_msgs[2];
} ChatCmd;
// temporary file

#ifndef _TYPES_H
#define _TYPES_H

#include "resource.h"

#include <windows.h>
#include <stdio.h>
#include <ddraw.h>
#include <dsound.h>
#include <io.h>
#include <math.h>
#include <time.h>
#include <process.h>
#include <shlobj.h>

#pragma warning (disable : 4309) // truncation of constant value
#pragma warning (disable : 4305) // truncation of int
#pragma warning (disable : 4018) // signed/unsigned mismatch
#pragma warning (disable : 4700) // used without having been initialized
#pragma warning (disable : 4804) // unsafe use of type 'bool' in operation
#pragma warning (disable : 4805) // unsafe bool mix
#pragma warning (disable : 4244) // conversion loss
#pragma warning (disable : 4800) // bool perf
#pragma warning (disable : 4146) // negative unsigned

#include "enums.h"
#include "structs.h"

#include "DiabloUI/diabloui.h"
#include "3rdParty/Storm/Source/storm.h"
#include "3rdParty/PKWare/pkware.h"


#include "defs.h"

// If defined, use copy protection [Default -> Defined]
//#define COPYPROT
// If defined, don't reload for debuggers [Default -> Undefined]
#define DEBUGGER
// If defined, don't fry the CPU [Default -> Undefined]
#define SLEEP

/* temp macro for asm XLAT */
#define ASM_XLAT(eax,ebx) eax = (eax & 0xFFFFFF00) + LOBYTE(ebx[LOBYTE(eax)])

// header files
#include "Source/appfat.h"
#include "Source/automap.h"
#include "Source/capture.h"
#include "Source/codec.h"
#include "Source/control.h"
#include "Source/cursor.h"
#include "Source/dead.h"
#include "Source/debug.h"
#include "Source/diablo.h"
#include "Source/doom.h"
#include "Source/drlg_l1.h"
#include "Source/drlg_l2.h"
#include "Source/drlg_l3.h"
#include "Source/drlg_l4.h"
#include "Source/dthread.h"
#include "Source/dx.h"
#include "Source/effects.h"
#include "Source/encrypt.h"
#include "Source/engine.h"
#include "Source/error.h"
#include "Source/fault.h"
#include "Source/gamemenu.h"
#include "Source/gendung.h"
#include "Source/gmenu.h"
#include "Source/help.h"
#include "Source/init.h"
#include "Source/interfac.h"
#include "Source/inv.h"
#include "Source/items.h"
#include "Source/lighting.h"
#include "Source/loadsave.h"
#include "Source/logging.h"
#include "Source/mainmenu.h"
#include "Source/minitext.h"
#include "Source/missiles.h"
#include "Source/monster.h"
#include "Source/movie.h"
#include "Source/mpqapi.h"
#include "Source/msg.h"
#include "Source/msgcmd.h"
#include "Source/multi.h"
#include "Source/nthread.h"
#include "Source/objects.h"
#include "Source/pack.h"
#include "Source/palette.h"
#include "Source/path.h"
#include "Source/pfile.h"
#include "Source/player.h"
#include "Source/plrmsg.h"
#include "Source/portal.h"
#include "Source/quests.h"
#include "Source/restrict.h"
#include "Source/scrollrt.h"
#include "Source/setmaps.h"
#include "Source/sha.h"
#include "Source/sound.h"
#include "Source/spells.h"
#include "Source/stores.h"
#include "Source/sync.h"
#include "Source/textdat.h" // check file name
#include "Source/themes.h"
#include "Source/tmsg.h"
#include "Source/town.h"
#include "Source/towners.h"
#include "Source/track.h"
#include "Source/trigs.h"
#include "Source/wave.h"
#include "Source/world.h"

#endif
/*****************************************************************************/
/* pkware.h                               Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Header file for PKWARE Data Compression Library                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 31.03.03  1.00  Lad  The first version of pkware.h                        */
/*****************************************************************************/

#ifndef __PKWARE_H__
#define __PKWARE_H__

//-----------------------------------------------------------------------------
// Defines

#define CMP_BINARY             0            // Binary compression
#define CMP_ASCII              1            // Ascii compression

#define CMP_NO_ERROR           0
#define CMP_INVALID_DICTSIZE   1
#define CMP_INVALID_MODE       2
#define CMP_BAD_DATA           3
#define CMP_ABORT              4

#define CMP_IMPLODE_DICT_SIZE1   1024       // Dictionary size of 1024
#define CMP_IMPLODE_DICT_SIZE2   2048       // Dictionary size of 2048
#define CMP_IMPLODE_DICT_SIZE3   4096       // Dictionary size of 4096

//-----------------------------------------------------------------------------
// Define calling convention

#ifndef PKEXPORT
#ifdef WIN32
#define PKEXPORT  __cdecl                   // Use for normal __cdecl calling 
#else
#define PKEXPORT
#endif
#endif

//-----------------------------------------------------------------------------
// Internal structures

// Compression structure
typedef struct
{
    unsigned int   distance;                // 0000: Backward distance of the currently found repetition, decreased by 1
    unsigned int   out_bytes;               // 0004: # bytes available in out_buff            
    unsigned int   out_bits;                // 0008: # of bits available in the last out byte
    unsigned int   dsize_bits;              // 000C: Number of bits needed for dictionary size. 4 = 0x400, 5 = 0x800, 6 = 0x1000
    unsigned int   dsize_mask;              // 0010: Bit mask for dictionary. 0x0F = 0x400, 0x1F = 0x800, 0x3F = 0x1000
    unsigned int   ctype;                   // 0014: Compression type (CMP_ASCII or CMP_BINARY)
    unsigned int   dsize_bytes;             // 0018: Dictionary size in bytes
    unsigned char  dist_bits[0x40];         // 001C: Distance bits
    unsigned char  dist_codes[0x40];        // 005C: Distance codes
    unsigned char  nChBits[0x306];          // 009C: Table of literal bit lengths to be put to the output stream
    unsigned short nChCodes[0x306];         // 03A2: Table of literal codes to be put to the output stream
    unsigned short offs09AE;                // 09AE: 

    void         * param;                   // 09B0: User parameter
    unsigned int (*read_buf)(char *buf, unsigned int *size, void *param);  // 9B4
    void         (*write_buf)(char *buf, unsigned int *size, void *param); // 9B8

    unsigned short offs09BC[0x204];         // 09BC:
    unsigned long  offs0DC4;                // 0DC4: 
    unsigned short phash_to_index[0x900];   // 0DC8: Array of indexes (one for each PAIR_HASH) to the "pair_hash_offsets" table
    unsigned short phash_to_index_end;      // 1FC8: End marker for "phash_to_index" table
    char           out_buff[0x802];         // 1FCA: Compressed data
    unsigned char  work_buff[0x2204];       // 27CC: Work buffer
                                            //  + DICT_OFFSET  => Dictionary
                                            //  + UNCMP_OFFSET => Uncompressed data
    unsigned short phash_offs[0x2204];      // 49D0: Table of offsets for each PAIR_HASH
} TCmpStruct;

#define CMP_BUFFER_SIZE  sizeof(TCmpStruct) // Size of compression structure.
                                            // Defined as 36312 in pkware header file


// Decompression structure
typedef struct
{
    unsigned long offs0000;                 // 0000
    unsigned long ctype;                    // 0004: Compression type (CMP_BINARY or CMP_ASCII)
    unsigned long outputPos;                // 0008: Position in output buffer
    unsigned long dsize_bits;               // 000C: Dict size (4, 5, 6 for 0x400, 0x800, 0x1000)
    unsigned long dsize_mask;               // 0010: Dict size bitmask (0x0F, 0x1F, 0x3F for 0x400, 0x800, 0x1000)
    unsigned long bit_buff;                 // 0014: 16-bit buffer for processing input data
    unsigned long extra_bits;               // 0018: Number of extra (above 8) bits in bit buffer
    unsigned int  in_pos;                   // 001C: Position in in_buff
    unsigned long in_bytes;                 // 0020: Number of bytes in input buffer
    void        * param;                    // 0024: Custom parameter
    unsigned int (*read_buf)(char *buf, unsigned int *size, void *param); // Pointer to function that reads data from the input stream
    void         (*write_buf)(char *buf, unsigned int *size, void *param);// Pointer to function that writes data to the output stream

    unsigned char out_buff[0x2204];         // 0030: Output circle buffer.
                                            //       0x0000 - 0x0FFF: Previous uncompressed data, kept for repetitions
                                            //       0x1000 - 0x1FFF: Currently decompressed data
                                            //       0x2000 - 0x2203: Reserve space for the longest possible repetition
    unsigned char in_buff[0x800];           // 2234: Buffer for data to be decompressed
    unsigned char DistPosCodes[0x100];      // 2A34: Table of distance position codes
    unsigned char LengthCodes[0x100];       // 2B34: Table of length codes
    unsigned char offs2C34[0x100];          // 2C34: Buffer for 
    unsigned char offs2D34[0x100];          // 2D34: Buffer for 
    unsigned char offs2E34[0x80];           // 2EB4: Buffer for 
    unsigned char offs2EB4[0x100];          // 2EB4: Buffer for 
    unsigned char ChBitsAsc[0x100];         // 2FB4: Buffer for 
    unsigned char DistBits[0x40];           // 30B4: Numbers of bytes to skip copied block length
    unsigned char LenBits[0x10];            // 30F4: Numbers of bits for skip copied block length
    unsigned char ExLenBits[0x10];          // 3104: Number of valid bits for copied block
    unsigned short LenBase[0x10];           // 3114: Buffer for 
} TDcmpStruct;

#define EXP_BUFFER_SIZE sizeof(TDcmpStruct) // Size of decompression structure
                                            // Defined as 12596 in pkware headers

//-----------------------------------------------------------------------------
// Public functions

#ifdef __cplusplus
   extern "C" {
#endif

unsigned int PKEXPORT implode(
   unsigned int (*read_buf)(char *buf, unsigned int *size, void *param),
   void         (*write_buf)(char *buf, unsigned int *size, void *param),
   char         *work_buf,
   void         *param,
   unsigned int *type,
   unsigned int *dsize);


unsigned int PKEXPORT explode(
   unsigned int (*read_buf)(char *buf, unsigned  int *size, void *param),
   void         (*write_buf)(char *buf, unsigned  int *size, void *param),
   char         *work_buf,
   void         *param);

#ifdef __cplusplus
   }                         // End of 'extern "C"' declaration
#endif

#endif // __PKWARE_H__
#pragma once

#ifndef __BLIZZARD_STORM_HEADER
#define __BLIZZARD_STORM_HEADER

#include <windows.h>
#include <winuser.h>
#include <winsock.h>
#include <ddraw.h>

// Note to self: Linker error => forgot a return value in cpp

// Storm API definition
#ifndef STORMAPI
#define STORMAPI __stdcall
#endif

#ifndef __STORM_SMAX
#define __STORM_SMAX(x,y) (x < y ? y : x)
#endif

#ifndef __STORM_SSIZEMAX
#define __STORM_SSIZEMAX(x,y) (__STORM_SMAX(sizeof(x),sizeof(y)))
#endif

#ifndef __STORM_SMIN
#define __STORM_SMIN(x,y) (x < y ? x : y)
#endif

#ifndef __STORM_SSIZEMIN
#define __STORM_SSIZEMIN(x,y) (__STORM_SMIN(sizeof(x),sizeof(y)))
#endif

typedef struct _WRECT
{
  WORD  left;
  WORD  top;
  WORD  right;
  WORD  bottom;
} WRECT, *PWRECT;

typedef struct _WPOINT
{
  WORD  x;
  WORD  y;
} WPOINT, *PWPOINT;

typedef struct _WSIZE
{
  WORD  cx;
  WORD  cy;
} WSIZE, *PWSIZE;



// Game states
#define GAMESTATE_PRIVATE 0x01
#define GAMESTATE_FULL    0x02
#define GAMESTATE_ACTIVE  0x04
#define GAMESTATE_STARTED 0x08
#define GAMESTATE_REPLAY  0x80

#ifdef __GNUC__
extern "C" {
#endif

BOOL STORMAPI SNetCreateGame(const char *pszGameName, const char *pszGamePassword, const char *pszGameStatString, DWORD dwGameType, char *GameTemplateData, int GameTemplateSize, int playerCount, char *creatorName, char *a11, int *playerID);
BOOL STORMAPI SNetDestroy();
BOOL STORMAPI SNetEnumProviders(int (STORMAPI *callback)(DWORD, DWORD, DWORD, DWORD), int mincaps);

BOOL STORMAPI SNetEnumGames(int (STORMAPI *callback)(DWORD, DWORD, DWORD), int *hintnextcall);

/*  SNetDropPlayer @ 106
 *
 *  Drops a player from the current game.
 *
 *  playerid:     The player ID for the player to be dropped.
 *  flags:
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetDropPlayer(
      int playerid,
      DWORD flags);

/*  SNetGetGameInfo @ 107
 *
 *  Retrieves specific game information from Storm, such as name, password,
 *  stats, mode, game template, and players.
 *
 *  type:         The type of data to retrieve. See GAMEINFO_ flags.
 *  dst:          The destination buffer for the data.
 *  length:       The maximum size of the destination buffer.
 *  byteswritten: The number of bytes written to the destination buffer.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetGetGameInfo(
    int type,
    void *dst,
    size_t length,
    size_t *byteswritten = NULL);


#define SNGetGameInfo(typ,dst) SNetGetGameInfo(typ, &dst, sizeof(dst))



// Game info fields
#define GAMEINFO_NAME           1
#define GAMEINFO_PASSWORD       2
#define GAMEINFO_STATS          3
#define GAMEINFO_MODEFLAG       4
#define GAMEINFO_GAMETEMPLATE   5
#define GAMEINFO_PLAYERS        6


BOOL STORMAPI SNetGetNumPlayers(int *firstplayerid, int *lastplayerid, int *activeplayers);


typedef struct _CAPS
{
  DWORD dwSize;                 // Size of this structure  // sizeof(CAPS)
  DWORD dwUnk_0x04;             // Some flags?
  DWORD maxmessagesize;         // Size of the packet buffer, must be beteen 128 and 512
  DWORD dwUnk_0x0C;             // Unknown
  DWORD dwDisplayedPlayerCount; // Displayed player count in the mode selection list
  DWORD dwUnk_0x14;             // some kind of timeout or timer related
  DWORD dwPlayerLatency;        // ... latency?
  DWORD dwPlayerCount;          // the number of players that can participate, must be between 1 and 20
  DWORD dwCallDelay;            // the number of calls before data is sent over the network // between 2 and 8; single player is set to 1
} CAPS, *PCAPS;


BOOL STORMAPI SNetGetPlayerCaps(char playerid, PCAPS playerCaps);

/*  SNetGetPlayerName @ 113
 *
 *  Retrieves the name of a player given their player ID.
 *
 *  playerid:     The player's ID.
 *  buffer:       The buffer that will receive the name.
 *  buffersize:   The maximum size of buffer.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetGetPlayerName(
      int playerid,
      char *buffer,
      size_t buffersize);

/*  SNetGetProviderCaps @ 114
 *
 *  Retrieves network provider capacity information.
 *
 *  providerCaps: A pointer to a CAPS structure that will receive the information.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
//BOOL
//STORMAPI
//SNetGetProviderCaps(
//      PCAPS providerCaps);

/*  SNetGetTurnsInTransit @ 115
 *
 *  Retrieves the number of turns (buffers) that have been queued
 *  before sending them over the network.
 *
 *  turns: A pointer to an integer that will receive the value.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetGetTurnsInTransit(
      int *turns);


BOOL STORMAPI SNetInitializeDevice(int a1, int a2, int a3, int a4, int *a5);

// Network provider structures
typedef struct _client_info
{
  DWORD dwSize; // 60
  char  *pszName;
  char  *pszVersion;
  DWORD dwProduct;
  DWORD dwVerbyte;
  DWORD dwUnk5;
  DWORD dwMaxPlayers;
  DWORD dwUnk7;
  DWORD dwUnk8;
  DWORD dwUnk9;
  DWORD dwUnk10; // 0xFF
  char  *pszCdKey;
  char  *pszCdOwner;
  DWORD dwIsShareware;
  DWORD dwLangId;
} client_info;

typedef struct _user_info
{
  DWORD dwSize; // 16
  char  *pszPlayerName;
  char  *pszUnknown;
  DWORD dwUnknown;
} user_info;

typedef struct _battle_info
{
  DWORD dwSize;   // 92
  DWORD dwUnkType;
  HWND  hFrameWnd;
  void  *pfnBattleGetResource;
  void  *pfnBattleGetErrorString;
  void  *pfnBattleMakeCreateGameDialog;
  void  *pfnBattleUpdateIcons;
  DWORD dwUnk_07;
  void  *pfnBattleErrorDialog;
  void  *pfnBattlePlaySound;
  DWORD dwUnk_10;
  void  *pfnBattleGetCursorLink;
  DWORD dwUnk_12;
  void  *pfnUnk_13;
  DWORD dwUnk_14;
  void  *pfnBattleMakeProfileDialog;
  char  *pszProfileStrings;
  void  *pfnBattleDrawProfileInfo;
  void  *pfnUnk_18;
  DWORD dwUnk_19;
  void  *pfnUnk_20;
  void  *pfnUnk_21;
  void  *pfnBattleSetLeagueName;
} battle_info;

typedef struct _module_info
{
  DWORD dwSize; // 20
  char  *pszVersionString;
  char  *pszModuleName;
  char  *pszMainArchive;
  char  *pszPatchArchive;
} module_info;

typedef struct _game
{
  DWORD     dwIndex;
  DWORD     dwGameState;
  DWORD     dwUnk_08;
  SOCKADDR  saHost;
  DWORD     dwUnk_1C;
  DWORD     dwTimer;
  DWORD     dwUnk_24;
  char      szGameName[128];
  char      szGameStatString[128];
  _game     *pNext;
  void      *pExtra;
  DWORD     dwExtraBytes;
  DWORD     dwProduct;
  DWORD     dwVersion;
} game;

typedef struct _storm_head
{
  WORD wChecksum;
  WORD wLength;
  WORD wSent;
  WORD wReceived;
  BYTE bCommandClass;
  BYTE bCommandType;
  BYTE bPlayerId;
  BYTE bFlags;
} storm_head;


// Traffic flags
#define STRAFFIC_NORMAL 0
#define STRAFFIC_VERIFY 1
#define STRAFFIC_RESEND 2
#define STRAFFIC_REPLY  4


/*  SNetInitializeProvider @ 117
 *
 *  Initializes a provider by storing the provider callbacks, and calling
 *  spiInitialize() using the parameters passed to this function.
 *  Note: The use of the parameters is determined by the network
 *  module.
 *
 *  providerName:     The provider's identifier. Example: 'TENB' (BNET).
 *  gameClientInfo:   A pointer to a clientInfo structure containing
 *                    information about the game client.
 *  userData:         A pointer to a userInfo structure containing information
 *                    about the player.
 *  bnCallbacks:      A pointer to a battleInfo structure containing callbacks
 *                    and other information that is specific to Battle.net.
 *  moduleData:       A pointer to a moduleInfo structure containing the
 *                    executable information and paths to MPQ archives.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
//BOOL
//STORMAPI
//SNetInitializeProvider(
//      DWORD       providerName,
//      client_info  *gameClientInfo,
//      user_info    *userData,
//      battle_info  *bnCallbacks,
//      module_info  *moduleData);


BOOL STORMAPI SNetJoinGame(int id, char *gameName, char *gamePassword, char *playerName, char *userStats, int *playerid);

/*  SNetLeaveGame @ 119
 *
 *  Notifies Storm that the player has left the game. Storm will
 *  notify all connected peers through the network provider.
 *
 *  type: The leave type. It doesn't appear to be important, no documentation available.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetLeaveGame(
    int type);

BOOL STORMAPI SNetPerformUpgrade(DWORD *upgradestatus);
BOOL STORMAPI SNetReceiveMessage(int *senderplayerid, char **data, int *databytes);
BOOL STORMAPI SNetReceiveTurns(int a1, int arraysize, char **arraydata, unsigned int *arraydatabytes, DWORD *arrayplayerstatus);

// Values for arrayplayerstatus
#define SNET_PS_OK             0
#define SNET_PS_WAITING        2
#define SNET_PS_NOTRESPONDING  3
#define SNET_PS_UNKNOWN        default


// Event structure
typedef struct _s_evt
{
  DWORD dwFlags;
  int   dwPlayerId;
  void  *pData;
  DWORD dwSize;
} S_EVT, *PS_EVT;


// @TODO: "type" is unknown.
//HANDLE STORMAPI SNetRegisterEventHandler(int type, void (STORMAPI *sEvent)(PS_EVT));

int  STORMAPI SNetSelectGame(int a1, int a2, int a3, int a4, int a5, int *playerid);

/*  SNetSendMessage @ 127
 *
 *  Sends a message to a player given their player ID. Network message
 *  is sent using class 01 and is retrieved by the other client using
 *  SNetReceiveMessage().
 *
 *  playerID:   The player index of the player to receive the data.
 *              Conversely, this field can be one of the following constants:
 *                  SNPLAYER_ALL      | Sends the message to all players, including oneself.
 *                  SNPLAYER_OTHERS   | Sends the message to all players, except for oneself.
 *  data:       A pointer to the data.
 *  databytes:  The amount of bytes that the data pointer contains.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetSendMessage(
      int    playerID,
      void   *data,
      size_t databytes);


// Macro values to target specific players
#define SNPLAYER_ALL    -1
#define SNPLAYER_OTHERS -2


/*  SNetSendTurn @ 128
 *
 *  Sends a turn (data packet) to all players in the game. Network data
 *  is sent using class 02 and is retrieved by the other client using
 *  SNetReceiveTurns().
 *
 *  data:       A pointer to the data.
 *  databytes:  The amount of bytes that the data pointer contains.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetSendTurn(
      char    *data,
      size_t  databytes);

/*  SNetSetGameMode @ 130
 *
 *  Set's the game's mode flags, notifying the network
 *  provider that the state of the game has changed.
 *  For example: notifies Battle.net when the game is
 *  full.
 *
 *  You should first call SNetGetGameInfo to retrieve
 *  the existing mode flags.
 *
 *  modeFlags:  The new flags for the game mode.
 *                  GAMESTATE_PRIVATE     | The game is passworded.
 *                  GAMESTATE_FULL        | The game is full.
 *                  GAMESTATE_ACTIVE      | The game is available.
 *                  GAMESTATE_STARTED     | The game is in progress.
 *                  GAMESTATE_REPLAY      | The game is a replay.
 *  makePublic: Used to make the game a public game, removing the GAMESTATE_PRIVATE flag.
 *
 *  Returns TRUE if the function was called successfully and FALSE otherwise.
 */
BOOL
STORMAPI
SNetSetGameMode(
      DWORD modeFlags,
      bool makePublic = false);

#define SNMakeGamePublic() SNetSetGameMode( (DWORD mode, SNetGetGameInfo(GAMEINFO_MODEFLAGS, &mode, 4), mode), true)

BOOL STORMAPI SNetEnumGamesEx(int a1, int a2, int (__fastcall *callback)(DWORD, DWORD, DWORD), int *hintnextcall);
BOOL STORMAPI SNetSendServerChatCommand(const char *command);

BOOL STORMAPI SNetDisconnectAll(DWORD flags);
BOOL STORMAPI SNetCreateLadderGame(const char *pszGameName, const char *pszGamePassword, const char *pszGameStatString, DWORD dwGameType, DWORD dwGameLadderType, DWORD dwGameModeFlags, char *GameTemplateData, int GameTemplateSize, int playerCount, char *creatorName, char *a11, int *playerID);

#define SNET_GAME_RESULT_WIN        1
#define SNET_GAME_RESULT_LOSS       2
#define SNET_GAME_RESULT_DRAW       3
#define SNET_GAME_RESULT_DISCONNECT 4

BOOL STORMAPI SNetReportGameResult(unsigned a1, int size, int *results, const char* headerInfo, const char* detailInfo);

int  STORMAPI SNetSendLeagueCommand(char *cmd, char *callback);
int  STORMAPI SNetSendReplayPath(int a1, int a2, char *replayPath);
int  STORMAPI SNetGetLeagueName(int leagueID);
BOOL STORMAPI SNetGetPlayerNames(char **names);
int  STORMAPI SNetLeagueLogout(char *bnetName);
int  STORMAPI SNetGetLeaguePlayerName(char *curPlayerLeageName, size_t nameSize);

HGDIOBJ STORMAPI SDlgDefDialogProc(HWND hDlg, signed int DlgType, HDC textLabel, HWND hWnd);

HANDLE STORMAPI SDlgDialogBoxIndirectParam(HMODULE hModule, LPCSTR lpName, HWND hWndParent, LPVOID lpParam, LPARAM lParam);

BOOL STORMAPI SDlgEndDialog(HWND hDlg, HANDLE nResult);

BOOL STORMAPI SDlgSetControlBitmaps(HWND parentwindow, int *id, int a3, char *buffer2, char *buffer, int flags, int mask);

/*
// lpCursorName can only be IDC_ARROW
BOOL STORMAPI SDlgSetSystemCursor(void *lpSrcBuffer, void *p_a2, LPSIZE lpSize, LPCSTR lpCursorName);
*/

BOOL STORMAPI SDlgBltToWindowE(HWND hWnd, HRGN a2, char *a3, int a4, void *buffer, RECT *rct, SIZE *size, int a8, int a9, DWORD rop);
BOOL STORMAPI SDlgSetBitmapE(HWND hWnd, int a2, char *src, int mask1, int flags, int a6, int a7, int width, int a9, int mask2);

int  STORMAPI Ordinal224(int a1);

BOOL STORMAPI SFileCloseArchive(HANDLE hArchive);
BOOL STORMAPI SFileCloseFile(HANDLE hFile);

BOOL STORMAPI SFileDdaBeginEx(HANDLE directsound, DWORD flags, DWORD mask, unsigned __int32 lDistanceToMove, signed __int32 volume, signed int a6, int a7);
BOOL STORMAPI SFileDdaDestroy();
BOOL STORMAPI SFileDdaEnd(HANDLE directsound);
BOOL STORMAPI SFileDdaGetPos(HANDLE directsound, int a2, int a3);

BOOL STORMAPI SFileDdaInitialize(HANDLE directsound);
BOOL STORMAPI SFileDdaSetVolume(HANDLE directsound, signed int bigvolume, signed int volume);
BOOL STORMAPI SFileDestroy();

BOOL STORMAPI SFileGetFileArchive(HANDLE hFile, HANDLE archive);
LONG STORMAPI SFileGetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL STORMAPI SFileOpenArchive(const char *szMpqName, DWORD dwPriority, DWORD dwFlags, HANDLE *phMpq);

// values for dwFlags
enum MPQFlags
{
  MPQ_NO_LISTFILE       = 0x0010,
  MPQ_NO_ATTRIBUTES     = 0x0020,
  MPQ_FORCE_V1          = 0x0040,
  MPQ_CHECK_SECTOR_CRC  = 0x0080
};


BOOL STORMAPI SFileOpenFile(const char *filename, HANDLE *phFile);
BOOL STORMAPI SFileOpenFileEx(HANDLE hMpq, const char *szFileName, DWORD dwSearchScope, HANDLE *phFile);

// values for dwSearchScope
enum SFileFlags
{
  SFILE_FROM_MPQ      = 0x00000000,
  SFILE_FROM_ABSOLUTE = 0x00000001,
  SFILE_FROM_RELATIVE = 0x00000002,
  SFILE_FROM_DISK     = 0x00000004
};

BOOL STORMAPI SFileReadFile(HANDLE hFile, void *buffer, DWORD nNumberOfBytesToRead, DWORD *read, LONG lpDistanceToMoveHigh);

void STORMAPI SFileSetLocale(LCID lcLocale);

// mode:    0 - Silent (callback is NULL)
//          1 - Application Defined
//          2 - Handled by storm (callback is NULL)
// BOOL STORMAPI callback(const char *pszFilename, DWORD dwErrCode, DWORD dwErrCount)
BOOL STORMAPI SFileSetIoErrorMode(DWORD mode, BOOL (STORMAPI *callback)(const char*,DWORD,DWORD) );

BOOL STORMAPI SFileGetArchiveName(HANDLE hArchive, char *name, int length);
BOOL STORMAPI SFileGetFileName(HANDLE hFile, char *buffer, int length);

BOOL STORMAPI SFileLoadFile(char *filename, void *buffer, int buffersize, int a4, int a5);
BOOL STORMAPI SFileUnloadFile(HANDLE hFile);
BOOL STORMAPI SFileLoadFileEx(void *hArchive, char *filename, int a3, int a4, int a5, DWORD searchScope, struct _OVERLAPPED *lpOverlapped);

// Options are DWORD except for #6
// 1: [TRUE|FALSE] - If true, reports resource leaks (SErrReportResourceLeak/SErrReportNamedResourceLeak) to the attached debugger instead of a message box.
// 2: This option is unused.
// 3: [TRUE|FALSE] - If true, reports general memory leaks to the attached debugger instead of a message box.
// 4: This option is unused.
// 5: [TRUE|FALSE] - If true, reports log messages and log dumps to the attached debugger.
// 6: { DWORD blocks_allocated; DWORD blocks_freed; } Used to determine the amount of memory/heap blocks that have been allocated and freed by storm.
//    Can also be used for custom allocations outside of storm.
//
//BOOL STORMAPI StormGetOption(int type, void *pValue, size_t *pSize);
//BOOL STORMAPI StormSetOption(int type, void *pValue, size_t size);

BOOL STORMAPI SBltROP3(void *lpDstBuffer, void *lpSrcBuffer, int srcDrawWidth, int srcDrawHeight, int dstWidth, int srcWidth, int a7, DWORD rop);
BOOL STORMAPI SBltROP3Clipped(void *lpDstBuffer, RECT *lpDstRect, POINT *lpDstPt, int a4, void *lpSrcBuffer, RECT *lpSrcRect, POINT *lpSrcPt, int a8, int a9, DWORD rop);

#define SBMP_DEFAULT  0
#define SBMP_BMP      1
#define SBMP_PCX      2
#define SBMP_TGA      3


/*  SBmpDecodeImage @ 321
 *
 *  Decodes an image that has already been loaded into a buffer.
 *
 *  dwImgType:        Optional, the image type. See SBMP_ macros.
 *  pSrcBuffer:       A pointer to the source buffer.
 *  dwSrcBuffersize:  The size of the data in the source buffer.
 *  pPalette:         An optional buffer that receives the image palette.
 *  pDstBuffer:       A buffer that receives the image data.
 *  dwDstBuffersize:  The size of the specified image buffer. If the size of the
 *                    destination buffer is 0, then the destination buffer is not used.
 *  pdwWidth:         An optional variable that receives the image width.
 *  pdwHeight:        An optional variable that receives the image height.
 *  pdwBpp:           An optional variable that receives the image bits per pixel.
 *
 *  Returns TRUE if the image was supported and decoded correctly, FALSE otherwise.
 */
BOOL
STORMAPI
SBmpDecodeImage(
    DWORD        dwImgType,
    void         *pSrcBuffer,
    DWORD        dwSrcBuffersize,
    PALETTEENTRY *pPalette        = NULL,
    void         *pDstBuffer      = NULL,
    DWORD        dwDstBuffersize  = 0,
    DWORD        *pdwWidth        = NULL,
    DWORD        *pdwHeight       = NULL,
    DWORD        *pdwBpp          = NULL);


/*  SBmpLoadImage @ 323
 *
 *  Load an image from an available archive into a buffer.
 *
 *  pszFileName:  The name of the graphic in an active archive.
 *  pPalette:     An optional buffer that receives the image palette.
 *  pBuffer:      A buffer that receives the image data.
 *  dwBuffersize: The size of the specified image buffer.
 *  pdwWidth:     An optional variable that receives the image width.
 *  pdwHeight:    An optional variable that receives the image height.
 *  pdwBpp:       An optional variable that receives the image bits per pixel.
 *
 *  Returns TRUE if the image was supported and loaded correctly, FALSE otherwise.
 */
BOOL
STORMAPI
SBmpLoadImage(
    const char   *pszFileName,
    PALETTEENTRY *pPalette    = NULL,
    void         *pBuffer     = NULL,
    DWORD        dwBuffersize = 0,
    DWORD        *pdwWidth    = NULL,
    DWORD        *pdwHeight   = NULL,
    DWORD        *pdwBpp      = NULL);

/*  SBmpSaveImage @ 324
 *
 *  Save an image from a buffer to a file. The image format is determined
 *  from the filename and is either .gif, .pcx, .tga, or .bmp being the default.
 *
 *  pszFileName:  The name of the file to create.
 *  pPalette:     A pointer to a palette array containing 256 entries.
 *  pBuffer:      A buffer containing the image data.
 *  pdwWidth:     The width of the image.
 *  pdwHeight:    The height of the image.
 *  pdwBpp:       The bits per pixel.
 *
 *  Returns TRUE if the image was saved correctly, FALSE otherwise.
 */
BOOL
STORMAPI
SBmpSaveImage(
    const char    *pszFileName,
    PALETTEENTRY  *pPalette,
    void          *pBuffer,
    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwBpp = 8);


HANDLE STORMAPI SBmpAllocLoadImage(const char *fileName, PALETTEENTRY *palette, void **buffer, int *width, int *height, int unused6, int unused7, void *(STORMAPI *allocFunction)(DWORD));

BOOL STORMAPI SCodeCompile(char *directives1, char *directives2, char *loopstring, unsigned int maxiterations, unsigned int flags, HANDLE handle);
BOOL STORMAPI SCodeDelete(HANDLE handle);

int  STORMAPI SCodeExecute(HANDLE handle, int a2);

BOOL STORMAPI SDrawAutoInitialize(HINSTANCE hInst, LPCSTR lpClassName, LPCSTR lpWindowName, WNDPROC pfnWndProc, int nMode, int nWidth, int nHeight, int nBits);


/*  SDrawCaptureScreen @ 342
 *
 *  Saves a screenshot from the primary surface being handled by Storm.
 *
 *  pszOutput: The name of the output file. The save format is automatically set by the extension.
 *             The extensions supported are .gif, .pcx, .tga, and .bmp. It will write a bitmap by default.
 *
 *  Returns TRUE if successful and FALSE otherwise.
 */
BOOL
STORMAPI
SDrawCaptureScreen(
    const char *pszOutput);


/*  SDrawGetFrameWindow @ 346
 *
 *  Retrieves the window handle that was specified in
 *  SDrawManualInitialize or created in SDrawAutoInitialize.
 *
 *  sdraw_framewindow: Optional variable that receives the returned handle.
 *
 *  Returns the handle of the window.
 */
HWND
STORMAPI
SDrawGetFrameWindow(
    HWND *sdraw_framewindow = NULL);


/*  SDrawGetObjects @ 347
 *
 *  Retrieves the object information that was initialized using
 *  SDrawManualInitialize or SDrawAutoInitialize.
 *
 *  ddInterface:    The DirectDraw interface.
 *  primarySurface: The primary DirectDraw surface.
 *  surface2:       A second unknown surface.
 *  surface3:       A third unknown surface.
 *  backSurface:    The back DirectDraw surface.
 *  ddPalette:      The DirectDraw palette.
 *  hPalette:       The palette handle.
 *
 *  Returns FALSE if the direct draw interface has not been initialized.
 */
BOOL
STORMAPI
SDrawGetObjects(
    LPDIRECTDRAW        *ddInterface    = NULL,
    LPDIRECTDRAWSURFACE *primarySurface = NULL,
    LPDIRECTDRAWSURFACE *surface2       = NULL,
    LPDIRECTDRAWSURFACE *surface3       = NULL,
    LPDIRECTDRAWSURFACE *backSurface    = NULL,
    LPDIRECTDRAWPALETTE *ddPalette      = NULL,
    HPALETTE            *hPalette       = NULL);


/*  SDrawGetScreenSize @ 348
 *
 *  Obtains information for the current screen resolution.
 *
 *  pdwWidth:   Optional variable that receives the screen width.
 *  pdwHeight:  Optional variable that receives the screen height.
 *  pdwBpp:     Optional variable that receives the bits per pixel.
 *
 *  Returns FALSE if no variables were specified.
 */
BOOL
STORMAPI
SDrawGetScreenSize(
    DWORD *pdwWidth,
    DWORD *pdwHeight,
    DWORD *pdwBpp);


// undefined
BOOL STORMAPI SDrawLockSurface(int surfacenumber, RECT *lpDestRect, void **lplpSurface, int *lpPitch, int arg_unused);


/*  SDrawManualInitialize @ 351
 *
 *  Sets the DirectDraw variables to be referenced in Storm.
 *
 *  hWnd:           The handle of the DirectDraw window.
 *  ddInterface:    The DirectDraw interface.
 *  primarySurface: The first and primary surface.
 *  surface2:       A second surface. Behaviour not completely known.
 *  surface3:       A third surface. Behaviour not completely known.
 *  backSurface:    The fourth and final surface. The back surface.
 *  ddPalette:      The DirectDraw palette if the application requires it.
 *  hPalette:       The palette handle that belongs to the window.
 *                  If this is NULL and ddPalette is specified, then it
 *                  will be created automatically. A palette can be created
 *                  using the CreatePalette WinAPI function.
 *
 *  Returns FALSE if no variables were specified.
 */
BOOL
STORMAPI
SDrawManualInitialize(
     HWND hWnd                           = NULL,
     LPDIRECTDRAW ddInterface            = NULL,
     LPDIRECTDRAWSURFACE primarySurface  = NULL,
     LPDIRECTDRAWSURFACE surface2        = NULL,
     LPDIRECTDRAWSURFACE surface3        = NULL,
     LPDIRECTDRAWSURFACE backSurface     = NULL,
     LPDIRECTDRAWPALETTE ddPalette       = NULL,
     HPALETTE hPalette                   = NULL);


/*  SDrawPostClose @ 353
 *
 *  Posts a WM_QUIT message to the active drawing window specified
 *  in SDrawManualInitialize or created in SDrawAutoInitialize.
 *
 *  Returns TRUE if successful and FALSE otherwise.
 */
BOOL
STORMAPI
SDrawPostClose();


// undefined
//BOOL STORMAPI SDrawRealizePalette();

BOOL STORMAPI SDrawUnlockSurface(int surfacenumber, void *lpSurface, int a3, RECT *lpRect);
BOOL STORMAPI SDrawUpdatePalette(unsigned int firstentry, unsigned int numentries, PALETTEENTRY *pPalEntries, int a4);

BOOL STORMAPI SEvtDispatch(DWORD dwMessageID, DWORD dwFlags, int type, PS_EVT pEvent);

BOOL STORMAPI SGdiDeleteObject(HANDLE handle);

BOOL STORMAPI SGdiExtTextOut(int a1, int a2, int a3, int a4, unsigned int a8, signed int a6, signed int a7, const char *pszString, unsigned int arg20);
BOOL STORMAPI SGdiImportFont(HGDIOBJ handle, int windowsfont);

BOOL STORMAPI SGdiSelectObject(int handle);
BOOL STORMAPI SGdiSetPitch(int pitch);

BOOL STORMAPI Ordinal393(char *pszString, int, int);


/*  SMemAlloc @ 401
 *
 *  Allocates a block of memory. This block is different
 *  from the standard malloc by including a header containing
 *  information about the block.
 *
 *  amount:       The amount of memory to allocate, in bytes.
 *  logfilename:  The name of the file or object that this call belongs to.
 *  logline:      The line in the file or one of the SLOG_ macros.
 *  defaultValue: The default value of a byte in the allocated memory.
 *
 *  Returns a pointer to the allocated memory. This pointer does NOT include
 *  the additional storm header.
 */
void*
STORMAPI
SMemAlloc(
    size_t amount,
    char  *logfilename,
    int   logline,
    char  defaultValue = 0);

#define SMAlloc(amount) SMemAlloc((amount), __FILE__, __LINE__)


/*  SMemFree @ 403
 *
 *  Frees a block of memory that was created using SMemAlloc,
 *  includes the log file and line for debugging purposes.
 *
 *  location:     The memory location to be freed.
 *  logfilename:  The name of the file or object that this call belongs to.
 *  logline:      The line in the file or one of the SLOG_ macros.
 *  defaultValue:
 *
 *  Returns TRUE if the call was successful and FALSE otherwise.
 */
BOOL
STORMAPI
SMemFree(
    void *location,
    char *logfilename,
    int  logline,
    char defaultValue = 0);

#define SMFree(loc) SMemFree((loc), __FILE__, __LINE__)


/*  SMemReAlloc @ 405
 *
 *  Reallocates a block of memory that was created using SMemAlloc,
 *  includes the log file and line for debugging purposes.
 *
 *  location:     The memory location to be re-allocated. If this parameter
 *                is NULL, then SMemAlloc is called with the remaining parameters.
 *  amount:       The amount of memory to re-allocate.
 *  logfilename:  The name of the file or object that this call belongs to.
 *  logline:      The line in the file or one of the SLOG_ macros.
 *  defaultValue:
 *
 *  Returns a pointer to the re-allocated memory. This pointer does NOT include
 *  the additional storm header.
 */
void*
STORMAPI
SMemReAlloc(
    void    *location,
    size_t  amount,
    char    *logfilename,
    int     logline,
    char    defaultValue = 0);

#define SMReAlloc(loc,s) SMemReAlloc((loc),(s), __FILE__, __LINE__)

// Can be provided instead of logline/__LINE__ parameter to indicate different errors.
#define SLOG_EXPRESSION    0
#define SLOG_FUNCTION     -1
#define SLOG_OBJECT       -2
#define SLOG_HANDLE       -3
#define SLOG_FILE         -4
#define SLOG_EXCEPTION    -5


BOOL STORMAPI SRegLoadData(const char *keyname, const char *valuename, int size, LPBYTE lpData, BYTE flags, LPDWORD lpcbData);
BOOL STORMAPI SRegLoadString(const char *keyname, const char *valuename, BYTE flags, char *buffer, size_t buffersize);
BOOL STORMAPI SRegLoadValue(const char *keyname, const char *valuename, BYTE flags, int *value);
BOOL STORMAPI SRegSaveData(const char *keyname, const char *valuename, int size, BYTE *lpData, DWORD cbData);
BOOL STORMAPI SRegSaveString(const char *keyname, const char *valuename, BYTE flags, char *string);
BOOL STORMAPI SRegSaveValue(const char *keyname, const char *valuename, BYTE flags, DWORD result);

BOOL STORMAPI SRegDeleteValue(const char *keyname, const char *valuename, BYTE flags);

// Flags for SReg functions

// Default behaviour checks both HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER
// relative to the "Software\\Blizzard Entertainment\\" key in both hives.
#define SREG_NONE                   0x00000000
#define SREG_EXCLUDE_LOCAL_MACHINE  0x00000001  // excludes checking the HKEY_LOCAL_MACHINE hive
#define SREG_BATTLE_NET             0x00000002  // sets the relative key to "Software\\Battle.net\\" instead
#define SREG_EXCLUDE_CURRENT_USER   0x00000004  // excludes checking the HKEY_CURRENT_USER hive
#define SREG_ABSOLUTE               0x00000010  // specifies that the key is not a relative key

BOOL STORMAPI STransBlt(void *lpSurface, int x, int y, int width, HANDLE hTrans);
BOOL STORMAPI STransBltUsingMask(void *lpDest, void *lpSource, int pitch, int width, HANDLE hTrans);

BOOL STORMAPI STransDelete(HANDLE hTrans);

BOOL STORMAPI STransDuplicate(HANDLE hTransSource, HANDLE hTransDest);
BOOL STORMAPI STransIntersectDirtyArray(HANDLE hTrans, char * dirtyarraymask, unsigned flags, HANDLE * phTransResult);
BOOL STORMAPI STransInvertMask(HANDLE hTrans, HANDLE * phTransResult);

BOOL STORMAPI STransSetDirtyArrayInfo(int width, int height, int depth, int bits);

BOOL STORMAPI STransPointInMask(HANDLE hTrans, int x, int y); // Name is a pure guess
BOOL STORMAPI STransCombineMasks(HANDLE hTransA, HANDLE hTransB, int left, int top, int flags, HANDLE * phTransResult);

BOOL STORMAPI STransCreateE(void *pBuffer, int width, int height, int bpp, int a5, int bufferSize, HANDLE *phTransOut);

BOOL STORMAPI SVidDestroy();
BOOL STORMAPI SVidGetSize(HANDLE video, int width, int height, int zero);
BOOL STORMAPI SVidInitialize(HANDLE video);
BOOL STORMAPI SVidPlayBegin(char *filename, int arg4, int a3, int a4, int a5, int a6, HANDLE* video);

BOOL STORMAPI SVidPlayContinueSingle(HANDLE video, int a2, int a3);
BOOL STORMAPI SVidPlayEnd(HANDLE video);

/* SErrDisplayError @ 461
 *
 * Displays a formatted error message. The message is detailed and flexible for many applications.
 * The message will be different if there is a debugger attached. Will typically terminate the application
 * unless the option to continue is given.
 *
 *  dwErrMessage:   The error code. See SErrGetLastError and GetLastError.
 *  logfilename:    The name of the file or object that this call belongs to.
 *  logline:        The line in the file or one of the SLOG_ macros.
 *  message:        A message or expression with additional information.
 *  allowOption:    If TRUE, allows the user the option to continue execution, otherwise the program will terminate.
 *  exitCode:       The exit code used for program termination.
 *
 *  Returns TRUE if the user chose to continue execution, FALSE otherwise.
 */
BOOL
STORMAPI
SErrDisplayError(
    DWORD dwErrMsg,
    const char *logfilename,
    int logline,
    const char *message = NULL,
    BOOL allowOption = FALSE,
    int exitCode = 1);

#define SAssert(x) { if ( !(x) ) SErrDisplayError(STORM_ERROR_ASSERTION, __FILE__, __LINE__, #x) }

#define SEDisplayError(err) SErrDisplayError(e, __FILE__, __LINE__)

/*  SErrGetErrorStr @ 462
 *
 *  Retrieves a string that describes the specified error code for
 *  the system, Storm, DirectDraw, or DirectSound.
 *
 *  dwErrCode:    The error code to look up.
 *  buffer:       The destination buffer to receive the string.
 *  bufferchars:  The size of the destination buffer.
 *
 *  Returns TRUE if the call was successful and FALSE otherwise.
 */
BOOL
STORMAPI
SErrGetErrorStr(
    DWORD dwErrCode,
    char *buffer,
    size_t bufferchars);

#define SEGetErrorStr(e,b) SErrGetErrorStr(e,b,sizeof(b))


/*  SErrGetLastError @ 463
 *
 *  Retrieves the last error that was specifically
 *  set for the Storm library.
 *
 *  Returns the last error set within the Storm library.
 */
DWORD
STORMAPI
SErrGetLastError();


// Registers a module as a message source for SErrGetErrorStr, always returns TRUE
// groupID is a group in a MessageTable entry for example in STORM_ERROR_BAD_ARGUMENT 0x85100065, 0x510 is the group.
// BOOL STORMAPI SErrRegisterMessageSource(WORD groupID, HMODULE hSourceModule, int a3)


/*  SErrSetLastError @ 465
 *
 *  Sets the last error for the Storm library and the Kernel32 library.
 *
 *  dwErrCode:  The error code that will be set.
 */
void
STORMAPI
SErrSetLastError(
    DWORD dwErrCode = NO_ERROR);

//
// void STORMAPI SErrReportNamedResourceLeak(const char *pszMsg, const char *pszSubMsg = nullptr)
// void STORMAPI SErrReportResourceLeak(const char *pszMsg)

void STORMAPI SErrSuppressErrors(BOOL suppressErrors);

// Values for dwErrCode
#define STORM_ERROR_ASSERTION                    0x85100000
#define STORM_ERROR_BAD_ARGUMENT                 0x85100065
#define STORM_ERROR_GAME_ALREADY_STARTED         0x85100066
#define STORM_ERROR_GAME_FULL                    0x85100067
#define STORM_ERROR_GAME_NOT_FOUND               0x85100068
#define STORM_ERROR_GAME_TERMINATED              0x85100069
#define STORM_ERROR_INVALID_PLAYER               0x8510006a
#define STORM_ERROR_NO_MESSAGES_WAITING          0x8510006b
#define STORM_ERROR_NOT_ARCHIVE                  0x8510006c
#define STORM_ERROR_NOT_ENOUGH_ARGUMENTS         0x8510006d
#define STORM_ERROR_NOT_IMPLEMENTED              0x8510006e
#define STORM_ERROR_NOT_IN_ARCHIVE               0x8510006f
#define STORM_ERROR_NOT_IN_GAME                  0x85100070
#define STORM_ERROR_NOT_INITIALIZED              0x85100071
#define STORM_ERROR_NOT_PLAYING                  0x85100072
#define STORM_ERROR_NOT_REGISTERED               0x85100073
#define STORM_ERROR_REQUIRES_CODEC1              0x85100074
#define STORM_ERROR_REQUIRES_CODEC2              0x85100075
#define STORM_ERROR_REQUIRES_CODEC3              0x85100076
#define STORM_ERROR_REQUIRES_UPGRADE             0x85100077
#define STORM_ERROR_STILL_ACTIVE                 0x85100078
#define STORM_ERROR_VERSION_MISMATCH             0x85100079
#define STORM_ERROR_MEM_NOT_ALLOCATED            0x8510007a
#define STORM_ERROR_MEM_CORRUPTED                0x8510007b
#define STORM_ERROR_MEM_INVALID                  0x8510007c
#define STORM_ERROR_MEM_MANAGER_NOT_INITIALIZED  0x8510007d
#define STORM_ERROR_MEM_NOT_FREED                0x8510007e
#define STORM_ERROR_RESOURCES_NOT_RELEASED       0x8510007f
#define STORM_ERROR_OUT_OF_BOUNDS                0x85100080
#define STORM_ERROR_NULL_POINTER                 0x85100081
#define STORM_ERROR_CDKEY_MISMATCH               0x85100082
#define STORM_ERROR_FILE_CORRUPTED               0x85100083
#define STORM_ERROR_FATAL                        0x85100084
#define STORM_ERROR_GAMETYPE_UNAVAILABLE         0x85100085


/*  SMemCopy @ 491
 *
 *  Copies a block of memory from source to destination.
 *  This function immediately calls memcpy. See online documentation
 *  of memcpy for more details.
 *
 *  dest:   The destination buffer.
 *  source: The source buffer.
 *  size:   The number of bytes to copy.
 */
void
STORMAPI
SMemCopy(
    void *dest,
    const void *source,
    size_t size);

#define SMCopy(d,s) ( SMemCopy(d, s, __STORM_SSIZEMIN(s,d)) )

/*  SMemFill @ 492
 *
 *  Fills a block of memory with the specified character.
 *  This function immediately calls memset. See online documentation
 *  of memset for more details.
 *
 *  dest:   The destination buffer.
 *  source: The size of the destination buffer.
 *  size:   The format to use.
 */
void
STORMAPI
SMemFill(
    void *location,
    size_t length,
    char fillWith = 0);

#define SMFill(l,f) (SMemFill(l, sizeof(l), f))

/*  SMemZero @ 494
 *
 *  Fills a block of memory with the integer 0x00 (Zero).
 *
 *  location: The location to write at.
 *  length:   The amount of bytes to write.
 */
void
STORMAPI
SMemZero(
    void *location,
    size_t length);

#define SMZero(l) (SMemZero(l, sizeof(l)))


int   STORMAPI SMemCmp(void *location1, void *location2, DWORD size);

#define SMCmp(l,x) ( SMemCmp(l, x, __STORM_SSIZEMIN(x,l)) )

/*  SStrCopy @ 501
 *
 *  Copies a string from src to dest (including NULL terminator)
 *  until the max_length is reached.
 *
 *  dest:         The destination array.
 *  src:          The source array.
 *  max_length:   The maximum length of dest.
 *
 *  Returns the number of characters copied.
 */
int
STORMAPI
SStrCopy(
    char *dest,
    const char *src,
    int max_length = 0x7FFFFFFF);

#define SSCopy(d,s) (SStrCopy(d, s, sizeof(d)))

#define STORM_HASH_ABSOLUTE 1

/*  SStrHash @ 502
 *
 *  Creates a simple hash for the string. This function
 *  should NOT be used for sensitive information.
 *
 *  string:   The input string.
 *  flags:    If STORM_HASH_ABSOLUTE is set then this
              function uses the absolute string, otherwise
              it will convert backslashes to forward
              slashes and some other processing.
 *  seed:     The hash seed. If this value is 0 then the
 *            default value 0x7FED7FED will be used.
 *
 *  Returns the 32-bit hash of the string.
 */
DWORD
STORMAPI
SStrHash(
      const char *string,
      DWORD flags = 0,
      DWORD Seed  = 0);

int   STORMAPI SStrNCat(char *dest, const char *src, DWORD max_length);

/*  SStrLen @ 506
 *
 *  Retrieves the length of a string.
 *
 *  string:   The input string of which to obtain a
 *            length for.
 *
 *  Returns the length of the string.
 */
int
STORMAPI
SStrLen(
      const char *string);

/*  SStrCmp @ 508
 *
 *  Compares two strings case sensitive.
 *
 *  string1:  The first string.
 *  string2:  The second string.
 *  size:     The maximum amount of characters to compare.
 *
 *  Returns 0 if strings are equal. See strcmp documentation for more details.
 */
int
STORMAPI
SStrCmp(
      const char *string1,
      const char *string2,
      size_t size);

#define SSCmp(s,x) ( SStrCmp(s,x,__STORM_SSIZEMIN(s,x)) )

/*  SStrCmpI @ 509
 *
 *  Compares two strings case insensitive.
 *
 *  string1:  The first string.
 *  string2:  The second string.
 *  size:     The maximum amount of characters to compare.
 *
 *  Returns 0 if strings are equal. See strcmpi documentation for more details.
 */
int
STORMAPI
SStrCmpI(
      const char *string1,
      const char *string2,
      size_t size);

#define SSCmpI(s,x) ( SStrCmpI(s,x,__STORM_SSIZEMIN(s,x)) )

/*  SStrUpper @ 510
 *
 *  Converts all lower-case alpha characters of a string to upper-case.
 *
 *  string:   The string to convert.
 *
 *  Returns the same pointer given in the input.
 */
char*
STORMAPI
SStrUpper(
      char* string);

void  STORMAPI SRgn523(HANDLE hRgn, RECT *pRect, int a3, int a4);
void  STORMAPI SRgnCreateRegion(HANDLE *hRgn, int a2);
void  STORMAPI SRgnDeleteRegion(HANDLE hRgn);

void  STORMAPI SRgn529i(int handle, int a2, int a3);


/* SErrDisplayErrorFmt @ 562
 *
 * Displays a formatted error message. The message is detailed and flexible for many applications.
 * The message will be different if there is a debugger attached. Will typically terminate the application
 * unless the option to continue is given.
 *
 *  dwErrMessage:   The error code. See SErrGetLastError and GetLastError.
 *  logfilename:    The name of the file or object that this call belongs to.
 *  logline:        The line in the file or one of the SLOG_ macros.
 *  allowOption:    If TRUE, allows the user the option to continue execution, otherwise the program will terminate.
 *  exitCode:       The exit code used for program termination.
 *  format:         Additional message formatting. See printf.
 *
 *  Returns TRUE if the user chose to continue execution, FALSE otherwise.
 */
BOOL
SErrDisplayErrorFmt(
    DWORD dwErrMsg,
    const char *logfilename,
    int logline,
    BOOL allowOption,
    int exitCode,
    const char *format,
    ...);

//#define SEDisplayErrorFmt(err,...) SErrDisplayErrorFmt(err, __FILE__, __LINE__, FALSE, 1, __VA_ARGS__)

/*  SErrCatchUnhandledExceptions @ 567
 *
 *  Registers a top-level exception filter managed entirely by Storm.
 *  The registered filter will display formatted exception information by calling SErrDisplayError.
 */
void
STORMAPI
SErrCatchUnhandledExceptions();


/*  SStrChr @ 571
 *
 *  Searches a string for the given character. See
 *  strchr documentation for more details.
 *
 *  string:   The string to search.
 *  c:        The character to search for.
 *
 *  Returns a pointer to the first occurance of the character.
 */
char*
STORMAPI
SStrChr(
    const char *string,
    char c);


char *STORMAPI SStrChrR(const char *string, char c);


/*  SStrVPrintf @ 578
 *
 *  Prints a formatted string to a destination buffer.
 *  This function calls vsnprintf with some extra error handling.
 *  See online documentation of vsnprintf for more details.
 *
 *  dest:   The destination buffer.
 *  size:   The size of the destination buffer.
 *  format: The format to use.
 *
 *  Returns the number of characters written.
 */
size_t
SStrVPrintf(
    char *dest,
    size_t size,
    const char *format, ...);


int STORMAPI SBigDel(void *buffer);

int STORMAPI SBigFromBinary(void *buffer, const void *str, size_t size);

int STORMAPI SBigNew(void **buffer);

int STORMAPI SBigPowMod(void *buffer1, void *buffer2, int a3, int a4);

int STORMAPI SBigToBinaryBuffer(void *buffer, int length, int a3, int a4);

void __stdcall SDrawMessageBox(char *,char *,int);
void __cdecl SDrawDestroy(void);
bool __cdecl StormDestroy(void);
bool __stdcall SFileSetBasePath(char *);
void __cdecl SDrawRealizePalette(void);
bool __cdecl SVidPlayContinue(void);
bool __stdcall SNetGetOwnerTurnsWaiting(int *);
void * __stdcall SNetUnregisterEventHandler(int,void (__stdcall*)(struct _SNETEVENT *));
void * __stdcall SNetRegisterEventHandler(int,void (__stdcall*)(struct _SNETEVENT *));
bool __stdcall SNetSetBasePlayer(int);
int __stdcall SNetInitializeProvider(unsigned long,struct _SNETPROGRAMDATA *,struct _SNETPLAYERDATA *,struct _SNETUIDATA *,struct _SNETVERSIONDATA *);
int __stdcall SNetGetProviderCaps(struct _SNETCAPS *);
int __stdcall SFileSetFilePointer(HANDLE,int,HANDLE,int);

#ifdef __GNUC__
}
#endif

#endif
/*
 * Diablo(TM)
 *
 * Copyright (C) 1996 Blizzard Entertainment
 * All Rights Reserved.
 *
 * DiabloUI.h
 *   definitions for DiabloUI
 */


#ifdef __GNUC__
extern "C" {
#endif

void __cdecl UiDestroy(); // { return; }
void __stdcall UiTitleDialog(int a1); // { return; }
void __cdecl UiInitialize(); // { return; }
void __stdcall UiCopyProtError(int a1); // { return; }
void __stdcall UiAppActivate(int a1); // { return; }
int __stdcall UiValidPlayerName(char *a1); // { return 0; }
int __stdcall UiSelHeroMultDialog(void *fninfo, void *fncreate, void *fnremove, void *fnstats, int *a5, int *a6, char *name); // { return 0; }
int __stdcall UiSelHeroSingDialog(void *fninfo, void *fncreate, void *fnremove, void *fnstats, int *a5, char *name, int *difficulty); // { return 0; }
void __stdcall UiCreditsDialog(int a1); // { return; }
int __stdcall UiMainMenuDialog(char *name, int *a2, void *fnSound, int a4); // { return 0; }
int __stdcall UiProgressDialog(HWND window, char *msg, int a3, void *fnfunc, int a5); // { return 0; }
int __cdecl UiProfileGetString(); // { return; }
void __cdecl UiProfileCallback(); // { return; }
void __cdecl UiProfileDraw(); // { return; }
void __cdecl UiCategoryCallback(); // { return; }
void __cdecl UiGetDataCallback(); // { return; }
void __cdecl UiAuthCallback(); // { return; }
void __cdecl UiSoundCallback(); // { return; }
void __cdecl UiMessageBoxCallback(); // { return; }
void __cdecl UiDrawDescCallback(); // { return; }
void __cdecl UiCreateGameCallback(); // { return; }
void __cdecl UiArtCallback(); // { return; }
int __stdcall UiSelectGame(int a1, _SNETPROGRAMDATA *client_info, _SNETPLAYERDATA *user_info, _SNETUIDATA *ui_info, _SNETVERSIONDATA *file_info, int *a6); // { return 0; }
int __stdcall UiSelectProvider(int a1, _SNETPROGRAMDATA *client_info, _SNETPLAYERDATA *user_info, _SNETUIDATA *ui_info, _SNETVERSIONDATA *file_info, int *type); // { return 0; }
int __stdcall UiCreatePlayerDescription(_uiheroinfo *info, int mode, char *desc); // { return 0; }
int __stdcall UiSetupPlayerInfo(char *str, _uiheroinfo *info, int mode); // { return 0; }

#ifdef __GNUC__
}
#endif
//HEADER_GOES_HERE
#ifndef __APPFAT_H__
#define __APPFAT_H__

extern int appfat_terminated; // weak
extern char sz_error_buf[256];
extern int terminating; // weak
extern int cleanup_thread_id; // weak
extern char empty_string;

char *__fastcall GetErr(int error_code);
void __fastcall GetDDErr(int error_code, char *error_buf, int error_buf_len);
void __fastcall GetDSErr(int error_code, char *error_buf, int error_buf_len);
char *__cdecl GetLastErr();
void TermMsg(char *pszFmt, ...);
void __fastcall MsgBox(char *pszFmt, va_list va);
void __cdecl FreeDlg();
void DrawDlg(char *pszFmt, ...);
void __fastcall DDErrDlg(int error_code, int log_line_nr, char *log_file_path);
void __fastcall DSErrDlg(int error_code, int log_line_nr, char *log_file_path);
void __fastcall CenterDlg(HWND hDlg);
void __fastcall TermDlg(int template_id, int error_code, char *log_file_path, int log_line_nr);
bool __stdcall FuncDlg(HWND hDlg, UINT uMsg, WPARAM wParam, char *text);
void __fastcall TextDlg(HWND hDlg, char *text);
void __fastcall ErrDlg(template_id template_id, int error_code, char *log_file_path, int log_line_nr);
void __fastcall FileErrDlg(char *error);
void __fastcall DiskFreeDlg(char *error);
bool __cdecl InsertCDDlg();
void __fastcall DirErrDlg(char *error);

#endif /* __APPFAT_H__ */
//HEADER_GOES_HERE
#ifndef __AUTOMAP_H__
#define __AUTOMAP_H__

extern short automaptype[512];
extern int AMdword_4B7E40; // weak
extern int AMdword_4B7E44; // weak
extern bool automapflag; // idb
extern char AMbyte_4B7E4C[32];
extern char automapview[40][40];
extern int AutoMapScale; // idb
extern int AutoMapXOfs; // weak
extern int AutoMapYOfs; // weak
extern int AutoMapPosBits; // weak
extern int AutoMapXPos; // weak
extern int AutoMapYPos; // weak
extern int AMPlayerX; // weak
extern int AMPlayerY; // weak

void __cdecl InitAutomapOnce();
void __cdecl InitAutomap();
void __cdecl StartAutomap();
void __cdecl AutomapUp();
void __cdecl AutomapDown();
void __cdecl AutomapLeft();
void __cdecl AutomapRight();
void __cdecl AutomapZoomIn();
void __cdecl AutomapZoomOut();
void __cdecl DrawAutomap();
void __fastcall DrawAutomapType(int screen_x, int screen_y, short automap_type);
void __cdecl DrawAutomapPlr();
short __fastcall GetAutomapType(int tx, int ty, bool view);
void __cdecl DrawAutomapGame();
void __fastcall SetAutomapView(int x, int y);
void __cdecl AutomapZoomReset();

#endif /* __AUTOMAP_H__ */
//HEADER_GOES_HERE
#ifndef __CAPTURE_H__
#define __CAPTURE_H__

void __cdecl CaptureScreen();
bool __fastcall CaptureHdr(HANDLE hFile, short width, int height);
bool __fastcall CapturePal(HANDLE hFile, PALETTEENTRY *palette);
bool __fastcall CapturePix(HANDLE hFile, short width, short height, short stride, char *pixels);
char *__fastcall CaptureEnc(char *src, char *dst, int width);
HANDLE __fastcall CaptureFile(char *dst_path);
void __fastcall RedPalette(PALETTEENTRY *pal);

#endif /* __CAPTURE_H__ */
//HEADER_GOES_HERE
#ifndef __CODEC_H__
#define __CODEC_H__

int __fastcall codec_decode(void *pbSrcDst, int size, char *pszPassword);
void __fastcall codec_init_key(int unused, char *pszPassword);
int __fastcall codec_get_encoded_len(int dwSrcBytes);
void __fastcall codec_encode(void *pbSrcDst, int size, int size_64, char *pszPassword);

#endif /* __CODEC_H__ */
//HEADER_GOES_HERE
#ifndef __CONTROL_H__
#define __CONTROL_H__

extern char sgbNextTalkSave; // weak
extern char sgbTalkSavePos; // weak
extern void *pDurIcons;
extern void *pChrButtons;
extern int drawhpflag; // idb
extern int dropGoldFlag; // weak
extern int panbtn[8];
extern int chrbtn[4];
extern void *pMultiBtns;
extern void *pPanelButtons;
extern void *pChrPanel;
extern int lvlbtndown; // weak
extern char sgszTalkSave[8][80];
extern int dropGoldValue; // idb
extern int drawmanaflag; // idb
extern int chrbtnactive; // weak
extern char sgszTalkMsg[80];
extern void *pPanelText;
extern int frame_4B8800; // idb
extern void *pLifeBuff;
extern void *pBtmBuff;
extern void *pTalkBtns;
extern int pstrjust[4];
extern int pnumlines; // idb
extern int pinfoflag; // weak
extern int talkbtndown[3];
extern int pSpell; // weak
extern void *pManaBuff;
extern int infoclr; // weak
extern int sgbPlrTalkTbl; // weak // should be char [4]
extern void *pGBoxBuff;
extern void *pSBkBtnCel;
extern char tempstr[260];
extern int sbooktab; // weak
extern int pSplType; // weak
extern int frame; // idb
extern int initialDropGoldIndex; // idb
extern int talkflag; // weak
extern void *pSBkIconCels;
extern int sbookflag; // weak
extern int chrflag;
extern int drawbtnflag; // idb
extern void *pSpellBkCel;
extern char infostr[260];
extern int numpanbtns; // weak
extern void *pStatusPanel;
extern char panelstr[256];
extern int panelflag; // weak
extern char byte_4B8B88[256];
extern int initialDropGoldValue; // idb
extern void *pSpellCels;
extern int panbtndown; // weak
extern void *pTalkPanel; // idb
extern int spselflag; // weak

void __fastcall DrawSpellCel(int xp, int yp, char *Trans, int nCel, int w);
void __fastcall SetSpellTrans(char t);
void __cdecl DrawSpell();
void __cdecl DrawSpellList();
void __cdecl SetSpell();
void __fastcall SetSpeedSpell(int slot);
void __fastcall ToggleSpell(int slot);
void __fastcall CPrintString(int No, unsigned char pszStr, int Just);
void __fastcall AddPanelString(char *str, int just);
void __cdecl ClearPanel();
void __fastcall DrawPanelBox(int x, int y, int w, int h, int sx, int sy);
void __cdecl InitPanelStr();
void __fastcall SetFlaskHeight(char *buf, int min, int max, int c, int r);
void __fastcall DrawFlask(void *a1, int a2, int a3, void *a4, int a5, int a6);
void __cdecl DrawLifeFlask();
void __cdecl UpdateLifeFlask();
void __cdecl DrawManaFlask();
void __cdecl control_update_life_mana();
void __cdecl UpdateManaFlask();
void __cdecl InitControlPan();
void __cdecl ClearCtrlPan();
void __cdecl DrawCtrlPan();
void __cdecl DoSpeedBook();
void __cdecl DoPanBtn();
void __fastcall control_set_button_down(int btn_id);
void __cdecl control_check_btn_press();
void __cdecl DoAutoMap();
void __cdecl CheckPanelInfo();
void __cdecl CheckBtnUp();
void __cdecl FreeControlPan();
int __fastcall control_WriteStringToBuffer(char *str);
void __cdecl DrawInfoBox();
void __fastcall control_print_info_str(int y, char *str, bool center, int lines);
void __fastcall PrintGameStr(int x, int y, char *str, int color);
void __cdecl DrawChr();
void __fastcall ADD_PlrStringXY(int x, int y, int width, char *pszStr, char col);
void __fastcall MY_PlrStringXY(int x, int y, int width, char *pszStr, char col, int base);
void __cdecl CheckLvlBtn();
void __cdecl ReleaseLvlBtn();
void __cdecl DrawLevelUpIcon();
void __cdecl CheckChrBtns();
void __cdecl ReleaseChrBtns();
void __cdecl DrawDurIcon();
int __fastcall DrawDurIcon4Item(ItemStruct *pItem, int x, int c);
void __cdecl RedBack();
int __fastcall GetSBookTrans(int ii, unsigned char townok);
void __cdecl DrawSpellBook();
void __fastcall PrintSBookStr(int x, int y, bool cjustflag, char *pszStr, int bright);
void __cdecl CheckSBook();
char *__fastcall get_pieces_str(int nGold);
void __fastcall DrawGoldSplit(int amount);
void __fastcall control_drop_gold(int vkey);
void __fastcall control_remove_gold(int pnum, int gold_index);
void __fastcall control_set_gold_curs(int pnum);
void __cdecl DrawTalkPan();
char *__fastcall control_print_talk_msg(char *msg, int x, int y, int *a4, int just);
int __cdecl control_check_talk_btn();
void __cdecl control_release_talk_btn();
void __cdecl control_reset_talk_msg();
void __cdecl control_type_message();
void __cdecl control_reset_talk();
int __fastcall control_talk_last_key(int a1);
int __fastcall control_presskeys(int a1);
void __cdecl control_press_enter();
void __fastcall control_up_down(char a1);

/* data */
extern unsigned char fontframe[127];
extern unsigned char fontkern[68];
extern int lineoffset[25];
extern unsigned char fontidx[256];

/* rdata */

extern unsigned char SpellITbl[37];
extern int PanBtnPos[8][5];
extern char *PanBtnHotKey[8];
extern char *PanBtnStr[8];
extern RECT32 attribute_inc_rects[4];
extern int SpellPages[6][7];

#endif /* __CONTROL_H__ */
//HEADER_GOES_HERE
#ifndef __CURSOR_H__
#define __CURSOR_H__

extern int cursH; // weak
extern int icursH28; // idb
extern int cursW; // idb
extern int pcursmonst; // idb
extern int icursW28; // idb
extern void *pCursCels;
extern int icursH; // weak
extern char pcursinvitem; // weak
extern int icursW; // weak
extern char pcursitem; // weak
extern char pcursobj; // weak
extern char pcursplr; // weak
extern int cursmx;
extern int cursmy;
extern int dword_4B8CCC; // weak
extern int pcurs; // idb

void __cdecl InitCursor();
void __cdecl FreeCursor();
void __fastcall SetICursor(int i);
void __fastcall SetCursor(int i);
void __fastcall NewCursor(int i);
void __cdecl InitLevelCursor();
void __cdecl CheckTown();
void __cdecl CheckRportal();
void __cdecl CheckCursMove();

/* data */
extern int InvItemWidth[180];
extern int InvItemHeight[180];

#endif /* __CURSOR_H__ */
//HEADER_GOES_HERE
#ifndef __DEAD_H__
#define __DEAD_H__

extern int spurtndx; // weak
extern DeadStruct dead[31];
extern int stonendx;

void __cdecl InitDead();
void __fastcall AddDead(int dx, int dy, char dv, int ddir);
void __cdecl SetDead();

#endif /* __DEAD_H__ */
//HEADER_GOES_HERE
#ifndef __DEBUG_H__
#define __DEBUG_H__

extern void *pSquareCel;
extern char dMonsDbg[17][112][112];
extern char dFlagDbg[17][112][112];

void __cdecl LoadDebugGFX();
void __cdecl FreeDebugGFX();
void __cdecl CheckDungeonClear();
#ifdef _DEBUG
void __cdecl GiveGoldCheat();
void __cdecl StoresCheat();
void __cdecl TakeGoldCheat();
void __cdecl MaxSpellsCheat();
void __fastcall PrintDebugPlayer(bool bNextPlayer);
void __cdecl PrintDebugQuest();
void __fastcall PrintDebugMonster(int m);
void __cdecl GetDebugMonster();
void __cdecl NextDebugMonster();
#endif

#endif /* __DEBUG_H__ */
//HEADER_GOES_HERE
#ifndef __DIABLO_H__
#define __DIABLO_H__

extern int diablo_cpp_init_value; // weak
extern HWND ghMainWnd;
extern int glMid1Seed[17];
extern int glMid2Seed[17];
extern int gnLevelTypeTbl[17];
extern int MouseY; // idb
extern int MouseX; // idb
extern bool gbGameLoopStartup; // idb
extern int glSeedTbl[17];
extern int gbRunGame; // weak
extern int glMid3Seed[17];
extern int gbRunGameResult; // weak
extern int zoomflag; // weak
extern int gbProcessPlayers; // weak
extern int glEndSeed[17];
extern int dword_5256E8; // weak
extern HINSTANCE ghInst; // idb
extern int DebugMonsters[10];
extern char cineflag; // weak
extern int drawpanflag; // weak
extern int visiondebug; // weak
extern int scrollflag; /* unused */
extern int light4flag; // weak
extern int leveldebug; // weak
extern int monstdebug; // weak
extern int trigdebug; /* unused */
extern int setseed; // weak
extern int debugmonsttypes; // weak
extern int PauseMode; // weak
extern int sgnTimeoutCurs;
extern char sgbMouseDown; // weak
extern int color_cycle_timer; // weak

void __cdecl diablo_cpp_init();
void __cdecl FreeGameMem();
int __fastcall diablo_init_menu(int a1, int bSinglePlayer);
void __fastcall run_game_loop(int uMsg);
void __fastcall start_game(int uMsg);
void __cdecl free_game();
bool __cdecl diablo_get_not_running();
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
void __fastcall diablo_parse_flags(char *args);
void __cdecl diablo_init_screen();
HWND __fastcall diablo_find_window(LPCSTR lpClassName);
void __fastcall diablo_reload_process(HMODULE hModule);
int __cdecl PressEscKey();
LRESULT __stdcall DisableInputWndProc(HWND hWnd, int uMsg, int wParam, int lParam);
int __stdcall GM_Game(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
bool __fastcall LeftMouseDown(int a1);
bool __cdecl TryIconCurs();
void __cdecl LeftMouseUp();
void __cdecl RightMouseDown();
void __fastcall j_gmenu_on_mouse_move(LPARAM lParam);
bool __fastcall PressSysKey(int wParam);
void __fastcall diablo_hotkey_msg(int dwMsg);
void __fastcall ReleaseKey(int vkey);
void __fastcall PressKey(int vkey);
void __cdecl diablo_pause_game();
void __fastcall PressChar(int vkey);
void __cdecl LoadLvlGFX();
void __cdecl LoadAllGFX();
void __fastcall CreateLevel(int lvldir);
void __fastcall LoadGameLevel(bool firstflag, int lvldir);
void __fastcall game_loop(bool startup);
void __cdecl game_logic();
void __fastcall timeout_cursor(bool timeout);
void __cdecl diablo_color_cyc_logic();

/* data */

extern int diablo_inf; // weak

/* rdata */

extern int fullscreen; // weak
#ifdef _DEBUG
extern int showintrodebug;
extern int questdebug;
extern int debug_mode_key_s;
extern int debug_mode_key_w;
extern int debug_mode_key_inverted_v;
extern int debug_mode_dollar_sign;
extern int debug_mode_key_d;
extern int debug_mode_key_i;
extern int dbgplr;
extern int dbgqst;
extern int dbgmon;
extern int frameflag;
extern int frameend;
extern int framerate;
extern int framestart;
#endif
extern int FriendlyMode; // weak
extern char *spszMsgTbl[4]; // weak
extern char *spszMsgKeyTbl[4]; // weak

#endif /* __DIABLO_H__ */
//HEADER_GOES_HERE
#ifndef __DOOM_H__
#define __DOOM_H__

extern int doom_quest_time; // weak
extern int doom_stars_drawn; // weak
extern void *pDoomCel;
extern int doomflag; // weak
extern int DoomQuestState; // idb

int __cdecl doom_get_frame_from_time();
void __cdecl doom_alloc_cel();
void __cdecl doom_cleanup();
void __cdecl doom_load_graphics();
void __cdecl doom_init();
void __cdecl doom_close();
void __cdecl doom_draw();

#endif /* __DOOM_H__ */
//HEADER_GOES_HERE
#ifndef __DRLG_L1_H__
#define __DRLG_L1_H__

extern char L5dungeon[80][80];
extern char mydflags[40][40];
extern int setloadflag; // weak
extern int HR1;
extern int HR2;
extern int HR3;
extern int VR1;
extern int VR2;
extern int VR3;
extern void *pSetPiece; // idb

void __cdecl DRLG_Init_Globals();
void __fastcall LoadL1Dungeon(char *sFileName, int vx, int vy);
void __cdecl DRLG_L1Floor();
void __cdecl DRLG_L1Pass3();
void __cdecl DRLG_InitL1Vals();
void __fastcall LoadPreL1Dungeon(char *sFileName, int vx, int vy);
void __fastcall CreateL5Dungeon(int rseed, int entry);
void __cdecl DRLG_LoadL1SP();
void __cdecl DRLG_FreeL1SP();
void __fastcall DRLG_L5(int entry);
void __fastcall DRLG_PlaceDoor(int x, int y);
void __cdecl DRLG_L1Shadows();
int __fastcall DRLG_PlaceMiniSet(unsigned char *miniset, int tmin, int tmax, int cx, int cy, bool setview, int noquad, int ldir);
void __cdecl InitL5Dungeon();
void __cdecl L5ClearFlags();
void __cdecl L5firstRoom();
void __fastcall L5drawRoom(int x, int y, int w, int h);
void __fastcall L5roomGen(int x, int y, int w, int h, bool dir);
bool __fastcall L5checkRoom(int x, int y, int width, int height);
int __cdecl L5GetArea();
void __cdecl L5makeDungeon();
void __cdecl L5makeDmt();
void __cdecl L5AddWall();
int __fastcall L5HWallOk(int i, int j);
int __fastcall L5VWallOk(int i, int j);
void __fastcall L5HorizWall(int i, int j, char p, int dx);
void __fastcall L5VertWall(int i, int j, char p, int dy);
void __cdecl L5tileFix();
void __cdecl DRLG_L5Subs();
void __cdecl L5FillChambers();
void __fastcall DRLG_L5GChamber(int sx, int sy, bool topflag, bool bottomflag, bool leftflag, bool rightflag);
void __fastcall DRLG_L5GHall(int x1, int y1, int x2, int y2);
void __fastcall DRLG_L5SetRoom(int rx1, int ry1);
void __cdecl DRLG_L5FloodTVal();
void __fastcall DRLG_L5FTVR(int i, int j, int x, int y, int d);
void __cdecl DRLG_L5TransFix();
void __cdecl DRLG_L5DirtFix();
void __cdecl DRLG_L5CornerFix();

/* data */
extern ShadowStruct SPATS[37];
extern unsigned char BSTYPES[206];
extern unsigned char L5BTYPES[206];
extern unsigned char STAIRSUP[];
extern unsigned char L5STAIRSUP[];
extern unsigned char STAIRSDOWN[];
extern unsigned char LAMPS[];
extern unsigned char PWATERIN[];

/* rdata */
extern unsigned char L5ConvTbl[16];

#endif /* __DRLG_L1_H__ */
//HEADER_GOES_HERE
#ifndef __DRLG_L2_H__
#define __DRLG_L2_H__

extern int nSx1;
extern int nSx2; // weak
extern int nSy1;
extern int nSy2; // weak
extern int nRoomCnt;
extern char predungeon[40][40];
extern ROOMNODE RoomList[81];
extern HALLNODE *pHallList;

void __cdecl InitDungeon();
void __cdecl L2LockoutFix();
void __cdecl L2DoorFix();
void __fastcall LoadL2Dungeon(char *sFileName, int vx, int vy);
void __cdecl DRLG_L2Pass3();
void __fastcall LoadPreL2Dungeon(char *sFileName, int vx, int vy);
void __fastcall CreateL2Dungeon(int rseed, int entry);
void __cdecl DRLG_LoadL2SP();
void __cdecl DRLG_FreeL2SP();
void __fastcall DRLG_L2(int entry);
bool __fastcall DRLG_L2PlaceMiniSet(char *miniset, int tmin, int tmax, int cx, int cy, bool setview, int ldir);
void __fastcall DRLG_L2PlaceRndSet(char *miniset, int rndper);
void __cdecl DRLG_L2Subs();
void __cdecl DRLG_L2Shadows();
void __fastcall DRLG_L2SetRoom(int rx1, int ry1);
void __cdecl L2TileFix();
bool __cdecl CreateDungeon();
void __fastcall CreateRoom(int nX1, int nY1, int nX2, int nY2, int nRDest, int nHDir, int ForceHW, int nH, int nW);
void __fastcall DefineRoom(int nX1, int nY1, int nX2, int nY2, int ForceHW);
void __fastcall AddHall(int nX1, int nY1, int nX2, int nY2, int nHd);
void __fastcall GetHall(int *nX1, int *nY1, int *nX2, int *nY2, int *nHd);
void __fastcall ConnectHall(int nX1, int nY1, int nX2, int nY2, int nHd);
void __fastcall CreateDoorType(int nX, int nY);
void __fastcall PlaceHallExt(int nX, int nY);
void __fastcall DoPatternCheck(int i, int j);
bool __cdecl DL2_FillVoids();
bool __fastcall DL2_Cont(bool x1f, bool y1f, bool x2f, bool y2f);
int __cdecl DL2_NumNoChar();
void __fastcall DL2_DrawRoom(int x1, int y1, int x2, int y2);
void __fastcall DL2_KnockWalls(int x1, int y1, int x2, int y2);
void __cdecl DRLG_L2FloodTVal();
void __fastcall DRLG_L2FTVR(int i, int j, int x, int y, int d);
void __cdecl DRLG_L2TransFix();
void __cdecl L2DirtFix();
void __cdecl DRLG_InitL2Vals();

/* rdata */
extern int Area_Min; // weak
extern int Room_Max; // weak
extern int Room_Min; // weak
extern int Dir_Xadd[5];
extern int Dir_Yadd[5];
extern ShadowStruct SPATSL2[2];
//short word_48489A;
extern unsigned char BTYPESL2[161];
extern unsigned char BSTYPESL2[161];
extern unsigned char VARCH1[];
extern unsigned char VARCH2[];
extern unsigned char VARCH3[];
extern unsigned char VARCH4[];
extern unsigned char VARCH5[];
extern unsigned char VARCH6[];
extern unsigned char VARCH7[];
extern unsigned char VARCH8[];
extern unsigned char VARCH9[];
extern unsigned char VARCH10[];
extern unsigned char VARCH11[];
extern unsigned char VARCH12[];
extern unsigned char VARCH13[];
extern unsigned char VARCH14[];
extern unsigned char VARCH15[];
extern unsigned char VARCH16[];
extern unsigned char VARCH17[];
extern unsigned char VARCH18[];
extern unsigned char VARCH19[];
extern unsigned char VARCH20[];
extern unsigned char VARCH21[];
extern unsigned char VARCH22[];
extern unsigned char VARCH23[];
extern unsigned char VARCH24[];
extern unsigned char VARCH25[];
extern unsigned char VARCH26[];
extern unsigned char VARCH27[];
extern unsigned char VARCH28[];
extern unsigned char VARCH29[];
extern unsigned char VARCH30[];
extern unsigned char VARCH31[];
extern unsigned char VARCH32[];
extern unsigned char VARCH33[];
extern unsigned char VARCH34[];
extern unsigned char VARCH35[];
extern unsigned char VARCH36[];
extern unsigned char VARCH37[];
extern unsigned char VARCH38[];
extern unsigned char VARCH39[];
extern unsigned char VARCH40[];
extern unsigned char HARCH1[];
extern unsigned char HARCH2[];
extern unsigned char HARCH3[];
extern unsigned char HARCH4[];
extern unsigned char HARCH5[];
extern unsigned char HARCH6[];
extern unsigned char HARCH7[];
extern unsigned char HARCH8[];
extern unsigned char HARCH9[];
extern unsigned char HARCH10[];
extern unsigned char HARCH11[];
extern unsigned char HARCH12[];
extern unsigned char HARCH13[];
extern unsigned char HARCH14[];
extern unsigned char HARCH15[];
extern unsigned char HARCH16[];
extern unsigned char HARCH17[];
extern unsigned char HARCH18[];
extern unsigned char HARCH19[];
extern unsigned char HARCH20[];
extern unsigned char HARCH21[];
extern unsigned char HARCH22[];
extern unsigned char HARCH23[];
extern unsigned char HARCH24[];
extern unsigned char HARCH25[];
extern unsigned char HARCH26[];
extern unsigned char HARCH27[];
extern unsigned char HARCH28[];
extern unsigned char HARCH29[];
extern unsigned char HARCH30[];
extern unsigned char HARCH31[];
extern unsigned char HARCH32[];
extern unsigned char HARCH33[];
extern unsigned char HARCH34[];
extern unsigned char HARCH35[];
extern unsigned char HARCH36[];
extern unsigned char HARCH37[];
extern unsigned char HARCH38[];
extern unsigned char HARCH39[];
extern unsigned char HARCH40[];
extern unsigned char USTAIRS[];
extern unsigned char DSTAIRS[];
extern unsigned char WARPSTAIRS[];
extern unsigned char CRUSHCOL[];
extern unsigned char BIG1[];
extern unsigned char BIG2[];
extern unsigned char BIG3[];
extern unsigned char BIG4[];
extern unsigned char BIG5[];
extern unsigned char BIG6[];
extern unsigned char BIG7[];
extern unsigned char BIG8[];
extern unsigned char BIG9[];
extern unsigned char BIG10[];
extern unsigned char RUINS1[];
extern unsigned char RUINS2[];
extern unsigned char RUINS3[];
extern unsigned char RUINS4[];
extern unsigned char RUINS5[];
extern unsigned char RUINS6[];
extern unsigned char RUINS7[];
extern unsigned char PANCREAS1[];
extern unsigned char PANCREAS2[];
extern unsigned char CTRDOOR1[];
extern unsigned char CTRDOOR2[];
extern unsigned char CTRDOOR3[];
extern unsigned char CTRDOOR4[];
extern unsigned char CTRDOOR5[];
extern unsigned char CTRDOOR6[];
extern unsigned char CTRDOOR7[];
extern unsigned char CTRDOOR8[];
extern int Patterns[100][10];

#endif /* __DRLG_L2_H__ */
//HEADER_GOES_HERE
#ifndef __DRLG_L3_H__
#define __DRLG_L3_H__

extern char lavapool; // weak
extern int abyssx; // weak
extern int lockoutcnt; // weak
extern char lockout[40][40];

void __cdecl AddFenceDoors();
void __cdecl FenceDoorFix();
int __cdecl DRLG_L3Anvil();
void __cdecl FixL3Warp();
void __cdecl FixL3HallofHeroes();
void __fastcall DRLG_L3LockRec(int x, int y);
bool __cdecl DRLG_L3Lockout();
void __fastcall CreateL3Dungeon(int rseed, int entry);
void __fastcall DRLG_L3(int entry);
void __cdecl InitL3Dungeon();
int __fastcall DRLG_L3FillRoom(int x1, int y1, int x2, int y2);
void __fastcall DRLG_L3CreateBlock(int x, int y, int obs, int dir);
void __fastcall DRLG_L3FloorArea(int x1, int y1, int x2, int y2);
void __cdecl DRLG_L3FillDiags();
void __cdecl DRLG_L3FillSingles();
void __cdecl DRLG_L3FillStraights();
void __cdecl DRLG_L3Edges();
int __cdecl DRLG_L3GetFloorArea();
void __cdecl DRLG_L3MakeMegas();
void __cdecl DRLG_L3River();
void __cdecl DRLG_L3Pool();
int __fastcall DRLG_L3SpawnEdge(int x, int y, int *totarea);
int __fastcall DRLG_L3Spawn(int x, int y, int *totarea);
void __cdecl DRLG_L3PoolFix();
int __fastcall DRLG_L3PlaceMiniSet(unsigned char *miniset, int tmin, int tmax, int cx, int cy, bool setview, int ldir);
void __fastcall DRLG_L3PlaceRndSet(unsigned char *miniset, int rndper);
void __cdecl DRLG_L3Wood();
bool __fastcall WoodVertU(int i, int y);
bool __fastcall WoodVertD(int i, int y);
bool __fastcall WoodHorizL(int x, int j);
bool __fastcall WoodHorizR(int x, int j);
void __cdecl DRLG_L3Pass3();
void __fastcall LoadL3Dungeon(char *sFileName, int vx, int vy);
void __fastcall LoadPreL3Dungeon(char *sFileName, int vx, int vy);

/* data */
extern unsigned char L3ConvTbl[16];
extern unsigned char L3UP[20];
extern unsigned char L3DOWN[20];
extern unsigned char L3HOLDWARP[20];
extern unsigned char L3TITE1[34];
extern unsigned char L3TITE2[34];
extern unsigned char L3TITE3[34];
extern unsigned char L3TITE6[42];
extern unsigned char L3TITE7[42];
extern unsigned char L3TITE8[20];
extern unsigned char L3TITE9[20];
extern unsigned char L3TITE10[20];
extern unsigned char L3TITE11[20];
extern unsigned char L3TITE12[6];
extern unsigned char L3TITE13[6];
extern unsigned char L3CREV1[6];
extern unsigned char L3CREV2[6];
extern unsigned char L3CREV3[6];
extern unsigned char L3CREV4[6];
extern unsigned char L3CREV5[6];
extern unsigned char L3CREV6[6];
extern unsigned char L3CREV7[6];
extern unsigned char L3CREV8[6];
extern unsigned char L3CREV9[6];
extern unsigned char L3CREV10[6];
extern unsigned char L3CREV11[6];
extern unsigned char L3ISLE1[14];
extern unsigned char L3ISLE2[14];
extern unsigned char L3ISLE3[14];
extern unsigned char L3ISLE4[14];
extern unsigned char L3ISLE5[10];
extern unsigned char L3XTRA1[4];
extern unsigned char L3XTRA2[4];
extern unsigned char L3XTRA3[4];
extern unsigned char L3XTRA4[4];
extern unsigned char L3XTRA5[4];
extern unsigned char L3ANVIL[244];
extern unsigned char L3SpawnTbl1[15]; /* local spawntable? */
extern unsigned char L3SpawnTbl2[15]; /* local spawntable? */
extern unsigned char L3PoolSub[15]; /* local poolsub? */

#endif /* __DRLG_L3_H__ */
//HEADER_GOES_HERE
#ifndef __DRLG_L4_H__
#define __DRLG_L4_H__

extern int diabquad1x; // weak
extern int diabquad1y; // weak
extern int diabquad3x; // idb
extern int diabquad3y; // idb
extern int diabquad2x; // idb
extern int diabquad2y; // idb
extern int diabquad4x; // idb
extern int diabquad4y; // idb
extern int hallok[20];
extern int l4holdx; // weak
extern int l4holdy; // weak
extern int SP4x1; // idb
extern int SP4x2; // weak
extern int SP4y1; // idb
extern int SP4y2; // weak
extern char L4dungeon[80][80];
extern char dung[20][20];
//int dword_52A4DC; // weak

void __cdecl DRLG_LoadL4SP();
void __cdecl DRLG_FreeL4SP();
void __fastcall DRLG_L4SetSPRoom(int rx1, int ry1);
void __cdecl L4SaveQuads();
void __fastcall DRLG_L4SetRoom(unsigned char *pSetPiece, int rx1, int ry1);
void __fastcall DRLG_LoadDiabQuads(bool preflag);
bool __fastcall IsDURWall(char d);
bool __fastcall IsDLLWall(char dd);
void __cdecl L4FixRim();
void __cdecl DRLG_L4GeneralFix();
void __fastcall CreateL4Dungeon(int rseed, int entry);
void __fastcall DRLG_L4(int entry);
void __cdecl DRLG_L4Shadows();
void __cdecl InitL4Dungeon();
void __cdecl L4makeDmt();
void __cdecl L4AddWall();
int __fastcall L4HWallOk(int i, int j);
int __fastcall L4VWallOk(int i, int j);
void __fastcall L4HorizWall(int i, int j, int dx);
void __fastcall L4VertWall(int i, int j, int dy);
void __cdecl L4tileFix();
void __cdecl DRLG_L4Subs();
void __cdecl L4makeDungeon();
void __cdecl uShape();
int __cdecl GetArea();
void __cdecl L4firstRoom();
void __fastcall L4drawRoom(int x, int y, int width, int height);
void __fastcall L4roomGen(int x, int y, int w, int h, int dir);
bool __fastcall L4checkRoom(int x, int y, int width, int height);
bool __fastcall DRLG_L4PlaceMiniSet(unsigned char *miniset, int tmin, int tmax, int cx, int cy, int setview, int ldir);
void __cdecl DRLG_L4FloodTVal();
void __fastcall DRLG_L4FTVR(int i, int j, int x, int y, int d);
void __cdecl DRLG_L4TransFix();
void __cdecl DRLG_L4Corners();
void __cdecl DRLG_L4Pass3();

/* data */
extern unsigned char L4ConvTbl[16];
extern unsigned char L4USTAIRS[42];
extern unsigned char L4TWARP[42];
extern unsigned char L4DSTAIRS[52];
extern unsigned char L4PENTA[52];
extern unsigned char L4PENTA2[52];
extern unsigned char L4BTYPES[140];

#endif /* __DRLG_L4_H__ */
//HEADER_GOES_HERE
#ifndef __DTHREAD_H__
#define __DTHREAD_H__

extern int dthread_cpp_init_value; // weak
extern unsigned int glpDThreadId; // idb
extern TMegaPkt *sgpInfoHead; /* may not be right struct */
extern char byte_52A508; // weak
extern HANDLE sghWorkToDoEvent; // idb

void __cdecl dthread_cpp_init_1();
void __cdecl dthread_cpp_init_2();
void __cdecl dthread_init_mutex();
void __cdecl dthread_cleanup_mutex_atexit();
void __cdecl dthread_cleanup_mutex();
void __fastcall dthread_remove_player(int pnum);
void __fastcall dthread_send_delta(int pnum, int cmd, void *pbSrc, int dwLen);
void __cdecl dthread_start();
unsigned int __stdcall dthread_handler(void *a1);
void __cdecl dthread_cleanup();

/* data */
extern int dthread_inf; // weak

#endif /* __DTHREAD_H__ */
//HEADER_GOES_HERE
#ifndef __DX_H__
#define __DX_H__

extern void *sgpBackBuf;
extern int dx_cpp_init_value; // weak
extern IDirectDraw *lpDDInterface;
extern IDirectDrawPalette *lpDDPalette; // idb
extern int sgdwLockCount;
extern Screen *gpBuffer;
extern IDirectDrawSurface *lpDDSBackBuf;
extern IDirectDrawSurface *lpDDSPrimary;
extern char gbBackBuf; // weak
extern char gbEmulate; // weak
extern HMODULE ghDiabMod; // idb

void __cdecl dx_cpp_init_1();
void __cdecl dx_cpp_init_2();
void __cdecl dx_init_mutex();
void __cdecl dx_cleanup_mutex_atexit();
void __cdecl dx_cleanup_mutex();
void __fastcall dx_init(HWND hWnd);
void __cdecl dx_create_back_buffer();
void __cdecl dx_create_primary_surface();
HRESULT __fastcall dx_DirectDrawCreate(GUID *guid, IDirectDraw **DD, void *unknown);
void __cdecl j_dx_lock_mutex();
void __cdecl dx_lock_mutex();
void __cdecl j_dx_unlock_mutex();
void __cdecl dx_unlock_mutex();
void __cdecl dx_cleanup();
void __cdecl dx_reinit();
void __cdecl j_dx_reinit();

/* data */

extern int dx_inf; // weak

#endif /* __DX_H__ */
//HEADER_GOES_HERE
#ifndef __EFFECTS_H__
#define __EFFECTS_H__

extern int effects_cpp_init_value; // weak
extern int sfxdelay; // weak
extern int sfxdnum;
extern void *sfx_stream;
extern TSFX *sfx_data_cur;

void __cdecl effects_cpp_init();
bool __fastcall effect_is_playing(int nSFX);
void __cdecl sfx_stop();
void __fastcall InitMonsterSND(int monst);
void __cdecl FreeEffects();
void __fastcall PlayEffect(int i, int mode);
int __fastcall calc_snd_position(int x, int y, int *plVolume, int *plPan);
void __fastcall PlaySFX(int psfx);
void __fastcall PlaySFX_priv(TSFX *pSFX, char loc, int x, int y);
void __fastcall stream_play(TSFX *pSFX, int lVolume, int lPan);
int __fastcall RndSFX(int psfx);
void __fastcall PlaySfxLoc(int psfx, int x, int y);
void __cdecl FreeMonsterSnd();
void __cdecl sound_stop();
void __cdecl sound_update();
void __cdecl effects_cleanup_sfx();
void __cdecl stream_update();
void __fastcall priv_sound_init(int bLoadMask);
void __cdecl sound_init();
void __stdcall effects_play_sound(char *snd_file);

/* data */

extern int effects_inf; // weak
extern char monster_action_sounds[]; // idb

/* rdata */

extern TSFX sgSFX[858];

#endif /* __EFFECTS_H__ */
//HEADER_GOES_HERE
#ifndef __ENCRYPT_H__
#define __ENCRYPT_H__

extern int encrypt_table[1280];
//int encrypt_52B564[257];

void __fastcall encrypt_decrypt_block(void *block, int size, int key);
void __fastcall encrypt_encrypt_block(void *block, int size, int key);
int __fastcall encrypt_hash(char *s, int type);
void __cdecl encrypt_init_lookup_table();
int __fastcall encrypt_compress(void *buf, int size);
unsigned int __cdecl encrypt_pkware_read(char *buf, unsigned int *size, void *param);
void __cdecl encrypt_pkware_write(char *buf, unsigned int *size, void *param);
void __fastcall encrypt_decompress(void *param, int recv_size, int dwMaxBytes);

#endif /* __ENCRYPT_H__ */
//HEADER_GOES_HERE
#ifndef __ENGINE_H__
#define __ENGINE_H__

//offset 0
//pCelBuff->pFrameTable[0]

extern int engine_cpp_init_value; // weak
extern char byte_52B96C; // automap pixel color 8-bit (palette entry)
extern int dword_52B970; // bool flip - if y < x
extern int orgseed; // weak
extern int sgnWidth;
extern int sglGameSeed; // weak
extern int SeedCount; // weak
extern int dword_52B99C; // bool valid - if x/y are in bounds

void __cdecl engine_cpp_init_1();
void __fastcall CelDrawDatOnly(char *pDecodeTo, char *pRLEBytes, int dwRLESize, int dwRLEWdt);
void __fastcall CelDecodeOnly(int screen_x, int screen_y, void *pCelBuff, int frame, int frame_width);
void __fastcall CelDecDatOnly(char *pBuff, char *pCelBuff, int frame, int frame_width);
void __fastcall CelDrawHdrOnly(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int always_0, int direction);
void __fastcall CelDecodeHdrOnly(char *pBuff, char *pCelBuff, int frame, int frame_width, int always_0, int direction);
void __fastcall CelDecDatLightOnly(char *pDecodeTo, char *pRLEBytes, int frame_content_size, int frame_width);
void __fastcall CelDecDatLightEntry(int a1, char *a2, char *a3, char *v6);
void __fastcall CelDecDatLightTrans(char *pDecodeTo, char *pRLEBytes, int frame_content_size, int frame_width);
void __fastcall CelDecodeLightOnly(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width);
void __fastcall CelDecodeHdrLightOnly(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int always_0, int direction);
void __fastcall CelDecodeHdrLightTrans(char *pBuff, char *pCelBuff, int frame, int frame_width, int always_0, int direction);
void __fastcall CelDrawHdrLightRed(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int always_0, int direction, char always_1);
void __fastcall Cel2DecDatOnly(char *pDecodeTo, char *pRLEBytes, int frame_content_size, int frame_width);
void __fastcall Cel2DrawHdrOnly(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int a6, int direction);
void __fastcall Cel2DecodeHdrOnly(char *pBuff, char *pCelBuff, int frame, int frame_width, int a5, int direction);
void __fastcall Cel2DecDatLightOnly(char *pDecodeTo, char *pRLEBytes, int frame_content_size, int frame_width);
void __fastcall Cel2DecDatLightEntry(int a1, int a2);
void __fastcall Cel2DecDatLightTrans(char *pDecodeTo, char *pRLEBytes, int frame_content_size, int frame_width);
void __fastcall Cel2DecodeHdrLight(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int a6, int direction);
void __fastcall Cel2DecodeLightTrans(char *dst_buf, char *pCelBuff, int frame, int frame_width, int a5, int direction);
void __fastcall Cel2DrawHdrLightRed(int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int always_0, int direction, char always_1);
void __fastcall CelDecodeRect(char *pBuff, int always_0, int dst_height, int dst_width, char *pCelBuff, int frame, int frame_width);
void __fastcall CelDecodeClr(char colour, int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int a7, int direction);
void __fastcall CelDrawHdrClrHL(char colour, int screen_x, int screen_y, char *pCelBuff, int frame, int frame_width, int a7, int direction);
void __fastcall ENG_set_pixel(int screen_x, int screen_y, char pixel);
void __fastcall engine_draw_pixel(int x, int y);
void __fastcall engine_draw_automap_pixels(int x1, int y1, int x2, int y2, char a5);
int __fastcall GetDirection(int x1, int y1, int x2, int y2);
void __fastcall SetRndSeed(int s);
int __cdecl GetRndSeed();
int __fastcall random(int idx, int v);
void __cdecl engine_cpp_init_2();
void __cdecl mem_init_mutex();
void __cdecl mem_atexit_mutex();
void __cdecl mem_free_mutex();
void *__fastcall DiabloAllocPtr(int dwBytes);
void __fastcall mem_free_dbg(void *ptr);
unsigned char *__fastcall LoadFileInMem(char *pszName, int *pdwFileLen);
void __fastcall LoadFileWithMem(char *pszName, void *buf);
void __fastcall Cl2ApplyTrans(char *p, char *ttbl, int last_frame);
void __fastcall Cl2DecodeFrm1(int x, int y, char *pCelBuff, int nCel, int width, int dir1, int dir2);
void __fastcall Cl2DecDatFrm1(char *buffer, char *frame_content, int a3, int width);
void __fastcall Cl2DecodeFrm2(char colour, int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a7, int a8);
void __fastcall Cl2DecDatFrm2(char *buffer, char *a2, int a3, int a4, char a5);
void __fastcall Cl2DecodeFrm3(int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a6, int a7, char a8);
void __fastcall Cl2DecDatLightTbl1(char *a1, char *a2, int a3, int a4, char *unused_lindex);
void __fastcall Cl2DecodeLightTbl(int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a6, int a7);
void __fastcall Cl2DecodeFrm4(int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a6, int a7);
void __fastcall Cl2DecDatFrm4(char *buffer, char *a2, int a3, int frame_width);
void __fastcall Cl2DecodeClrHL(char colour, int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a7, int a8);
void __fastcall Cl2DecDatClrHL(char *dst_buf, char *frame_content, int a3, int frame_width, char colour);
void __fastcall Cl2DecodeFrm5(int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a6, int a7, char a8);
void __fastcall Cl2DecDatLightTbl2(char *dst_buf, char *a2, int a3, int frame_width, char *a5);
void __fastcall Cl2DecodeFrm6(int screen_x, int screen_y, char *pCelBuff, int nCel, int frame_width, int a6, int a7);
void __fastcall PlayInGameMovie(char *pszMovie);

/* data */

extern int engine_inf; // weak

#endif /* __ENGINE_H__ */
//HEADER_GOES_HERE
#ifndef __ERROR_H__
#define __ERROR_H__

extern char msgtable[80];
extern char msgdelay; // weak
extern char msgflag; // weak
extern char msgcnt; // weak

void __fastcall InitDiabloMsg(char e);
void __cdecl ClrDiabloMsg();
void __cdecl DrawDiabloMsg();

/* data */
extern char *MsgStrings[44];

#endif /* __ERROR_H__ */
//HEADER_GOES_HERE
#ifndef __FAULT_H__
#define __FAULT_H__

//int dword_52B9F4;
extern LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter; // idb

void __cdecl exception_cpp_init();
void __cdecl exception_install_filter();
void __cdecl j_exception_init_filter();
void __cdecl exception_init_filter();
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
void __fastcall exception_hex_format(char *a1, char a2);
void __fastcall exception_unknown_module(LPCVOID lpAddress, LPSTR lpString1, int iMaxLength, int a4, int a5);
void __fastcall exception_call_stack(void *a1, LPVOID lp);
char *__fastcall exception_get_error_type(DWORD dwMessageId, LPSTR lpString1, DWORD nSize);
void __fastcall exception_set_filter();
LPTOP_LEVEL_EXCEPTION_FILTER __cdecl exception_set_filter_ptr();
LPTOP_LEVEL_EXCEPTION_FILTER __cdecl exception_get_filter();

#endif /* __FAULT_H__ */
//HEADER_GOES_HERE
#ifndef __GAMEMENU_H__
#define __GAMEMENU_H__

void __cdecl gamemenu_previous();
void __cdecl gamemenu_enable_single();
void __cdecl gamemenu_enable_multi();
void __cdecl gamemenu_off();
void __cdecl gamemenu_handle_previous();
void __cdecl gamemenu_new_game();
void __cdecl gamemenu_quit_game();
void __cdecl gamemenu_load_game();
void __cdecl gamemenu_save_game();
void __cdecl gamemenu_restart_town();
void __cdecl gamemenu_options();
void __cdecl gamemenu_get_music();
void __fastcall gamemenu_sound_music_toggle(char **names, TMenuItem *menu_item, int gamma);
void __cdecl gamemenu_get_sound();
void __cdecl gamemenu_get_color_cycling();
void __cdecl gamemenu_get_gamma();
void __fastcall gamemenu_music_volume(int a1);
int __fastcall gamemenu_slider_music_sound(TMenuItem *menu_item);
void __fastcall gamemenu_sound_volume(int a1);
void __fastcall gamemenu_gamma(int a1);
int __cdecl gamemenu_slider_gamma();
void __cdecl gamemenu_color_cycling();

/* rdata */
extern TMenuItem sgSingleMenu[6];
extern TMenuItem sgMultiMenu[5];
extern TMenuItem sgOptionMenu[6];
extern char *music_toggle_names[];
extern char *sound_toggle_names[];
extern char *color_cycling_toggle_names[];

#endif /* __GAMEMENU_H__ */
//HEADER_GOES_HERE
#ifndef __GENDUNG_H__
#define __GENDUNG_H__

extern short level_frame_types[2048];
extern int themeCount;
extern char nTransTable[2049];
//int dword_52D204;
extern int dMonster[112][112];
extern char dungeon[40][40];
extern char dObject[112][112];
extern void *pSpeedCels;
extern int nlevel_frames; // weak
extern char pdungeon[40][40];
extern char dDead[112][112];
extern short dpiece_defs_map_1[16][112][112];
extern char dTransVal2[112][112];
extern char TransVal; // weak
extern int dword_5A5594;
extern char dflags[40][40];
extern int dPiece[112][112];
extern char dTransVal[112][112];
extern int setloadflag_2; // weak
extern Tile tile_defs[1024];
extern void *pMegaTiles;
extern DPiece dpiece_defs[2];
extern int gnDifficulty; // idb
extern char block_lvid[2049];
//char byte_5B78EB;
extern char dung_map[112][112];
extern char nTrapTable[2049];
extern char leveltype; // weak
extern unsigned char currlevel; // idb
extern char TransList[256];
extern char nSolidTable[2049];
extern int level_frame_count[2049];
extern ScrollStruct ScrollInfo;
extern void *pDungeonCels;
extern int speed_cel_frame_num_from_light_index_frame_num[16][128];
extern THEME_LOC themeLoc[50];
extern char dPlayer[112][112];
extern int dword_5C2FF8; // weak
extern int dword_5C2FFC; // weak
extern int scr_pix_width; // weak
extern int scr_pix_height; // weak
extern char dArch[112][112];
extern char nBlockTable[2049];
extern void *level_special_cel;
extern char dFlags[112][112];
extern char dItem[112][112];
extern char setlvlnum; // weak
extern int level_frame_sizes[2048];
extern char nMissileTable[2049];
extern char *pSetPiece_2;
extern char setlvltype; // weak
extern char setlevel; // weak
extern int LvlViewY; // weak
extern int LvlViewX; // weak
extern int dmaxx; // weak
extern int dmaxy; // weak
extern int setpc_h; // weak
extern int setpc_w; // weak
extern int setpc_x; // idb
extern int ViewX; // idb
extern int ViewY; // idb
extern int setpc_y; // idb
extern char dMissile[112][112];
extern int dminx; // weak
extern int dminy; // weak
extern short dpiece_defs_map_2[16][112][112];

void __cdecl FillSolidBlockTbls();
void __cdecl gendung_418D91();
void __fastcall gendung_4191BF(int frames);
void __fastcall gendung_4191FB(int a1, int a2);
int __fastcall gendung_get_dpiece_num_from_coord(int x, int y);
void __cdecl gendung_4192C2();
void __cdecl SetDungeonMicros();
void __cdecl DRLG_InitTrans();
void __fastcall DRLG_MRectTrans(int x1, int y1, int x2, int y2);
void __fastcall DRLG_RectTrans(int x1, int y1, int x2, int y2);
void __fastcall DRLG_CopyTrans(int sx, int sy, int dx, int dy);
void __fastcall DRLG_ListTrans(int num, unsigned char *List);
void __fastcall DRLG_AreaTrans(int num, unsigned char *List);
void __cdecl DRLG_InitSetPC();
void __cdecl DRLG_SetPC();
void __fastcall Make_SetPC(int x, int y, int w, int h);
bool __fastcall DRLG_WillThemeRoomFit(int floor, int x, int y, int minSize, int maxSize, int *width, int *height);
void __fastcall DRLG_CreateThemeRoom(int themeIndex);
void __fastcall DRLG_PlaceThemeRooms(int minSize, int maxSize, int floor, int freq, int rndSize);
void __cdecl DRLG_HoldThemeRooms();
bool __fastcall SkipThemeRoom(int x, int y);
void __cdecl InitLevels();

#endif /* __GENDUNG_H__ */
//HEADER_GOES_HERE
#ifndef __GMENU_H__
#define __GMENU_H__

extern void *optbar_cel;
extern bool byte_634464; // weak
extern void *PentSpin_cel;
extern TMenuItem *sgpCurrItem;
extern void *BigTGold_cel;
extern int dword_634474; // weak
extern char byte_634478; // weak
extern void (__cdecl *dword_63447C)();
extern TMenuItem *dword_634480; // idb
extern void *option_cel;
extern void *sgpLogo;
extern int dword_63448C; // weak

void __cdecl gmenu_draw_pause();
void __fastcall gmenu_print_text(int x, int y, char *pszStr);
void __cdecl FreeGMenu();
void __cdecl gmenu_init_menu();
bool __cdecl gmenu_exception();
void __fastcall gmenu_call_proc(TMenuItem *pItem, void (__cdecl *gmFunc)());
void __fastcall gmenu_up_down(int a1);
void __cdecl gmenu_draw();
void __fastcall gmenu_draw_menu_item(TMenuItem *pItem, int a2);
void __fastcall gmenu_clear_buffer(int x, int y, int width, int height);
int __fastcall gmenu_get_lfont(TMenuItem *pItem);
int __fastcall gmenu_presskeys(int a1);
void __fastcall gmenu_left_right(int a1);
int __fastcall gmenu_on_mouse_move(LPARAM lParam);
bool __fastcall gmenu_valid_mouse_pos(int *plOffset);
int __fastcall gmenu_left_mouse(int a1);
void __fastcall gmenu_enable(TMenuItem *pMenuItem, bool enable);
void __fastcall gmenu_slider_1(TMenuItem *pItem, int min, int max, int gamma);
int __fastcall gmenu_slider_get(TMenuItem *pItem, int min, int max);
void __fastcall gmenu_slider_3(TMenuItem *pItem, int dwTicks);

/* data */

extern unsigned char lfontframe[127];
extern unsigned char lfontkern[56];

#endif /* __GMENU_H__ */
//HEADER_GOES_HERE
#ifndef __HELP_H__
#define __HELP_H__

extern int help_select_line; // weak
extern int dword_634494; // weak
extern int helpflag;
extern int displayinghelp[22];
extern int HelpTop; // weak

void __cdecl InitHelp();
void __cdecl DrawHelp();
void __fastcall DrawHelpLine(int always_0, int help_line_nr, char *text, text_color color);
void __cdecl DisplayHelp();
void __cdecl HelpScrollUp();
void __cdecl HelpScrollDown();

/* data */
extern char gszHelpText[];

#endif /* __HELP_H__ */
//HEADER_GOES_HERE
#ifndef __INIT_H__
#define __INIT_H__

extern _SNETVERSIONDATA fileinfo;
extern int init_cpp_init_value; // weak
extern int window_activated; // weak
extern char diablo_exe_path[260];
extern void *unused_mpq;
extern char patch_rt_mpq_path[260];
extern LRESULT (__stdcall *CurrentProc)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern void *diabdat_mpq;
extern char diabdat_mpq_path[260];
extern void *patch_rt_mpq;
extern int killed_mom_parent; // weak
extern bool screensaver_enabled_prev;

void __cdecl init_cpp_init();
void __fastcall init_cleanup(bool show_cursor);
void __cdecl init_run_office_from_start_menu();
void __fastcall init_run_office(char *dir);
void __fastcall init_disable_screensaver(bool disable);
void __cdecl init_create_window();
void __cdecl init_kill_mom_parent();
HWND __cdecl init_find_mom_parent();
void __cdecl init_await_mom_parent_exit();
void __cdecl init_archives();
void *__fastcall init_test_access(char *mpq_path, char *mpq_name, char *reg_loc, int flags, bool on_cd);
char *__fastcall init_strip_trailing_slash(char *path);
int __fastcall init_read_test_file(char *mpq_path, char *mpq_name, int flags, void **archive);
void __cdecl init_get_file_info();
LRESULT __stdcall init_palette(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
void __fastcall init_activate_window(HWND hWnd, bool activated);
LRESULT __stdcall init_redraw_window(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT (__stdcall *SetWindowProc(void *func))(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/* data */
extern int init_inf; // weak

/* rdata */

extern char gszVersionNumber[260];
extern char gszProductName[260];

#endif /* __INIT_H__ */
//HEADER_GOES_HERE
#ifndef __INTERFAC_H__
#define __INTERFAC_H__

extern void *sgpBackCel;
extern float interfac_cpp_init_value;
extern int sgdwProgress;
extern int progress_id; // idb

void __cdecl interfac_cpp_init();
void __cdecl interface_msg_pump();
bool __cdecl IncProgress();
void __cdecl DrawCutscene();
void __fastcall DrawProgress(int screen_x, int screen_y, int progress_id);
void __fastcall ShowProgress(int uMsg);
void __cdecl FreeInterface();
void __fastcall InitCutscene(int interface_mode);

/* data */

extern int interfac_inf; // weak
extern unsigned char progress_bar_colours[3];
extern POINT32 progress_bar_screen_pos[3];

#endif /* __INTERFAC_H__ */
//HEADER_GOES_HERE
#ifndef __INV_H__
#define __INV_H__

extern int invflag;
extern void *pInvCels;
extern int drawsbarflag; // idb
extern int sgdwLastTime; // check name

void __cdecl FreeInvGFX();
void __cdecl InitInv();
void __fastcall InvDrawSlotBack(int X, int Y, int W, int H);
void __cdecl DrawInv();
void __cdecl DrawInvBelt();
int __fastcall AutoPlace(int pnum, int ii, int sx, int sy, int saveflag);
int __fastcall SpecialAutoPlace(int pnum, int ii, int sx, int sy, int saveflag);
int __fastcall GoldAutoPlace(int pnum);
int __fastcall WeaponAutoPlace(int pnum);
int __fastcall SwapItem(ItemStruct *a, ItemStruct *b);
void __fastcall CheckInvPaste(int pnum, int mx, int my);
void __fastcall CheckInvSwap(int pnum, int bLoc, int idx, int wCI, int seed, int bId);
void __fastcall CheckInvCut(int pnum, int mx, int my);
void __fastcall inv_update_rem_item(int pnum, int iv);
void __fastcall RemoveInvItem(int pnum, int iv);
void __fastcall RemoveSpdBarItem(int pnum, int iv);
void __cdecl CheckInvItem();
void __cdecl CheckInvScrn();
void __fastcall CheckItemStats(int pnum);
void __fastcall CheckBookLevel(int pnum);
void __fastcall CheckQuestItem(int pnum);
void __fastcall InvGetItem(int pnum, int ii);
void __fastcall AutoGetItem(int pnum, int ii);
int __fastcall FindGetItem(int indx, unsigned short ci, int iseed);
void __fastcall SyncGetItem(int x, int y, int idx, unsigned short ci, int iseed);
int __fastcall CanPut(int i, int j);
int __cdecl TryInvPut();
void __fastcall DrawInvMsg(char *msg);
int __fastcall InvPutItem(int pnum, int x, int y);
int __fastcall SyncPutItem(int pnum, int x, int y, int idx, int icreateinfo, int iseed, int Id, int dur, int mdur, int ch, int mch, int ivalue, unsigned int ibuff);
int __cdecl CheckInvHLight();
void __fastcall RemoveScroll(int pnum);
bool __cdecl UseScroll();
void __fastcall UseStaffCharge(int pnum);
bool __cdecl UseStaff();
void __cdecl StartGoldDrop();
int __fastcall UseInvItem(int pnum, int cii);
void __cdecl DoTelekinesis();
int __fastcall CalculateGold(int pnum);
int __cdecl DropItemBeforeTrig();

/* data */

extern InvXY InvRect[73];

/* rdata */

extern int AP2x2Tbl[10]; // weak

#endif /* __INV_H__ */
//HEADER_GOES_HERE
#ifndef __ITEMS_H__
#define __ITEMS_H__

extern int itemactive[127];
extern int uitemflag;
extern int itemavail[127];
extern ItemStruct curruitem;
extern ItemGetRecordStruct itemrecord[127];
extern ItemStruct item[128];
extern char itemhold[3][3];
extern char byte_641234[28]; /* check if part of above */
extern int Item2Frm[35];
extern int UniqueItemFlag[128];
extern int numitems;
extern int gnNumGetRecords;

void __cdecl InitItemGFX();
bool __fastcall ItemPlace(int x, int y);
void __cdecl AddInitItems();
void __cdecl InitItems();
void __fastcall CalcPlrItemVals(int p, bool Loadgfx);
void __fastcall CalcPlrScrolls(int p);
void __fastcall CalcPlrStaff(int pnum);
void __fastcall CalcSelfItems(int pnum);
void __fastcall CalcPlrItemMin(int pnum);
bool __fastcall ItemMinStats(PlayerStruct *p, ItemStruct *x);
void __fastcall CalcPlrBookVals(int p);
void __fastcall CalcPlrInv(int p, bool Loadgfx);
void __fastcall SetPlrHandItem(ItemStruct *h, int idata);
void __fastcall GetPlrHandSeed(ItemStruct *h);
void __fastcall GetGoldSeed(int pnum, ItemStruct *h);
void __fastcall SetPlrHandSeed(ItemStruct *h, int iseed);
void __fastcall SetPlrHandGoldCurs(ItemStruct *h);
void __fastcall CreatePlrItems(int p);
bool __fastcall ItemSpaceOk(int i, int j);
bool __fastcall GetItemSpace(int x, int y, char inum);
void __fastcall GetSuperItemSpace(int x, int y, char inum);
void __fastcall GetSuperItemLoc(int x, int y, int *xx, int *yy);
void __fastcall CalcItemValue(int i);
void __fastcall GetBookSpell(int i, int lvl);
void __fastcall GetStaffPower(int i, int lvl, int bs, unsigned char onlygood);
void __fastcall GetStaffSpell(int i, int lvl, unsigned char onlygood);
void __fastcall GetItemAttrs(int i, int idata, int lvl);
int __fastcall RndPL(int param1, int param2);
int __fastcall PLVal(int pv, int p1, int p2, int minv, int maxv);
void __fastcall SaveItemPower(int i, int power, int param1, int param2, int minval, int maxval, int multval);
void __fastcall GetItemPower(int i, int minlvl, int maxlvl, int flgs, int onlygood);
void __fastcall GetItemBonus(int i, int idata, int minlvl, int maxlvl, int onlygood);
void __fastcall SetupItem(int i);
int __fastcall RndItem(int m);
int __fastcall RndUItem(int m);
int __cdecl RndAllItems();
int __fastcall RndTypeItems(int itype, int imid);
int __fastcall CheckUnique(int i, int lvl, int uper, bool recreate);
void __fastcall GetUniqueItem(int i, int uid);
void __fastcall SpawnUnique(int uid, int x, int y);
void __fastcall ItemRndDur(int ii);
void __fastcall SetupAllItems(int ii, int idx, int iseed, int lvl, int uper, int onlygood, int recreate, int pregen);
void __fastcall SpawnItem(int m, int x, int y, unsigned char sendmsg);
void __fastcall CreateItem(int uid, int x, int y);
void __fastcall CreateRndItem(int x, int y, unsigned char onlygood, unsigned char sendmsg, int delta);
void __fastcall SetupAllUseful(int ii, int iseed, int lvl);
void __fastcall CreateRndUseful(int pnum, int x, int y, unsigned char sendmsg);
void __fastcall CreateTypeItem(int x, int y, unsigned char onlygood, int itype, int imisc, int sendmsg, int delta);
void __fastcall RecreateItem(int ii, int idx, unsigned short ic, int iseed, int ivalue);
void __fastcall RecreateEar(int ii, unsigned short ic, int iseed, unsigned char Id, int dur, int mdur, int ch, int mch, int ivalue, int ibuff);
void __fastcall SpawnQuestItem(int itemid, int x, int y, int randarea, int selflag);
void __cdecl SpawnRock();
void __fastcall RespawnItem(int i, bool FlipFlag);
void __fastcall DeleteItem(int ii, int i);
void __cdecl ItemDoppel();
void __cdecl ProcessItems();
void __cdecl FreeItemGFX();
void __fastcall GetItemFrm(int i);
void __fastcall GetItemStr(int i);
void __fastcall CheckIdentify(int pnum, int cii);
void __fastcall DoRepair(int pnum, int cii);
void __fastcall RepairItem(ItemStruct *i, int lvl);
void __fastcall DoRecharge(int pnum, int cii);
void __fastcall RechargeItem(ItemStruct *i, int r);
void __fastcall PrintItemOil(char IDidx);
void __fastcall PrintItemPower(char plidx, ItemStruct *x);
void __cdecl DrawUBack();
void __fastcall PrintUString(int x, int y, int cjustflag, char *str, int col);
void __fastcall DrawULine(int y);
void __cdecl DrawUniqueInfo();
void __fastcall PrintItemMisc(ItemStruct *x);
void __fastcall PrintItemDetails(ItemStruct *x);
void __fastcall PrintItemDur(ItemStruct *x);
void __fastcall UseItem(int p, int Mid, int spl);
bool __fastcall StoreStatOk(ItemStruct *h);
bool __fastcall SmithItemOk(int i);
int __fastcall RndSmithItem(int lvl);
void __fastcall BubbleSwapItem(ItemStruct *a, ItemStruct *b);
void __cdecl SortSmith();
void __fastcall SpawnSmith(int lvl);
bool __fastcall PremiumItemOk(int i);
int __fastcall RndPremiumItem(int minlvl, int maxlvl);
void __fastcall SpawnOnePremium(int i, int plvl);
void __fastcall SpawnPremium(int lvl);
bool __fastcall WitchItemOk(int i);
int __fastcall RndWitchItem(int lvl);
void __cdecl SortWitch();
void __fastcall WitchBookLevel(int ii);
void __fastcall SpawnWitch(int lvl);
int __fastcall RndBoyItem(int lvl);
void __fastcall SpawnBoy(int lvl);
bool __fastcall HealerItemOk(int i);
int __fastcall RndHealerItem(int lvl);
void __cdecl SortHealer();
void __fastcall SpawnHealer(int lvl);
void __cdecl SpawnStoreGold();
void __fastcall RecreateSmithItem(int ii, int idx, int plvl, int iseed);
void __fastcall RecreatePremiumItem(int ii, int idx, int lvl, int iseed);
void __fastcall RecreateBoyItem(int ii, int idx, int lvl, int iseed);
void __fastcall RecreateWitchItem(int ii, int idx, int lvl, int iseed);
void __fastcall RecreateHealerItem(int ii, int idx, int lvl, int iseed);
void __fastcall RecreateTownItem(int ii, int idx, unsigned short icreateinfo, int iseed, int ivalue);
void __cdecl RecalcStoreStats();
int __cdecl ItemNoFlippy();
void __fastcall CreateSpellBook(int x, int y, int ispell, bool sendmsg, int delta);
void __fastcall CreateMagicItem(int x, int y, int imisc, int icurs, int sendmsg, int delta);
bool __fastcall GetItemRecord(int dwSeed, int CI, int indx);
void __fastcall NextItemRecord(int i);
void __fastcall SetItemRecord(int dwSeed, int CI, int indx);
void __fastcall PutItemRecord(int seed, int ci, int index);

/* data */

extern PLStruct PL_Prefix[84];
extern PLStruct PL_Suffix[96];
extern UItemStruct UniqueItemList[91];

/* rdata */


extern ItemDataStruct AllItemsList[157];
extern unsigned char ItemCAnimTbl[169];
extern char *ItemDropStrs[35];
extern unsigned char ItemAnimLs[35];
extern int ItemDropSnds[35];
extern int ItemInvSnds[35];
extern int idoppely; // weak
extern int premiumlvladd[6];

#endif /* __ITEMS_H__ */
//HEADER_GOES_HERE
#ifndef __LIGHTING_H__
#define __LIGHTING_H__

extern LightListStruct VisionList[32];
extern char lightactive[32];
extern LightListStruct LightList[32];
extern int numlights;
extern char dung_map_radius[2048]; /* char [16][128] */
extern int dovision; // weak
extern int numvision;
extern char lightmax; // weak
extern int dolighting; // weak
extern char dung_map_rgba[16384]; /* int [64][64] short [64][128] char [64][256] */
extern int visionid;
extern char *pLightTbl; /* todo: struct? */
extern int lightflag; // weak

void __fastcall SetLightFX(int *x, int *y, short *s_r, short *s_g, int *s_b, int *d_r, int *d_g, int *d_b);
void __fastcall DoLighting(int nXPos, int nYPos, int nRadius, int Lnum);
void __fastcall DoUnLight(int nXPos, int nYPos, int nRadius);
void __fastcall DoUnVision(int nXPos, int nYPos, int nRadius);
void __fastcall DoVision(int nXPos, int nYPos, int nRadius, unsigned char doautomap, int visible);
void __cdecl FreeLightTable();
void __cdecl InitLightTable();
void __cdecl MakeLightTable();
void __cdecl InitLightMax();
void __cdecl InitLighting();
int __fastcall AddLight(int x, int y, int r);
void __fastcall AddUnLight(int i);
void __fastcall ChangeLightRadius(int i, int r);
void __fastcall ChangeLightXY(int i, int x, int y);
void __fastcall ChangeLightOff(int i, int x, int y);
void __fastcall ChangeLight(int i, int x, int y, int r);
void __cdecl ProcessLightList();
void __cdecl SavePreLighting();
void __cdecl InitVision();
int __fastcall AddVision(int x, int y, int r, bool mine);
void __fastcall ChangeVisionRadius(int id, int r);
void __fastcall ChangeVisionXY(int id, int x, int y);
void __cdecl ProcessVisionList();
void __cdecl lighting_color_cycling();

/* rdata */

extern CircleCoord CrawlTable;
extern void *pCrawlTable[19];
extern unsigned char vCrawlTable[23][30];
extern unsigned char byte_49463C[18][18];
extern unsigned char RadiusAdj[23];

#endif /* __LIGHTING_H__ */
//HEADER_GOES_HERE
#ifndef __LOADSAVE_H__
#define __LOADSAVE_H__

extern void *tbuff;

void __fastcall LoadGame(bool firstflag);
char __cdecl BLoad();
int __cdecl ILoad();
int __cdecl ILoad_2();
bool __cdecl OLoad();
void __fastcall LoadPlayer(int i);
void __fastcall LoadMonster(int i);
void __fastcall LoadMissile(int i);
void __fastcall LoadObject(int i);
void __fastcall LoadItem(int i);
void __fastcall LoadPremium(int i);
void __fastcall LoadQuest(int i);
void __fastcall LoadLighting(int i);
void __fastcall LoadVision(int i);
void __fastcall LoadPortal(int i);
void __cdecl SaveGame();
void __fastcall BSave(char v);
void __fastcall ISave(int v);
void __fastcall ISave_2(int v);
void __fastcall OSave(unsigned char v);
void __fastcall SavePlayer(int i);
void __fastcall SaveMonster(int i);
void __fastcall SaveMissile(int i);
void __fastcall SaveObject(int i);
void __fastcall SaveItem(int i);
void __fastcall SavePremium(int i);
void __fastcall SaveQuest(int i);
void __fastcall SaveLighting(int i);
void __fastcall SaveVision(int i);
void __fastcall SavePortal(int i);
void __cdecl SaveLevel();
void __cdecl LoadLevel();

#endif /* __LOADSAVE_H__ */
//HEADER_GOES_HERE
#ifndef __LOGGING_H__
#define __LOGGING_H__

extern int log_cpp_init_value; // weak
extern CHAR FileName[260]; // idb
extern char log_buffer[388];
extern LPCVOID lpAddress; // idb
extern DWORD nNumberOfBytesToWrite; // idb

void __cdecl log_cpp_init_1();
void __cdecl log_cpp_init_2();
void __cdecl log_init_mutex();
void __cdecl j_log_cleanup_mutex();
void __cdecl log_cleanup_mutex();
void __cdecl log_flush(bool force_close);
void *__cdecl log_create(); // should be HANDLE
void __fastcall log_get_version(VS_FIXEDFILEINFO *file_info);
void log_printf(char *pszFmt, ...); // LogMessage
void __cdecl log_dump_computer_info();

/* data */

extern int log_inf; // weak

/* rdata */

extern int log_not_created; // weak
extern HANDLE log_file; // idb

#endif /* __LOGGING_H__ */
//HEADER_GOES_HERE
#ifndef __MAINMENU_H__
#define __MAINMENU_H__

extern int mainmenu_cpp_init_value; // weak
extern char chr_name_str[16];

void __cdecl mainmenu_cpp_init();
void __cdecl mainmenu_refresh_music();
void __stdcall mainmenu_create_hero(char *, char *);
int __stdcall mainmenu_select_hero_dialog(int u1, int u2, int u3, int u4, int mode, char *cname, int clen, char *cdesc, int cdlen, int *multi);
void __fastcall mainmenu_action(int option);
int __cdecl mainmenu_single_player();
int __fastcall mainmenu_init_menu(int a1);
int __cdecl mainmenu_multi_player();
void __cdecl mainmenu_play_intro();

/* data */

extern int mainmenu_inf; // weak

/* rdata */

extern int menu_music_track_id; // idb

#endif /* __MAINMENU_H__ */
//HEADER_GOES_HERE
#ifndef __MINITEXT_H__
#define __MINITEXT_H__

extern int qtexty; // weak
extern char *qtextptr;
extern int qtextSpd; // weak
extern char qtextflag; // weak
extern int scrolltexty; // weak
extern int sgLastScroll; // weak
extern void *pMedTextCels;
extern void *pTextBoxCels;

void __cdecl FreeQuestText();
void __cdecl InitQuestText();
void __fastcall InitQTextMsg(int m);
void __cdecl DrawQTextBack();
void __fastcall PrintQTextChr(int screen_x, int screen_y, char *cel_buf, int frame);
void __cdecl DrawQText();

/* data */

extern unsigned char mfontframe[127];
extern unsigned char mfontkern[56];

/* rdata */

extern int qscroll_spd_tbl[9];

#endif /* __MINITEXT_H__ */
//HEADER_GOES_HERE
#ifndef __MISSILES_H__
#define __MISSILES_H__

extern int missileactive[125];
extern int missileavail[125];
extern MissileStruct missile[125];
extern int nummissiles; // idb
extern int ManashieldFlag;
extern unk_missile_struct misflagstruct_unknown[125];
extern int MissilePreFlag; // weak
// int END_unkmis_126; // weak

void __fastcall GetDamageAmt(int i, int *mind, int *maxd);
int __fastcall CheckBlock(int fx, int fy, int tx, int ty);
int __fastcall FindClosest(int sx, int sy, int rad);
int __fastcall GetSpellLevel(int id, int sn);
int __fastcall GetDirection8(int x1, int y1, int x2, int y2);
int __fastcall GetDirection16(int x1, int y1, int x2, int y2);
void __fastcall DeleteMissile(int mi, int i);
void __fastcall GetMissileVel(int i, int sx, int sy, int dx, int dy, int v);
void __fastcall PutMissile(int i);
void __fastcall GetMissilePos(int i);
void __fastcall MoveMissilePos(int i);
bool __fastcall MonsterTrapHit(int m, int mindam, int maxdam, int dist, int t, int shift);
bool __fastcall MonsterMHit(int pnum, int m, int mindam, int maxdam, int dist, int t, int shift);
bool __fastcall PlayerMHit(int pnum, int m, int dist, int mind, int maxd, int mtype, int shift, int earflag);
bool __fastcall Plr2PlrMHit(int pnum, int p, int mindam, int maxdam, int dist, int mtype, int shift);
void __fastcall CheckMissileCol(int i, int mindam, int maxdam, bool shift, int mx, int my, int nodel);
void __fastcall SetMissAnim(int mi, int animtype);
void __fastcall SetMissDir(int mi, int dir);
void __fastcall LoadMissileGFX(int mi);
void __cdecl InitMissileGFX();
void __fastcall FreeMissileGFX(int mi);
void __cdecl FreeMissiles();
void __cdecl FreeMissiles2();
void __cdecl InitMissiles();
void __fastcall AddLArrow(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddArrow(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall GetVileMissPos(int mi, int dx, int dy);
void __fastcall AddRndTeleport(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFirebolt(int mi, int sx, int sy, int dx, int dy, int midir, int micaster, int id, int dam);
void __fastcall AddMagmaball(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_33(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddTeleport(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddLightball(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFirewall(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFireball(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddLightctrl(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddLightning(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddMisexp(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddWeapexp(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
bool __fastcall CheckIfTrig(int x, int y);
void __fastcall AddTown(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFlash(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFlash2(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddManashield(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFiremove(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddGuardian(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddChain(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_11(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_12(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_13(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddRhino(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_32(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFlare(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddAcid(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_1D(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddAcidpud(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddStone(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddGolem(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddEtherealize(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_1F(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall miss_null_23(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddBoom(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddHeal(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddHealOther(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddElement(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddIdentify(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFirewallC(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddInfra(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddWave(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddNova(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddRepair(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddRecharge(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddDisarm(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddApoca(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFlame(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddFlamec(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddCbolt(int mi, int sx, int sy, int dx, int dy, int midir, int micaster, int id, int dam);
void __fastcall AddHbolt(int mi, int sx, int sy, int dx, int dy, int midir, int micaster, int id, int dam);
void __fastcall AddResurrect(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddResurrectBeam(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddTelekinesis(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddBoneSpirit(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddRportal(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
void __fastcall AddDiabApoca(int mi, int sx, int sy, int dx, int dy, int midir, int mienemy, int id, int dam);
int __fastcall AddMissile(int sx, int sy, int v1, int v2, int midir, int mitype, int micaster, int id, int v3, int spllvl);
int __fastcall Sentfire(int i, int sx, int sy);
void __fastcall MI_Dummy(int i);
void __fastcall MI_Golem(int i);
void __fastcall MI_SetManashield(int i);
void __fastcall MI_LArrow(int i);
void __fastcall MI_Arrow(int i);
void __fastcall MI_Firebolt(int i);
void __fastcall MI_Lightball(int i);
void __fastcall mi_null_33(int i);
void __fastcall MI_Acidpud(int i);
void __fastcall MI_Firewall(int i);
void __fastcall MI_Fireball(int i);
void __fastcall MI_Lightctrl(int i);
void __fastcall MI_Lightning(int i);
void __fastcall MI_Town(int i);
void __fastcall MI_Flash(int i);
void __fastcall MI_Flash2(int i);
void __fastcall MI_Manashield(int i);
void __fastcall MI_Etherealize(int i);
void __fastcall MI_Firemove(int i);
void __fastcall MI_Guardian(int i);
void __fastcall MI_Chain(int i);
void __fastcall mi_null_11(int i);
void __fastcall MI_Weapexp(int i);
void __fastcall MI_Misexp(int i);
void __fastcall MI_Acidsplat(int i);
void __fastcall MI_Teleport(int i);
void __fastcall MI_Stone(int i);
void __fastcall MI_Boom(int i);
void __fastcall MI_Rhino(int i);
void __fastcall mi_null_32(int i);
void __fastcall MI_FirewallC(int i);
void __fastcall MI_Infra(int i);
void __fastcall MI_Apoca(int i);
void __fastcall MI_Wave(int i);
void __fastcall MI_Nova(int i);
void __fastcall MI_Blodboil(int i);
void __fastcall MI_Flame(int i);
void __fastcall MI_Flamec(int i);
void __fastcall MI_Cbolt(int i);
void __fastcall MI_Hbolt(int i);
void __fastcall MI_Element(int i);
void __fastcall MI_Bonespirit(int i);
void __fastcall MI_ResurrectBeam(int i);
void __fastcall MI_Rportal(int i);
void __cdecl ProcessMissiles();
void __cdecl missiles_process_charge();
void __fastcall ClearMissileSpot(int mi);

/* rdata */

extern MissileData missiledata[68];
extern MisFileData misfiledata[47];
extern int XDirAdd[8];
extern int YDirAdd[8];

#endif /* __MISSILES_H__ */
//HEADER_GOES_HERE
#ifndef __MONSTER_H__
#define __MONSTER_H__

extern int MissileFileFlag; // weak
extern int monster_cpp_init_value; // weak
extern int monstkills[200];
extern int monstactive[200];
extern int nummonsters;
extern int sgbSaveSoundOn; // weak
extern MonsterStruct monster[200];
extern int totalmonsters; // weak
extern CMonster Monsters[16];
// int END_Monsters_17; // weak
extern int monstimgtot; // weak
extern int uniquetrans;
extern int nummtypes;

void __cdecl monster_cpp_init();
void __fastcall InitMonsterTRN(int monst, int special);
void __cdecl InitLevelMonsters();
int __fastcall AddMonsterType(int type, int placeflag);
void __cdecl GetLevelMTypes();
void __fastcall InitMonsterGFX(int monst);
void __fastcall ClearMVars(int i);
void __fastcall InitMonster(int i, int rd, int mtype, int x, int y);
void __cdecl ClrAllMonsters();
bool __fastcall MonstPlace(int xp, int yp);
void __fastcall PlaceMonster(int i, int mtype, int x, int y);
void __fastcall PlaceUniqueMonst(int uniqindex, int miniontype, int unpackfilesize);
void __cdecl PlaceQuestMonsters();
void __fastcall PlaceGroup(int mtype, int num, unsigned char leaderf, int leader);
void __cdecl LoadDiabMonsts();
void __cdecl InitMonsters();
void __cdecl PlaceUniques();
void __fastcall SetMapMonsters(char *pMap, int startx, int starty);
void __fastcall DeleteMonster(int i);
int __fastcall AddMonster(int x, int y, int dir, int mtype, int InMap);
void __fastcall NewMonsterAnim(int i, AnimStruct *anim, int md);
bool __fastcall M_Ranged(int i);
bool __fastcall M_Talker(int i);
void __fastcall M_Enemy(int i);
int __fastcall M_GetDir(int i);
void __fastcall M_CheckEFlag(int i);
void __fastcall M_StartStand(int i, int md);
void __fastcall M_StartDelay(int i, int len);
void __fastcall M_StartSpStand(int i, int md);
void __fastcall M_StartWalk(int i, int xvel, int yvel, int xadd, int yadd, int EndDir);
void __fastcall M_StartWalk2(int i, int xvel, int yvel, int a4, int a5, int a6, int a7, int EndDir);
void __fastcall M_StartWalk3(int i, int xvel, int yvel, int a4, int a5, int a6, int a7, int a8, int a9, int EndDir);
void __fastcall M_StartAttack(int i);
void __fastcall M_StartRAttack(int i, int missile_type, int dam);
void __fastcall M_StartRSpAttack(int i, int missile_type, int dam);
void __fastcall M_StartSpAttack(int i);
void __fastcall M_StartEat(int i);
void __fastcall M_ClearSquares(int i);
void __fastcall M_GetKnockback(int i);
void __fastcall M_StartHit(int i, int pnum, int dam);
void __fastcall M_DiabloDeath(int i, unsigned char sendmsg);
void __fastcall M2MStartHit(int mid, int i, int dam);
void __fastcall MonstStartKill(int i, int pnum, unsigned char sendmsg);
void __fastcall M2MStartKill(int i, int mid);
void __fastcall M_StartKill(int i, int pnum);
void __fastcall M_SyncStartKill(int i, int x, int y, int pnum);
void __fastcall M_StartFadein(int i, int md, unsigned char backwards);
void __fastcall M_StartFadeout(int i, int md, unsigned char backwards);
void __fastcall M_StartHeal(int i);
void __fastcall M_ChangeLightOffset(int monst);
int __fastcall M_DoStand(int i);
int __fastcall M_DoWalk(int i);
int __fastcall M_DoWalk2(int i);
int __fastcall M_DoWalk3(int i);
void __fastcall M_TryM2MHit(int i, int mid, int hper, int mind, int maxd);
void __fastcall M_TryH2HHit(int i, int pnum, int Hit, int MinDam, int MaxDam);
int __fastcall M_DoAttack(int i);
int __fastcall M_DoRAttack(int i);
int __fastcall M_DoRSpAttack(int i);
int __fastcall M_DoSAttack(int i);
int __fastcall M_DoFadein(int i);
int __fastcall M_DoFadeout(int i);
int __fastcall M_DoHeal(int i);
int __fastcall M_DoTalk(int i);
void __fastcall M_Teleport(int i);
int __fastcall M_DoGotHit(int i);
void __fastcall M_UpdateLeader(int i);
void __cdecl DoEnding();
void __cdecl PrepDoEnding();
int __fastcall M_DoDeath(int i);
int __fastcall M_DoSpStand(int i);
int __fastcall M_DoDelay(int i);
int __fastcall M_DoStone(int i);
void __fastcall M_WalkDir(int i, int md);
void __fastcall GroupUnity(int i);
bool __fastcall M_CallWalk(int i, int md);
bool __fastcall M_PathWalk(int i);
bool __fastcall M_CallWalk2(int i, int md);
bool __fastcall M_DumbWalk(int i, int md);
bool __fastcall M_RoundWalk(int i, int md, int *dir);
void __fastcall MAI_Zombie(int i);
void __fastcall MAI_SkelSd(int i);
bool __fastcall MAI_Path(int i);
void __fastcall MAI_Snake(int i);
void __fastcall MAI_Bat(int i);
void __fastcall MAI_SkelBow(int i);
void __fastcall MAI_Fat(int i);
void __fastcall MAI_Sneak(int i);
void __fastcall MAI_Fireman(int i);
void __fastcall MAI_Fallen(int i);
void __fastcall MAI_Cleaver(int i);
void __fastcall MAI_Round(int i, unsigned char special);
void __fastcall MAI_GoatMc(int i);
void __fastcall MAI_Ranged(int i, int missile_type, unsigned char special);
void __fastcall MAI_GoatBow(int i);
void __fastcall MAI_Succ(int i);
void __fastcall MAI_AcidUniq(int i);
void __fastcall MAI_Scav(int i);
void __fastcall MAI_Garg(int i);
void __fastcall MAI_RoundRanged(int i, int missile_type, unsigned char checkdoors, int dam, int lessmissiles);
void __fastcall MAI_Magma(int i);
void __fastcall MAI_Storm(int i);
void __fastcall MAI_Acid(int i);
void __fastcall MAI_Diablo(int i);
void __fastcall MAI_RR2(int i, int mistype, int dam);
void __fastcall MAI_Mega(int i);
void __fastcall MAI_Golum(int i);
void __fastcall MAI_SkelKing(int i);
void __fastcall MAI_Rhino(int i);
void __fastcall MAI_Counselor(int i);
void __fastcall MAI_Garbud(int i);
void __fastcall MAI_Zhar(int i);
void __fastcall MAI_SnotSpil(int i);
void __fastcall MAI_Lazurus(int i);
void __fastcall MAI_Lazhelp(int i);
void __fastcall MAI_Lachdanan(int i);
void __fastcall MAI_Warlord(int i);
void __cdecl DeleteMonsterList();
void __cdecl ProcessMonsters();
void __cdecl FreeMonsters();
bool __fastcall DirOK(int i, int mdir);
bool __fastcall PosOkMissile(int x, int y);
bool __fastcall CheckNoSolid(int x, int y);
bool __fastcall LineClearF(bool (__fastcall *Clear)(int, int), int x1, int y1, int x2, int y2);
bool __fastcall LineClear(int x1, int y1, int x2, int y2);
bool __fastcall LineClearF1(bool (__fastcall *Clear)(int, int, int), int monst, int x1, int y1, int x2, int y2);
void __fastcall SyncMonsterAnim(int i);
void __fastcall M_FallenFear(int x, int y);
void __fastcall PrintMonstHistory(int mt);
void __cdecl PrintUniqueHistory();
void __fastcall MissToMonst(int i, int x, int y);
bool __fastcall PosOkMonst(int i, int x, int y);
bool __fastcall PosOkMonst2(int i, int x, int y);
bool __fastcall PosOkMonst3(int i, int x, int y);
bool __fastcall IsSkel(int mt);
bool __fastcall IsGoat(int mt);
int __fastcall M_SpawnSkel(int x, int y, int dir);
void __fastcall ActivateSpawn(int i, int x, int y, int dir);
bool __fastcall SpawnSkeleton(int ii, int x, int y);
int __cdecl PreSpawnSkeleton();
void __fastcall TalktoMonster(int i);
void __fastcall SpawnGolum(int i, int x, int y, int mi);
bool __fastcall CanTalkToMonst(int m);
bool __fastcall CheckMonsterHit(int m, bool *ret);
int __fastcall encode_enemy(int m);
void __fastcall decode_enemy(int m, int enemy);

/* data */

extern int monster_inf; // weak
extern char plr2monst[9];
extern unsigned char counsmiss[4];

/* rdata */

extern MonsterData monsterdata[112];
extern char MonstConvTbl[128];
extern unsigned char MonstAvailTbl[112];
extern UniqMonstStruct UniqMonst[98];
extern int MWVel[24][3];
extern char animletter[7];
extern int left[8];
extern int right[8];
extern int opposite[8];
extern int offset_x[8];
extern int offset_y[8];

/* unused */
extern int rnd5[4];
extern int rnd10[4];
extern int rnd20[4];
extern int rnd60[4];
//

extern void (__fastcall *AiProc[])(int i);

#endif /* __MONSTER_H__ */
//HEADER_GOES_HERE
#ifndef __MOVIE_H__
#define __MOVIE_H__

extern int movie_cpp_init_value; // weak
extern char movie_playing; // weak
extern int loop_movie; // weak

void __cdecl movie_cpp_init();
void __fastcall play_movie(char *pszMovie, bool user_can_close);
LRESULT __stdcall MovieWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

/* data */

extern int movie_inf; // weak

#endif /* __MOVIE_H__ */
//HEADER_GOES_HERE
#ifndef __MPQAPI_H__
#define __MPQAPI_H__

extern int mpqapi_cpp_init_value; // weak
extern int sgdwMpqOffset; // idb
extern char mpq_buf[4096];
extern _HASHENTRY *sgpHashTbl;
extern bool save_archive_modified; // weak
extern _BLOCKENTRY *sgpBlockTbl;
extern bool save_archive_open; // weak

void __cdecl mpqapi_cpp_init();
bool __fastcall mpqapi_set_hidden(char *pszArchive, bool hidden);
void __fastcall mpqapi_store_creation_time(char *pszArchive, int dwChar);
bool __fastcall mpqapi_reg_load_modification_time(char *dst, int size);
void __fastcall mpqapi_xor_buf(char *pbData);
bool __fastcall mpqapi_reg_store_modification_time(char *pbData, int dwLen);
_BLOCKENTRY *__fastcall j_mpqapi_remove_hash_entry(char *pszName);
void __fastcall mpqapi_remove_hash_entry(char *pszName);
void __fastcall mpqapi_alloc_block(int block_offset, int block_size);
_BLOCKENTRY *__fastcall mpqapi_new_block(int *block_index);
int __fastcall mpqapi_get_hash_index_of_path(char *pszName);
int __fastcall mpqapi_get_hash_index(short index, int hash_a, int hash_b, int locale);
void __fastcall mpqapi_remove_hash_entries(bool (__stdcall *fnGetName)(int, char *));
bool __fastcall mpqapi_write_file(char *pszName, char *pbData, int dwLen);
_BLOCKENTRY *__fastcall mpqapi_add_file(char *pszName, _BLOCKENTRY *pBlk, int block_index);
bool __fastcall mpqapi_write_file_contents(char *pszName, char *pbData, int dwLen, _BLOCKENTRY *pBlk);
int __fastcall mpqapi_find_free_block(int size, int *block_size);
void __fastcall mpqapi_rename(char *pszOld, char *pszNew);
bool __fastcall mpqapi_has_file(char *pszName);
bool __fastcall mpqapi_open_archive(char *pszArchive, bool hidden, int dwChar);
bool __fastcall mpqapi_parse_archive_header(TMPQHeader *pHdr, int *pdwNextFileStart);
void __fastcall mpqapi_close_archive(char *pszArchive, bool bFree, int dwChar);
void __fastcall mpqapi_store_modified_time(char *pszArchive, int dwChar);
void __fastcall mpqapi_flush_and_close(char *pszArchive, bool bFree, int dwChar);
bool __cdecl mpqapi_write_header();
bool __cdecl mpqapi_write_block_table();
bool __cdecl mpqapi_write_hash_table();
bool __cdecl mpqapi_can_seek();

/* data */

extern int mpqapi_inf; // weak

/* rdata */

extern HANDLE sghArchive; // idb

#endif /* __MPQAPI_H__ */
//HEADER_GOES_HERE
#ifndef __MSG_H__
#define __MSG_H__

extern int sgdwOwnerWait; // weak
extern int msg_cpp_init_value; // weak
extern int sgdwRecvOffset; // idb
extern int sgnCurrMegaPlayer; // weak
extern DLevel sgLevels[17];
extern char sbLastCmd; // weak
extern TMegaPkt *sgpCurrPkt;
extern char sgRecvBuf[4722];
extern unsigned char sgbRecvCmd; // idb
extern LocalLevel sgLocals[17];
extern DJunk sgJunk[4];
extern TMegaPkt *sgpMegaPkt;
extern char sgbDeltaChanged; // weak
extern char sgbDeltaChunks; // weak
extern int deltaload; // weak
extern char gbBufferMsgs; // weak
extern int dword_676198; // weak
extern int msg_err_timer; // weak

void __cdecl msg_cpp_init();
void __fastcall msg_send_drop_pkt(int pnum, int reason);
void __fastcall msg_send_packet(int pnum, void *packet, int dwSize);
TMegaPkt *__cdecl msg_get_next_packet();
int __cdecl msg_wait_resync();
void __cdecl msg_free_packets();
int __cdecl msg_wait_for_turns();
void __cdecl msg_process_net_packets();
void __cdecl msg_pre_packet();
void __fastcall DeltaExportData(int pnum);
void *__fastcall DeltaExportItem(void *dst, void *src);
void *__fastcall DeltaExportObject(void *dst, void *src);
void *__fastcall DeltaExportMonster(void *dst, void *src);
char *__fastcall DeltaExportJunk(char *a1);
int __fastcall msg_comp_level(char *buffer, int size);
void __cdecl delta_init();
void __fastcall delta_kill_monster(int mi, unsigned char x, unsigned char y, unsigned char bLevel);
void __fastcall delta_monster_hp(int mi, int hp, unsigned char bLevel);
void __fastcall delta_sync_monster(TCmdLocParam1 *packet, char level);
void __fastcall delta_sync_golem(TCmdGolem *pG, int pnum, int bLevel);
void __fastcall delta_leave_sync(unsigned char bLevel);
bool __fastcall delta_portal_inited(int portal_num);
bool __fastcall delta_quest_inited(int quest_num);
void __fastcall DeltaAddItem(int ii);
void __cdecl DeltaSaveLevel();
void __cdecl DeltaLoadLevel();
void __fastcall NetSendCmd(unsigned char bHiPri, unsigned char bCmd);
void __fastcall NetSendCmdGolem(unsigned char mx, unsigned char my, unsigned char dir, unsigned char menemy, int hp, int cl);
void __fastcall NetSendCmdLoc(unsigned char bHiPri, unsigned char bCmd, unsigned char x, unsigned char y);
void __fastcall NetSendCmdLocParam1(unsigned char bHiPri, unsigned char bCmd, unsigned char x, unsigned char y, int wParam1);
void __fastcall NetSendCmdLocParam2(unsigned char bHiPri, unsigned char bCmd, unsigned char x, unsigned char y, int wParam1, int wParam2);
void __fastcall NetSendCmdLocParam3(unsigned char bHiPri, unsigned char bCmd, unsigned char x, unsigned char y, int wParam1, int wParam2, int wParam3);
void __fastcall NetSendCmdParam1(unsigned char bHiPri, unsigned char bCmd, unsigned short wParam1);
void __fastcall NetSendCmdParam2(unsigned char bHiPri, unsigned char bCmd, unsigned short wParam1, unsigned short wParam2);
void __fastcall NetSendCmdParam3(unsigned char bHiPri, unsigned char bCmd, unsigned short wParam1, unsigned short wParam2, int wParam3);
void __fastcall NetSendCmdQuest(unsigned char bHiPri, unsigned char q);
void __fastcall NetSendCmdGItem(unsigned char bHiPri, unsigned char bCmd, unsigned char mast, unsigned char pnum, int ii);
void __fastcall NetSendCmdGItem2(unsigned char usonly, unsigned char bCmd, unsigned char mast, unsigned char pnum, struct TCmdGItem *p);
bool __fastcall NetSendCmdReq2(unsigned char bCmd, unsigned char mast, unsigned char pnum, struct TCmdGItem *p);
void __fastcall NetSendCmdExtra(struct TCmdGItem *p);
void __fastcall NetSendCmdPItem(unsigned char bHiPri, unsigned char bCmd, unsigned char x, unsigned char y);
void __fastcall NetSendCmdChItem(unsigned char bHiPri, unsigned char bLoc);
void __fastcall NetSendCmdDelItem(unsigned char bHiPri, unsigned char bLoc);
void __fastcall NetSendCmdDItem(unsigned char bHiPri, int ii);
void __fastcall NetSendCmdDamage(unsigned char bHiPri, unsigned char bPlr, unsigned int dwDam);
void __fastcall NetSendCmdString(int a1, const char *pszStr);
void __fastcall RemovePlrPortal(int pnum);
int __fastcall ParseCmd(int pnum, TCmd *pCmd);
void __fastcall DeltaImportData(unsigned char cmd, int recv_offset);
void *__fastcall DeltaImportItem(void *src, void *dst);
void *__fastcall DeltaImportObject(void *src, void *dst);
void *__fastcall DeltaImportMonster(void *src, void *dst);
char __fastcall DeltaImportJunk(int a1);
int __fastcall On_SYNCDATA(void *packet, int pnum);
int __fastcall On_WALKXY(struct TCmdLoc *pCmd, int pnum);
int __fastcall On_ADDSTR(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_ADDMAG(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_ADDDEX(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_ADDVIT(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_SBSPELL(struct TCmdParam1 *pCmd, int pnum);
void msg_errorf(char *pszFmt, ...);
int __fastcall On_GOTOGETITEM(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_REQUESTGITEM(struct TCmdGItem *pCmd, int pnum);
bool __fastcall i_own_level(int nReqLevel);
int __fastcall On_GETITEM(struct TCmdGItem *pCmd, int pnum);
bool __fastcall delta_get_item(struct TCmdGItem *pI, unsigned char bLevel);
int __fastcall On_GOTOAGETITEM(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_REQUESTAGITEM(struct TCmdGItem *pCmd, int pnum);
int __fastcall On_AGETITEM(struct TCmdGItem *pCmd, int pnum);
int __fastcall On_ITEMEXTRA(struct TCmdGItem *pCmd, int pnum);
int __fastcall On_PUTITEM(struct TCmdPItem *pCmd, int pnum);
void __fastcall delta_put_item(struct TCmdPItem *pI, int x, int y, unsigned char bLevel);
void __fastcall check_update_plr(int pnum);
int __fastcall On_SYNCPUTITEM(struct TCmdPItem *pCmd, int pnum);
int __fastcall On_RESPAWNITEM(struct TCmdPItem *pCmd, int pnum);
int __fastcall On_ATTACKXY(struct TCmdLoc *pCmd, int pnum);
int __fastcall On_SATTACKXY(struct TCmdLoc *pCmd, int pnum);
int __fastcall On_RATTACKXY(struct TCmdLoc *pCmd, int pnum);
int __fastcall On_SPELLXYD(struct TCmdLocParam3 *pCmd, int pnum);
int __fastcall On_SPELLXY(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_TSPELLXY(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_OPOBJXY(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_DISARMXY(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_OPOBJT(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_ATTACKID(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_ATTACKPID(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_RATTACKID(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_RATTACKPID(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_SPELLID(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_SPELLPID(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_TSPELLID(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_TSPELLPID(struct TCmdLocParam2 *pCmd, int pnum);
int __fastcall On_KNOCKBACK(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_RESURRECT(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_HEALOTHER(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_TALKXY(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_NEWLVL(struct TCmdParam2 *pCmd, int pnum);
int __fastcall On_WARP(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_MONSTDEATH(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_KILLGOLEM(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_AWAKEGOLEM(struct TCmdGolem *pCmd, int pnum);
int __fastcall On_MONSTDAMAGE(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_PLRDEAD(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_PLRDAMAGE(struct TCmdDamage *pCmd, int pnum);
int __fastcall On_OPENDOOR(struct TCmdParam1 *pCmd, int pnum);
void __fastcall delta_sync_object(int oi, unsigned char bCmd, unsigned char bLevel);
int __fastcall On_CLOSEDOOR(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_OPERATEOBJ(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_PLROPOBJ(struct TCmdParam2 *pCmd, int pnum);
int __fastcall On_BREAKOBJ(struct TCmdParam2 *pCmd, int pnum);
int __fastcall On_CHANGEPLRITEMS(struct TCmdChItem *pCmd, int pnum);
int __fastcall On_DELPLRITEMS(struct TCmdDelItem *pCmd, int pnum);
int __fastcall On_PLRLEVEL(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_DROPITEM(struct TCmdPItem *pCmd, int pnum);
int __fastcall On_SEND_PLRINFO(struct TCmdPlrInfoHdr *pCmd, int pnum);
int __fastcall On_ACK_PLRINFO(struct TCmdPlrInfoHdr *pCmd, int pnum);
int __fastcall On_PLAYER_JOINLEVEL(struct TCmdLocParam1 *pCmd, int pnum);
int __fastcall On_ACTIVATEPORTAL(DJunk *pCmd, int pnum);
void __fastcall delta_open_portal(int pnum, int x, int y, int bLevel, int bLType, int bSetLvl);
int __fastcall On_DEACTIVATEPORTAL(struct TCmd *pCmd, int pnum);
int __fastcall On_RETOWN(struct TCmd *pCmd, int pnum);
int __fastcall On_SETSTR(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_SETDEX(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_SETMAG(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_SETVIT(struct TCmdParam1 *pCmd, int pnum);
int __fastcall On_STRING(struct TCmdString *pCmd, int pnum);
int __fastcall On_SYNCQUEST(struct TCmdQuest *pCmd, int pnum);
int __fastcall On_ENDSHIELD(int a1, int pnum);
#ifdef _DEBUG
int __fastcall On_CHEAT_EXPERIENCE(struct TCmd *pCmd, int pnum);
int __fastcall On_CHEAT_SPELL_LEVEL(struct TCmd *pCmd, int pnum);
#endif
int __cdecl On_DEBUG();
int __fastcall On_NOVA(struct TCmdLoc *pCmd, int pnum);
int __fastcall On_SETSHIELD(int unused, int pnum);
int __fastcall On_REMSHIELD(int unused, int pnum);

/* data */

extern int msg_inf; // weak

#endif /* __MSG_H__ */
//HEADER_GOES_HERE
#ifndef __MSGCMD_H__
#define __MSGCMD_H__

extern int msgcmd_cpp_init_value; // weak
extern ChatCmd sgChat_Cmd;
extern int sgdwMsgCmdTimer;

void __cdecl msgcmd_cpp_init_1();
void __cdecl msgcmd_cpp_init_2();
void __cdecl msgcmd_init_event();
void __cdecl msgcmd_cleanup_chatcmd_atexit();
void __cdecl msgcmd_cleanup_chatcmd();
void __cdecl msgcmd_cmd_cleanup();
void __cdecl msgcmd_send_chat();
bool __fastcall msgcmd_add_server_cmd_W(char *chat_message);
void __fastcall msgcmd_add_server_cmd(char *command);
void __fastcall msgcmd_init_chatcmd(ChatCmd *chat_cmd);
void __fastcall msgcmd_free_event(ChatCmd *a1);
bool __fastcall msgcmd_delete_server_cmd_W(ChatCmd *cmd, ServerCommand *extern_msg);
ChatCmd *__fastcall msgcmd_alloc_event(ChatCmd *a1, int a2, int a3, int a4, int a5);
void __fastcall msgcmd_remove_event(ChatCmd *a1, int a2);
void __fastcall msgcmd_event_type(ChatCmd *a1, int a2, int *a3, int a4, int a5);
void __fastcall msgcmd_cleanup_chatcmd_1(ChatCmd *a1);
void __fastcall msgcmd_cleanup_extern_msg(ServerCommand **extern_msgs);

/* data */

extern int msgcmd_inf; // weak

#endif /* __MSGCMD_H__ */
//HEADER_GOES_HERE
#ifndef __MULTI_H__
#define __MULTI_H__

extern char gbSomebodyWonGameKludge; // weak
extern char pkdata_6761C0[4100];
extern char szPlayerDescript[128];
extern short sgwPackPlrOffsetTbl[4];
extern PkPlayerStruct pkplr[4];
extern char sgbPlayerTurnBitTbl[4];
extern char sgbPlayerLeftGameTbl[4];
extern int multi_cpp_init_value; // weak
extern int sgbSentThisCycle; // idb
extern int dword_678628; // weak
extern char gbActivePlayers; // weak
extern char gbGameDestroyed; // weak
extern char sgbSendDeltaTbl[4];
extern _gamedata sgGameInitInfo;
extern char byte_678640; // weak
extern int sglTimeoutStart; // weak
extern int sgdwPlayerLeftReasonTbl[4];
extern char pkdata_678658[4100];
extern unsigned int sgdwGameLoops; // idb
extern char gbMaxPlayers; // weak
extern char sgbTimeout; // weak
extern char szPlayerName[128];
extern char gbDeltaSender; // weak
extern int sgbNetInited; // weak
extern int player_state[4];

void __cdecl multi_cpp_init();
void __fastcall multi_msg_add(unsigned char *a1, unsigned char a2);
void __fastcall NetSendLoPri(unsigned char *pbMsg, unsigned char bLen);
void __fastcall multi_copy_packet(void *a1, void *packet, int size);
void __fastcall multi_send_packet(void *packet, int dwSize);
void __fastcall NetRecvPlrData(TPkt *pkt);
void __fastcall NetSendHiPri(unsigned char *pbMsg, unsigned char bLen);
unsigned char *__fastcall multi_recv_packet(void *packet, unsigned char *a2, int *a3);
void __fastcall multi_send_msg_packet(int a1, unsigned char *a2, unsigned char len);
void __cdecl multi_msg_countdown();
void __fastcall multi_parse_turn(int pnum, int turn);
void __fastcall multi_handle_turn_upper_bit(int pnum);
void __fastcall multi_player_left(int pnum, int reason);
void __cdecl multi_clear_left_tbl();
void __fastcall multi_player_left_msg(int pnum, int left);
void __cdecl multi_net_ping();
int __cdecl multi_handle_delta();
int __fastcall multi_check_pkt_valid(char *a1);
void __cdecl multi_mon_seeds();
void __cdecl multi_begin_timeout();
void __cdecl multi_check_drop_player();
void __cdecl multi_process_network_packets();
void __fastcall multi_handle_all_packets(int players, TPkt *packet, int a3);
void __cdecl multi_process_tmsgs();
void __fastcall multi_send_zero_packet(int pnum, char a2, void *pbSrc, int dwLen);
void __cdecl NetClose();
char __fastcall multi_event_handler(int a1);
void __stdcall multi_handle_events(_SNETEVENT *pEvt);
int __fastcall NetInit(int bSinglePlayer, int *pfExitProgram);
void __fastcall multi_clear_pkt(char *a1);
void __fastcall multi_send_pinfo(int pnum, TCmdPlrInfoHdr *cmd);
int __fastcall InitNewSeed(int newseed);
void __cdecl SetupLocalCoords();
int __fastcall multi_init_single(_SNETPROGRAMDATA *client_info, _SNETPLAYERDATA *user_info, _SNETUIDATA *ui_info);
int __fastcall multi_init_multi(_SNETPROGRAMDATA *client_info, _SNETPLAYERDATA *user_info, _SNETUIDATA *ui_info, int *a4);
int __fastcall multi_upgrade(int *a1);
void __fastcall multi_player_joins(int pnum, TCmdPlrInfoHdr *cmd, int a3);

/* data */

extern int multi_inf; // weak
extern event_type event_types[3];

#endif /* __MULTI_H__ */
//HEADER_GOES_HERE
#ifndef __NTHREAD_H__
#define __NTHREAD_H__

extern int nthread_cpp_init_value; // weak
extern char byte_679704; // weak
extern int gdwMsgLenTbl[4];
extern int gdwDeltaBytesSec; // weak
extern char byte_679734; // weak
extern int gdwTurnsInTransit; // weak
extern int glpMsgTbl[4];
extern unsigned int glpNThreadId;
extern char sgbSyncCountdown; // weak
extern int dword_679754; // weak
extern char byte_679758; // weak
extern char sgbPacketCountdown; // weak
extern char sgbThreadIsRunning; // weak
extern int gdwLargestMsgSize; // weak
extern int gdwNormalMsgSize; // weak
extern int dword_679764; // weak

void __cdecl nthread_cpp_init_1();
void __cdecl nthread_cpp_init_2();
void __cdecl nthread_init_mutex();
void __cdecl nthread_cleanup_mutex_atexit();
void __cdecl nthread_cleanup_mutex();
void __fastcall nthread_terminate_game(char *pszFcn);
int __fastcall nthread_send_and_recv_turn(int cur_turn, int turn_delta);
int __fastcall nthread_recv_turns(int *pfSendAsync);
void __cdecl nthread_set_turn_upper_bit();
void __fastcall nthread_start(bool set_turn_upper_bit);
unsigned int __stdcall nthread_handler(void *a1);
void __cdecl nthread_cleanup();
void __fastcall nthread_ignore_mutex(bool bStart);
bool __cdecl nthread_has_500ms_passed();

/* data */

extern int nthread_inf; // weak

#endif /* __NTHREAD_H__ */
//HEADER_GOES_HERE
#ifndef __OBJECTS_H__
#define __OBJECTS_H__

extern int trapid; // weak
extern int trapdir; // weak
extern int pObjCels[40];
extern char ObjFileList[40];
extern int objectactive[127];
extern int nobjects; // idb
extern int leverid; // idb
extern int objectavail[127];
extern ObjectStruct object[127];
extern int InitObjFlag; // weak
extern int numobjfiles; // weak

void __cdecl InitObjectGFX();
void __cdecl FreeObjectGFX();
bool __fastcall RndLocOk(int xp, int yp);
void __fastcall InitRndLocObj(int min, int max, int objtype);
void __fastcall InitRndLocBigObj(int min, int max, int objtype);
void __fastcall InitRndLocObj5x5(int min, int max, int objtype);
void __cdecl ClrAllObjects();
void __cdecl AddTortures();
void __cdecl AddCandles();
void __fastcall AddBookLever(int lx1, int ly1, int lx2, int ly2, int x1, int y1, int x2, int y2, int msg);
void __cdecl InitRndBarrels();
void __fastcall AddL1Objs(int x1, int y1, int x2, int y2);
void __fastcall AddL2Objs(int x1, int y1, int x2, int y2);
void __fastcall AddL3Objs(int x1, int y1, int x2, int y2);
bool __fastcall WallTrapLocOk(int xp, int yp);
void __cdecl AddL2Torches();
bool __fastcall TorchLocOK(int xp, int yp);
void __cdecl AddObjTraps();
void __cdecl AddChestTraps();
void __fastcall LoadMapObjects(unsigned char *pMap, int startx, int starty, int x1, int y1, int w, int h, int leveridx);
void __fastcall LoadMapObjs(unsigned char *pMap, int startx, int starty);
void __cdecl AddDiabObjs();
void __cdecl AddStoryBooks();
void __fastcall AddHookedBodies(int freq);
void __cdecl AddL4Goodies();
void __cdecl AddLazStand();
void __fastcall InitObjects(int a1);
void __fastcall SetMapObjects(char *pMap, int startx, int starty);
void __fastcall DeleteObject(int oi, int i);
void __fastcall SetupObject(int i, int x, int y, int ot);
void __fastcall SetObjMapRange(int i, int x1, int y1, int x2, int y2, int v);
void __fastcall SetBookMsg(int i, int msg);
void __fastcall AddL1Door(int i, int x, int y, int ot);
void __fastcall AddSCambBook(int i);
void __fastcall AddChest(int i, int t);
void __fastcall AddL2Door(int i, int x, int y, int ot);
void __fastcall AddL3Door(int i, int x, int y, int ot);
void __fastcall AddSarc(int i);
void __fastcall AddFlameTrap(int i);
void __fastcall AddFlameLvr(int i);
void __fastcall AddTrap(int i);
void __fastcall AddObjLight(int i, int r);
void __fastcall AddBarrel(int i);
void __fastcall AddShrine(int i);
void __fastcall AddBookcase(int i);
void __fastcall AddPurifyingFountain(int i);
void __fastcall AddArmorStand(int i);
void __fastcall AddDecap(int i);
void __fastcall AddVilebook(int i);
void __fastcall AddMagicCircle(int i);
void __fastcall AddBookstand(int i);
void __fastcall AddPedistal(int i);
void __fastcall AddStoryBook(int i);
void __fastcall AddWeaponRack(int i);
void __fastcall AddTorturedBody(int i);
void __fastcall GetRndObjLoc(int randarea, int *xx, int *yy);
void __cdecl AddMushPatch();
void __cdecl AddSlainHero();
void __fastcall AddObject(int ot, int ox, int oy);
void __fastcall Obj_Light(int i, int lr);
void __fastcall Obj_Circle(int i);
void __fastcall Obj_StopAnim(int i);
void __fastcall Obj_Door(int i);
void __fastcall Obj_Sarc(int i);
void __fastcall ActivateTrapLine(int ttype, int tid);
void __fastcall Obj_FlameTrap(int i);
void __fastcall Obj_Trap(int i);
void __fastcall Obj_BCrossDamage(int i);
void __cdecl ProcessObjects();
void __fastcall ObjSetMicro(int dx, int dy, int pn);
void __fastcall objects_set_door_piece(int x, int y);
void __fastcall ObjSetMini(int x, int y, int v);
void __fastcall ObjL1Special(int x1, int y1, int x2, int y2);
void __fastcall ObjL2Special(int x1, int y1, int x2, int y2);
void __fastcall DoorSet(int oi, int dx, int dy);
void __cdecl RedoPlayerVision();
void __fastcall OperateL1RDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall OperateL1LDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall OperateL2RDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall OperateL2LDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall OperateL3RDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall OperateL3LDoor(int pnum, int oi, unsigned char sendflag);
void __fastcall MonstCheckDoors(int m);
void __fastcall ObjChangeMap(int x1, int y1, int x2, int y2);
void __fastcall ObjChangeMapResync(int x1, int y1, int x2, int y2);
void __fastcall OperateL1Door(int pnum, int i, unsigned char sendflag);
void __fastcall OperateLever(int pnum, int i);
void __fastcall OperateBook(int pnum, int i);
void __fastcall OperateBookLever(int pnum, int i);
void __fastcall OperateSChambBk(int pnum, int i);
void __fastcall OperateChest(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateMushPatch(int pnum, int i);
void __fastcall OperateInnSignChest(int pnum, int i);
void __fastcall OperateSlainHero(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateTrapLvr(int i);
void __fastcall OperateSarc(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateL2Door(int pnum, int i, unsigned char sendflag);
void __fastcall OperateL3Door(int pnum, int i, unsigned char sendflag);
void __fastcall OperatePedistal(int pnum, int i);
void __fastcall TryDisarm(int pnum, int i);
int __fastcall ItemMiscIdIdx(int imiscid);
void __fastcall OperateShrine(int pnum, int i, int sType);
void __fastcall OperateSkelBook(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateBookCase(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateDecap(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateArmorStand(int pnum, int i, unsigned char sendmsg);
int __fastcall FindValidShrine(int i);
void __fastcall OperateGoatShrine(int pnum, int i, int sType);
void __fastcall OperateCauldron(int pnum, int i, int sType);
bool __fastcall OperateFountains(int pnum, int i);
void __fastcall OperateWeaponRack(int pnum, int i, unsigned char sendmsg);
void __fastcall OperateStoryBook(int pnum, int i);
void __fastcall OperateLazStand(int pnum, int i);
void __fastcall OperateObject(int pnum, int i, unsigned char TeleFlag);
void __fastcall SyncOpL1Door(int pnum, int cmd, int i);
void __fastcall SyncOpL2Door(int pnum, int cmd, int i);
void __fastcall SyncOpL3Door(int pnum, int cmd, int i);
void __fastcall SyncOpObject(int pnum, int cmd, int i);
void __fastcall BreakCrux(int i);
void __fastcall BreakBarrel(int pnum, int i, int dam, unsigned char forcebreak, int sendmsg);
void __fastcall BreakObject(int pnum, int oi);
void __fastcall SyncBreakObj(int pnum, int oi);
void __fastcall SyncL1Doors(int i);
void __fastcall SyncCrux(int i);
void __fastcall SyncLever(int i);
void __fastcall SyncQSTLever(int i);
void __fastcall SyncPedistal(int i);
void __fastcall SyncL2Doors(int i);
void __fastcall SyncL3Doors(int i);
void __fastcall SyncObjectAnim(int o);
void __fastcall GetObjectStr(int i);

/* rdata */

extern int ObjTypeConv[113];
extern ObjDataStruct AllObjects[99];
extern char *ObjMasterLoadList[56];
extern int bxadd[8];
extern int byadd[8];
extern char *shrinestrs[26];
extern unsigned char shrinemin[26];
extern unsigned char shrinemax[26];
extern unsigned char shrineavail[26];
extern char *StoryBookName[9];
extern int StoryText[3][3];

#endif /* __OBJECTS_H__ */
//HEADER_GOES_HERE
#ifndef __PACK_H__
#define __PACK_H__

extern int pack_cpp_init_value; // weak

void __cdecl pack_cpp_init();
void __fastcall PackPlayer(PkPlayerStruct *pPack, int pnum, bool manashield);
void __fastcall PackItem(PkItemStruct *id, ItemStruct *is);
void __fastcall VerifyGoldSeeds(PlayerStruct *pPlayer);
void __fastcall UnPackPlayer(PkPlayerStruct *pPack, int pnum, bool killok);
void __fastcall UnPackItem(PkItemStruct *is, ItemStruct *id);

/* data */

extern int pack_inf; // weak

#endif /* __PACK_H__ */
//HEADER_GOES_HERE
#ifndef __PALETTE_H__
#define __PALETTE_H__

extern PALETTEENTRY logical_palette[256];
extern int palette_cpp_init_value; // weak
extern PALETTEENTRY system_palette[256];
extern PALETTEENTRY orig_palette[256];
extern UINT gdwPalEntries;

void __cdecl palette_cpp_init();
void __cdecl palette_save_gamme();
void __cdecl palette_init();
void __cdecl palette_load_gamma();
void __cdecl LoadSysPal();
void __fastcall LoadPalette(char *pszFileName);
void __fastcall LoadRndLvlPal(int l);
void __cdecl ResetPal();
void __cdecl palette_inc_gamma();
void __cdecl palette_update();
void __fastcall palette_apply_gamma_correction(PALETTEENTRY *dst, PALETTEENTRY *src, int n);
void __cdecl palette_dec_gamma();
int __fastcall palette_update_gamma(int gamma);
void __cdecl BlackPalette();
void __fastcall SetFadeLevel(int brightness);
void __fastcall PaletteFadeIn(int fr);
void __fastcall PaletteFadeOut(int fr);
void __cdecl palette_update_caves();
void __fastcall palette_update_quest_palette(int n);
bool __cdecl palette_get_colour_cycling();
void __fastcall palette_set_color_cycling(bool enabled);

/* data */

extern int palette_inf; // weak

/* rdata */

extern int gamma_correction; // idb
extern int color_cycling_enabled; // idb
extern bool sgbFadedIn;

#endif /* __PALETTE_H__ */
//HEADER_GOES_HERE
#ifndef __PATH_H__
#define __PATH_H__

extern PATHNODE path_nodes[300];
extern int gdwCurPathStep;
extern int pnode_vals[26];
extern PATHNODE *pnode_ptr;
extern PATHNODE *pnode_tblptr[300];
extern PATHNODE path_2_nodes[300];

int __fastcall FindPath(bool (__fastcall *PosOk)(int, int, int), int PosOkArg, int sx, int sy, int dx, int dy, char *path);
int __fastcall path_get_h_cost(int sx, int sy, int dx, int dy);
int __fastcall path_check_equal(PATHNODE *pPath, int dx, int dy);
PATHNODE *__cdecl GetNextPath();
bool __fastcall path_solid_pieces(PATHNODE *pPath, int dx, int dy);
int __fastcall path_get_path(bool (__fastcall *PosOk)(int, int, int), int PosOkArg, PATHNODE *pPath, int x, int y);
int __fastcall path_parent_path(PATHNODE *pPath, int dx, int dy, int sx, int sy);
PATHNODE *__fastcall path_get_node1(int dx, int dy);
PATHNODE *__fastcall path_get_node2(int dx, int dy);
void __fastcall path_next_node(PATHNODE *pPath);
void __fastcall path_set_coords(PATHNODE *pPath);
void __fastcall path_push_active_step(PATHNODE *pPath);
PATHNODE *__cdecl path_pop_active_step();
PATHNODE *__cdecl path_new_step();

/* data */

extern char pathxdir[8];
extern char pathydir[8];

/* rdata */
extern char path_directions[9];

#endif /* __PATH_H__ */
//HEADER_GOES_HERE
#ifndef __PFILE_H__
#define __PFILE_H__

extern int pfile_cpp_init_value;
extern char hero_names[320];
extern bool gbValidSaveFile; // idb
extern int save_prev_tc; // weak

void __cdecl pfile_cpp_init();
void __cdecl pfile_init_save_directory();
void __fastcall pfile_check_available_space(char *pszDir);
void __cdecl pfile_write_hero();
int __fastcall pfile_get_save_num_from_name(char *name);
void __fastcall pfile_encode_hero(PkPlayerStruct *pPack);
bool __fastcall pfile_open_archive(bool a1, int save_num);
void __fastcall pfile_get_save_path(char *pszBuf, int dwBufSize, int save_num);
void __fastcall pfile_flush(bool is_single_player, int save_num);
bool __fastcall pfile_create_player_description(char *dst, int len);
int __fastcall pfile_create_save_file(char *name_1, char *name_2);
void __cdecl pfile_flush_W();
void __fastcall game_2_ui_player(PlayerStruct *p, _uiheroinfo *heroinfo, bool bHasSaveFile);
char __fastcall game_2_ui_class(PlayerStruct *p);
bool __stdcall pfile_ui_set_hero_infos(void (__stdcall *ui_add_hero_info)(_uiheroinfo *));
char *__fastcall GetSaveDirectory(char *dst, int dst_size, int save_num);
bool __fastcall pfile_read_hero(void *archive, PkPlayerStruct *pPack);
void *__fastcall pfile_open_save_archive(int *unused, int save_num);
void __fastcall pfile_SFileCloseArchive(void *hsArchive);
bool __fastcall pfile_archive_contains_game(void *hsArchive);
bool __stdcall pfile_ui_set_class_stats(int player_class_nr, _uidefaultstats *class_stats);
int __fastcall pfile_get_player_class(int player_class_nr);
bool __stdcall pfile_ui_save_create(_uiheroinfo *heroinfo);
bool __stdcall pfile_get_file_name(int lvl, char *dst);
bool __stdcall pfile_delete_save(_uiheroinfo *hero_info);
void __cdecl pfile_read_player_from_save();
void __fastcall GetTempLevelNames(char *szTemp);
void __fastcall GetPermLevelNames(char *szPerm);
void __fastcall pfile_get_game_name(char *dst);
void __cdecl pfile_remove_temp_files();
bool __stdcall GetTempSaveNames(int dwIndex, char *szTemp);
void __cdecl pfile_rename_temp_to_perm();
bool __stdcall GetPermSaveNames(int dwIndex, char *szPerm);
void __fastcall pfile_write_save_file(char *pszName, void *pbData, int dwLen, int qwLen);
void __fastcall pfile_strcpy(char *dst, char *src);
char *__fastcall pfile_read(char *pszName, int *pdwLen);
void __fastcall pfile_update(bool force_save);

/* data */

extern int pfile_inf; // weak

#endif /* __PFILE_H__ */
//HEADER_GOES_HERE
#ifndef __PLAYER_H__
#define __PLAYER_H__

extern int plr_lframe_size; // idb
extern int plr_wframe_size; // idb
extern char plr_gfx_flag; // weak
extern int player_cpp_init_value; // weak
extern int plr_aframe_size; // idb
extern int myplr;
extern PlayerStruct plr[4];
extern int plr_fframe_size; // idb
extern int plr_qframe_size; // idb
extern int deathflag; // idb
extern int plr_hframe_size; // idb
extern int plr_bframe_size; // idb
extern char plr_gfx_bflag; // weak
extern int plr_sframe_size; // idb
extern int deathdelay; // weak
extern int plr_dframe_size; // idb

void __cdecl player_cpp_init();
void __fastcall player_init_cl2_hdrs(char *src, char *dst);
void __fastcall LoadPlrGFX(int pnum, int gfxflag);
void __fastcall InitPlayerGFX(int pnum);
void __fastcall InitPlrGFXMem(int pnum);
int __fastcall GetPlrGFXSize(char *szCel);
void __fastcall FreePlayerGFX(int pnum);
void __fastcall NewPlrAnim(int pnum, int Peq, int numFrames, int Delay, int width);
void __fastcall ClearPlrPVars(int pnum);
void __fastcall SetPlrAnims(int pnum);
void __fastcall ClearPlrRVars(PlayerStruct *pPlayer);
void __fastcall CreatePlayer(int pnum, char c);
int __fastcall CalcStatDiff(int pnum);
void __fastcall NextPlrLevel(int pnum);
void __fastcall AddPlrExperience(int pnum, int lvl, int exp);
void __fastcall AddPlrMonstExper(int lvl, int exp, char pmask);
void __fastcall InitPlayer(int pnum, bool FirstTime);
void __cdecl InitMultiView();
void __fastcall InitPlayerLoc(int pnum, bool flag);
bool __fastcall SolidLoc(int x, int y);
bool __fastcall PlrDirOK(int pnum, int dir);
void __fastcall PlrClrTrans(int x, int y);
void __fastcall PlrDoTrans(int x, int y);
void __fastcall SetPlayerOld(int pnum);
void __fastcall FixPlayerLocation(int pnum, int dir);
void __fastcall StartStand(int pnum, int dir);
void __fastcall StartWalkStand(int pnum);
void __fastcall PM_ChangeLightOff(int pnum);
void __fastcall PM_ChangeOffset(int pnum);
void __fastcall StartWalk(int pnum, int xvel, int yvel, int xadd, int yadd, int EndDir, int sdir);
void __fastcall StartWalk2(int pnum, int xvel, int yvel, int xoff, int yoff, int xadd, int yadd, int EndDir, int sdir);
void __fastcall StartWalk3(int pnum, int xvel, int yvel, int xoff, int yoff, int xadd, int yadd, int mapx, int mapy, int EndDir, int sdir);
void __fastcall StartAttack(int pnum, int d);
void __fastcall StartRangeAttack(int pnum, int d, int cx, int cy);
void __fastcall StartPlrBlock(int pnum, int dir);
void __fastcall StartSpell(int pnum, int d, int cx, int cy);
void __fastcall FixPlrWalkTags(int pnum);
void __fastcall RemovePlrFromMap(int pnum);
void __fastcall StartPlrHit(int pnum, int dam, unsigned char forcehit);
void __fastcall RespawnDeadItem(ItemStruct *itm, int x, int y);
void __fastcall StartPlayerKill(int pnum, int earflag);
void __fastcall PlrDeadItem(int pnum, struct ItemStruct *itm, int xx, int yy);
void __fastcall DropHalfPlayersGold(int pnum);
void __fastcall SyncPlrKill(int pnum, int earflag);
void __fastcall j_StartPlayerKill(int pnum, int earflag);
void __fastcall RemovePlrMissiles(int pnum);
void __fastcall InitLevelChange(int pnum);
void __fastcall StartNewLvl(int pnum, int fom, int lvl);
void __fastcall RestartTownLvl(int pnum);
void __fastcall StartWarpLvl(int pnum, int pidx);
int __fastcall PM_DoStand(int pnum);
int __fastcall PM_DoWalk(int pnum);
int __fastcall PM_DoWalk2(int pnum);
int __fastcall PM_DoWalk3(int pnum);
bool __fastcall WeaponDur(int pnum, int durrnd);
bool __fastcall PlrHitMonst(int pnum, int m);
bool __fastcall PlrHitPlr(int pnum, char p);
bool __fastcall PlrHitObj(int pnum, int mx, int my);
int __fastcall PM_DoAttack(int pnum);
int __fastcall PM_DoRangeAttack(int pnum);
void __fastcall ShieldDur(int pnum);
int __fastcall PM_DoBlock(int pnum);
int __fastcall PM_DoSpell(int pnum);
int __fastcall PM_DoGotHit(int pnum);
void __fastcall ArmorDur(int pnum);
int __fastcall PM_DoDeath(int pnum);
void __fastcall CheckNewPath(int pnum);
bool __fastcall PlrDeathModeOK(int pnum);
void __cdecl ValidatePlayer();
void __cdecl ProcessPlayers();
void __fastcall CheckCheatStats(int pnum);
void __fastcall ClrPlrPath(int pnum);
bool __fastcall PosOkPlayer(int pnum, int px, int py);
void __fastcall MakePlrPath(int pnum, int xx, int yy, unsigned char endspace);
void __fastcall CheckPlrSpell();
void __fastcall SyncPlrAnim(int pnum);
void __fastcall SyncInitPlrPos(int pnum);
void __fastcall SyncInitPlr(int pnum);
void __fastcall CheckStats(int pnum);
void __fastcall ModifyPlrStr(int pnum, int l);
void __fastcall ModifyPlrMag(int pnum, int l);
void __fastcall ModifyPlrDex(int pnum, int l);
void __fastcall ModifyPlrVit(int pnum, int l);
void __fastcall SetPlayerHitPoints(int pnum, int newhp);
void __fastcall SetPlrStr(int pnum, int v);
void __fastcall SetPlrMag(int pnum, int v);
void __fastcall SetPlrDex(int pnum, int v);
void __fastcall SetPlrVit(int pnum, int v);
void __fastcall InitDungMsgs(int pnum);
void __cdecl PlayDungMsgs();

/* data */

extern int player_inf;
extern char ArmourChar[4];
extern char WepChar[10];
extern char CharChar[4];

/* rdata */

extern int plrxoff[9];
extern int plryoff[9];
extern int plrxoff2[9];
extern int plryoff2[9];
extern char PlrGFXAnimLens[3][11];
extern int PWVel[4][3];
extern int StrengthTbl[3];
extern int MagicTbl[3];
extern int DexterityTbl[3];
extern int VitalityTbl[3];
extern int ToBlkTbl[3];
extern char *ClassStrTblOld[3];
extern int MaxStats[3][4];
extern int ExpLvlsTbl[51];
extern char *ClassStrTbl[3];
extern unsigned char fix[9];

#endif /* __PLAYER_H__ */
//HEADER_GOES_HERE
#ifndef __PLRMSG_H__
#define __PLRMSG_H__

extern int plrmsg_ticks; // weak
extern char plr_msg_slot; // weak
extern _plrmsg plr_msgs[8];

void __fastcall plrmsg_delay(int a1);
char *__fastcall ErrorPlrMsg(char *pszMsg);
size_t EventPlrMsg(char *pszFmt, ...);
void __fastcall SendPlrMsg(int pnum, const char *pszStr);
void __cdecl ClearPlrMsg();
void __cdecl InitPlrMsg();
void __cdecl DrawPlrMsg();
void __fastcall PrintPlrMsg(int no, int x, int y, char *str, int just);

/* data */

extern text_color text_color_from_player_num[2];

#endif /* __PLRMSG_H__ */
//HEADER_GOES_HERE
#ifndef __PORTAL_H__
#define __PORTAL_H__

extern PortalStruct portal[4];
extern int portalindex;
// int END_portalstruct; // weak

void __cdecl InitPortals();
void __fastcall SetPortalStats(int i, int o, int x, int y, int lvl, int lvltype);
void __fastcall AddWarpMissile(int i, int x, int y);
void __cdecl SyncPortals();
void __fastcall AddInTownPortal(int i);
void __fastcall ActivatePortal(int i, int x, int y, int lvl, int lvltype, int sp);
void __fastcall DeactivatePortal(int i);
bool __fastcall PortalOnLevel(int i);
void __fastcall RemovePortalMissile(int id);
void __fastcall SetCurrentPortal(int p);
void __cdecl GetPortalLevel();
void __cdecl GetPortalLvlPos();
bool __fastcall PosOkPortal(int level, int x, int y);

/* rdata */
extern int WarpDropX[4];
extern int WarpDropY[4];

#endif /* __PORTAL_H__ */
//HEADER_GOES_HERE
#ifndef __QUESTS_H__
#define __QUESTS_H__

extern int qtopline; // idb
extern int questlog; // weak
extern void *pQLogCel;
extern QuestStruct quests[16];
extern int qline; // weak
extern int qlist[16];
extern int numqlines; // weak
extern int WaterDone; // idb
extern int ReturnLvlY; // idb
extern int ReturnLvlX; // idb
extern int ReturnLvlT; // idb
extern int ALLQUESTS; // idb
extern int ReturnLvl; // idb

void __cdecl InitQuests();
void __cdecl CheckQuests();
bool __cdecl ForceQuests();
bool __fastcall QuestStatus(int i);
void __fastcall CheckQuestKill(int m, unsigned char sendmsg);
void __cdecl DrawButcher();
void __fastcall DrawSkelKing(int quest_id, int xx, int yy);
void __fastcall DrawWarLord(int xx, int yy);
void __fastcall DrawSChamber(int quest_id, int xx, int yy);
void __fastcall DrawLTBanner(int xx, int yy);
void __fastcall DrawBlind(int xx, int yy);
void __fastcall DrawBlood(int xx, int yy);
void __fastcall DRLG_CheckQuests(int xx, int yy);
void __cdecl SetReturnLvlPos();
void __cdecl GetReturnLvlPos();
void __cdecl ResyncMPQuests();
void __cdecl ResyncQuests();
void __fastcall PrintQLString(int x, int y, unsigned char cjustflag, char *str, int col);
void __cdecl DrawQuestLog();
void __cdecl StartQuestlog();
void __cdecl QuestlogUp();
void __cdecl QuestlogDown();
void __cdecl QuestlogEnter();
void __cdecl QuestlogESC();
void __fastcall SetMultiQuest(int q, int s, unsigned char l, int v1);

/* rdata */
extern QuestData questlist[16];
extern char questxoff[7];
extern char questyoff[7];
extern char *questtrigstr[5];
extern int QuestGroup1[3];
extern int QuestGroup2[3];
extern int QuestGroup3[3];
extern int QuestGroup4[2];

#endif /* __QUESTS_H__ */
//HEADER_GOES_HERE
#ifndef __RESTRICT_H__
#define __RESTRICT_H__

bool __cdecl SystemSupported();
bool __cdecl RestrictedTest();
bool __cdecl ReadOnlyTest();

#endif /* __RESTRICT_H__ */
//HEADER_GOES_HERE
#ifndef __SCROLLRT_H__
#define __SCROLLRT_H__

extern int light_table_index; // weak
extern int screen_y_times_768[1024];
extern int scrollrt_cpp_init_value; // weak
extern unsigned int sgdwCursWdtOld; // idb
extern int sgdwCursX; // idb
extern int sgdwCursY; // idb
extern int screen_buf_end; // weak
extern int sgdwCursHgt;
extern int level_cel_block; // weak
extern int sgdwCursXOld; // idb
extern int sgdwCursYOld; // idb
extern char arch_draw_type; // weak
extern DDSURFACEDESC DDS_desc;
extern int cel_transparency_active; // weak
extern int level_piece_id; // weak
extern int sgdwCursWdt;
extern int (__fastcall *DrawPlrProc)(int player_num, int x, int y, int screen_x, int screen_y, void *cl2_buf, int frame, int frame_width, int a9, int a10);
extern char cursor_draw_back_buffer[8192];
extern int draw_monster_num; // weak
extern int sgdwCursHgtOld; // idb

void __cdecl scrollrt_cpp_init();
void __cdecl ClearCursor();
void __fastcall DrawMissile(int x, int y, int sx, int sy, int a5, int a6, int del_flag);
void __fastcall DrawClippedMissile(int x, int y, int sx, int sy, int a5, int a6, int a7);
void __fastcall DrawDeadPlayer(int x, int y, int sx, int sy, int a5, int a6, bool clipped);
void __fastcall DrawPlayer(int pnum, int x, int y, int px, int py, int animdata, int animframe, int animwidth, int a9, int a10);
void __fastcall DrawClippedPlayer(int pnum, int x, int y, int px, int py, int animdata, int animframe, int animwidth, int a9, int a10);
void __fastcall DrawView(int StartX, int StartY);
void __fastcall DrawGame(int x, int y);
void __fastcall scrollrt_draw_lower(int x, int y, int sx, int sy, int a5, int some_flag);
void __fastcall scrollrt_draw_clipped_dungeon(char *a1, int sx, int sy, int a4, int a5, int a6);
void __fastcall DrawClippedMonster(int x, int y, int a3, int a4, int mon_id, int a6, int a7);
void __fastcall DrawClippedObject(int x, int y, int a3, int a4, int pre_flag, int a6, int dir);
void __fastcall scrollrt_draw_clipped_e_flag(char *buffer, int x, int y, int a4, int a5);
void __fastcall scrollrt_draw_lower_2(int x, int y, int sx, int sy, int a5, int a6, int some_flag);
void __fastcall scrollrt_draw_clipped_dungeon_2(char *buffer, int x, int y, int a4, int a5, int sx, int sy, int me_flag);
void __fastcall scrollrt_draw_clipped_e_flag_2(char *buffer, int x, int y, int a4, signed int a5, int sx, int sy);
void __fastcall scrollrt_draw_upper(int x, int y, int sx, int sy, int a5, int a6, int some_flag);
void __fastcall scrollrt_draw_dungeon(char *buffer, int x, int y, int a4, int a5, int sx, int sy, int me_flag);
void __fastcall DrawMonster(int x, int y, int a3, int a4, int mon_id, int a6, int a7);
void __fastcall DrawObject(int x, int y, int a3, int a4, int pre_flag, int a6, int dir);
void __fastcall scrollrt_draw_e_flag(char *buffer, int x, int y, int a4, int a5, int sx, int sy);
void __fastcall DrawZoom(int x, int y);
void __cdecl ClearScreenBuffer();
#ifdef _DEBUG
void __cdecl ScrollView();
void __cdecl EnableFrameCount();
#endif
void __fastcall scrollrt_draw_game_screen(bool draw_cursor);
void __cdecl scrollrt_draw_cursor_back_buffer();
void __cdecl scrollrt_draw_cursor_item();
void __fastcall DrawMain(int dwHgt, int draw_desc, int draw_hp, int draw_mana, int draw_sbar, int draw_btn);
#ifdef _DEBUG
void __cdecl DrawFPS();
#endif
void __fastcall DoBlitScreen(int dwX, int dwY, int dwWdt, int dwHgt);
void __cdecl DrawAndBlit();

/* data */

extern int scrollrt_inf; // weak

/* rdata */

/* used in 1.00 debug */
extern char *szMonModeAssert[18];
extern char *szPlrModeAssert[12];

#endif /* __SCROLLRT_H__ */
//HEADER_GOES_HERE
#ifndef __SETMAPS_H__
#define __SETMAPS_H__

int __fastcall ObjIndex(int x, int y);
void __cdecl AddSKingObjs();
void __cdecl AddSChamObjs();
void __cdecl AddVileObjs();
void __fastcall DRLG_SetMapTrans(char *sFileName);
void __cdecl LoadSetMap();

/* rdata */
extern RECT8 QSRects[32];
extern char *quest_level_names[];

#endif /* __SETMAPS_H__ */
//HEADER_GOES_HERE
#ifndef __SHA_H__
#define __SHA_H__

/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word) \
				(((word) << (bits)) | ((word) >> (32-(bits))))
#define SHA1HashSize 20

//sha
extern SHA1Context sgSHA1[3];

void __cdecl SHA1Clear();
void __fastcall SHA1Result(int n, char Message_Digest[SHA1HashSize]);
void __fastcall SHA1Calculate(int n, const char *data, char Message_Digest[SHA1HashSize]);
void __fastcall SHA1Input(SHA1Context *context, const char *message_array, int len);
void __fastcall SHA1ProcessMessageBlock(SHA1Context *context);
void __fastcall SHA1Reset(int n);

#endif /* __SHA_H__ */
//HEADER_GOES_HERE
#ifndef __SOUND_H__
#define __SOUND_H__

extern float sound_cpp_init_value;
extern IDirectSoundBuffer *DSBs[8];
extern IDirectSound *sglpDS;
extern char gbSndInited;
extern int sglMusicVolume;
extern int sglSoundVolume;
extern HMODULE hDsound_dll; // idb
extern void *sgpMusicTrack;
extern IDirectSoundBuffer *sglpDSB;

void __cdecl sound_cpp_init();
void __fastcall snd_update(bool bStopAll);
void __fastcall snd_stop_snd(TSnd *pSnd);
bool __fastcall snd_playing(TSnd *pSnd);
void __fastcall snd_play_snd(TSnd *pSnd, int lVolume, int lPan);
IDirectSoundBuffer *__fastcall sound_dup_channel(IDirectSoundBuffer *DSB);
bool __fastcall sound_file_reload(TSnd *sound_file, IDirectSoundBuffer *DSB);
TSnd *__fastcall sound_file_load(char *path);
void __fastcall sound_CreateSoundBuffer(TSnd *sound_file);
void __fastcall sound_file_cleanup(TSnd *sound_file);
void __fastcall snd_init(HWND hWnd);
void __fastcall sound_load_volume(char *value_name, int *value);
void __fastcall sound_create_primary_buffer(int music_track);
int __fastcall sound_DirectSoundCreate(GUID *guid, IDirectSound **DS, int always_null);
void __cdecl sound_cleanup();
void __fastcall sound_store_volume(char *key, int value);
void __cdecl music_stop();
void __fastcall music_start(int nTrack);
void __fastcall sound_disable_music(bool disable);
int __fastcall sound_get_or_set_music_volume(int volume);
int __fastcall sound_get_or_set_sound_volume(int volume);

/* data */

extern int sound_inf; // weak

/* rdata */

extern char gbMusicOn; // weak
extern char gbSoundOn; // weak
extern char gbDupSounds; // weak
extern int sgnMusicTrack;
extern char *sgszMusicTracks[6];
extern RECT8 QSRect[2]; /* psx version? */

#endif /* __SOUND_H__ */
//HEADER_GOES_HERE
#ifndef __SPELLS_H__
#define __SPELLS_H__

int __fastcall GetManaAmount(int id, int sn);
void __fastcall UseMana(int id, int sn);
bool __fastcall CheckSpell(int id, int sn, char st, bool manaonly);
void __fastcall CastSpell(int id, int spl, int sx, int sy, int dx, int dy, int caster, int spllvl);
void __fastcall DoResurrect(int pnum, int rid);
void __fastcall PlacePlayer(int pnum);
void __fastcall DoHealOther(int pnum, int rid);

/* rdata */

extern SpellData spelldata[37];

#endif /* __SPELLS_H__ */
//HEADER_GOES_HERE
#ifndef __STORES_H__
#define __STORES_H__

extern int stextup; // weak
extern int storenumh; // weak
extern int stextlhold; // weak
extern ItemStruct boyitem;
extern int stextshold; // idb
extern ItemStruct premiumitem[6];
extern void *pSTextBoxCels;
extern int premiumlevel; // idb
extern int talker; // weak
extern STextStruct stext[24];
extern char stextsize; // weak
extern int stextsmax; // weak
extern int InStoreFlag; // idb
extern ItemStruct storehold[48];
extern int gossipstart; // weak
extern ItemStruct witchitem[20];
extern int stextscrl; // weak
extern int numpremium; // idb
extern ItemStruct healitem[20];
extern ItemStruct golditem;
extern char storehidx[48];
extern void *pSTextSlidCels;
extern int stextvhold; // weak
extern int stextsel; // weak
extern char stextscrldbtn; // weak
extern int gossipend; // weak
extern void *pCelBuff;
extern int stextsval; // idb
extern int boylevel; // weak
extern ItemStruct smithitem[20];
extern int stextdown; // weak
extern char stextscrlubtn; // weak
extern char stextflag; // weak

void __cdecl InitStores();
void __cdecl SetupTownStores();
void __cdecl FreeStoreMem();
void __cdecl DrawSTextBack();
void __fastcall PrintSString(int x, int y, unsigned char cjustflag, char *str, int col, int val);
void __fastcall DrawSLine(int y);
void __fastcall DrawSArrows(int a1, int a2);
void __cdecl DrawSTextHelp();
void __fastcall ClearSText(int s, int e);
void __fastcall AddSLine(int y);
void __fastcall AddSTextVal(int y, int val);
void __fastcall OffsetSTextY(int y, int yo);
void __fastcall AddSText(int x, int y, unsigned char j, char *str, int clr, int sel);
void __cdecl StoreAutoPlace();
void __cdecl S_StartSmith();
void __fastcall S_ScrollSBuy(int idx);
void __fastcall PrintStoreItem(ItemStruct *x, int l, char iclr);
void __cdecl S_StartSBuy();
void __fastcall S_ScrollSPBuy(int idx);
bool __cdecl S_StartSPBuy();
bool __fastcall SmithSellOk(int i);
void __fastcall S_ScrollSSell(int idx);
void __cdecl S_StartSSell();
bool __fastcall SmithRepairOk(int i);
void __cdecl S_StartSRepair();
void __fastcall AddStoreHoldRepair(ItemStruct *itm, int i);
void __cdecl S_StartWitch();
void __fastcall S_ScrollWBuy(int idx);
void __cdecl S_StartWBuy();
bool __fastcall WitchSellOk(int i);
void __cdecl S_StartWSell();
bool __fastcall WitchRechargeOk(int i);
void __fastcall AddStoreHoldRecharge(ItemStruct itm, int i);
void __cdecl S_StartWRecharge();
void __cdecl S_StartNoMoney();
void __cdecl S_StartNoRoom();
void __cdecl S_StartConfirm();
void __cdecl S_StartBoy();
void __cdecl S_StartBBoy();
void __cdecl S_StartHealer();
void __fastcall S_ScrollHBuy(int idx);
void __cdecl S_StartHBuy();
void __cdecl S_StartStory();
bool __fastcall IdItemOk(ItemStruct *i);
void __fastcall AddStoreHoldId(ItemStruct itm, int i);
void __cdecl S_StartSIdentify();
void __cdecl S_StartIdShow();
void __cdecl S_StartTalk();
void __cdecl S_StartTavern();
void __cdecl S_StartBarMaid();
void __cdecl S_StartDrunk();
void __fastcall StartStore(char s);
void __cdecl DrawSText();
void __cdecl STextESC();
void __cdecl STextUp();
void __cdecl STextDown();
void __cdecl STextPrior();
void __cdecl STextNext();
void __cdecl S_SmithEnter();
void __fastcall SetGoldCurs(int pnum, int i);
void __fastcall SetSpdbarGoldCurs(int pnum, int i);
void __fastcall TakePlrsMoney(int cost);
void __cdecl SmithBuyItem();
void __cdecl S_SBuyEnter();
void __cdecl SmithBuyPItem();
void __cdecl S_SPBuyEnter();
bool __fastcall StoreGoldFit(int idx);
void __fastcall PlaceStoreGold(int v);
void __cdecl StoreSellItem();
void __cdecl S_SSellEnter();
void __cdecl SmithRepairItem();
void __cdecl S_SRepairEnter();
void __cdecl S_WitchEnter();
void __cdecl WitchBuyItem();
void __cdecl S_WBuyEnter();
void __cdecl S_WSellEnter();
void __cdecl WitchRechargeItem();
void __cdecl S_WRechargeEnter();
void __cdecl S_BoyEnter();
void __cdecl BoyBuyItem();
void __cdecl HealerBuyItem();
void __cdecl S_BBuyEnter();
void __cdecl StoryIdItem();
void __cdecl S_ConfirmEnter();
void __cdecl S_HealerEnter();
void __cdecl S_HBuyEnter();
void __cdecl S_StoryEnter();
void __cdecl S_SIDEnter();
void __cdecl S_TalkEnter();
void __cdecl S_TavernEnter();
void __cdecl S_BarmaidEnter();
void __cdecl S_DrunkEnter();
void __cdecl STextEnter();
void __cdecl CheckStoreBtn();
void __cdecl ReleaseStoreBtn();

/* rdata */

extern int SStringY[24];
extern char *talkname[9];

#endif /* __STORES_H__ */
//HEADER_GOES_HERE
#ifndef __SYNC_H__
#define __SYNC_H__

extern short sync_word_6AA708[200];
extern int dword_6AA898; // weak
extern short sync_word_6AA89C[200];
extern int dword_6AAA2C[2];
extern int sgnSyncPInv; // weak

int __fastcall sync_all_monsters(TSyncHeader *packet, int size);
void __cdecl sync_one_monster();
int __fastcall sync_monster_active(TSyncMonster *packet);
int __fastcall sync_monster_pos(TSyncMonster *packet, int mon_id);
int __fastcall sync_monster_active2(TSyncMonster *packet);
char __fastcall SyncPlrInv(TSyncHeader *pItem);
int __fastcall SyncData(int pnum, TSyncHeader *packet);
void __fastcall sync_monster_data(int pnum, TSyncMonster *packet);
void __cdecl sync_clear_pkt();

#endif /* __SYNC_H__ */
//HEADER_GOES_HERE
#ifndef __TEXTDAT_H__
#define __TEXTDAT_H__

extern TextDataStruct alltext[259];
extern int gdwAllTextEntries;

#endif /* __TEXTDAT_H__ */
//HEADER_GOES_HERE
#ifndef __THEMES_H__
#define __THEMES_H__

extern int numthemes; // idb
extern bool armorFlag; // weak
extern int ThemeGoodIn[4];
extern bool weaponFlag; // weak
extern bool treasureFlag; // weak
extern bool mFountainFlag; // weak
extern bool cauldronFlag; // weak
extern bool tFountainFlag; // weak
extern int zharlib; // weak
extern int themex; // idb
extern int themey; // idb
extern int themeVar1; // idb
extern ThemeStruct themes[50];
extern bool pFountainFlag; // weak
extern bool bFountainFlag; // weak
extern bool bCrossFlag; // weak

bool __fastcall TFit_Shrine(int i);
bool __fastcall TFit_Obj5(int t);
bool __fastcall TFit_SkelRoom(int t);
bool __fastcall TFit_GoatShrine(int t);
bool __fastcall CheckThemeObj3(int xp, int yp, int t, int f);
bool __fastcall TFit_Obj3(int t);
bool __fastcall CheckThemeReqs(int t);
bool __fastcall SpecialThemeFit(int i, int t);
bool __fastcall CheckThemeRoom(int tv);
void __cdecl InitThemes();
void __cdecl HoldThemeRooms();
void __fastcall PlaceThemeMonsts(int t, int f);
void __fastcall Theme_Barrel(int t);
void __fastcall Theme_Shrine(int t);
void __fastcall Theme_MonstPit(int t);
void __fastcall Theme_SkelRoom(int t);
void __fastcall Theme_Treasure(int t);
void __fastcall Theme_Library(int t);
void __fastcall Theme_Torture(int t);
void __fastcall Theme_BloodFountain(int t);
void __fastcall Theme_Decap(int t);
void __fastcall Theme_PurifyingFountain(int t);
void __fastcall Theme_ArmorStand(int t);
void __fastcall Theme_GoatShrine(int t);
void __fastcall Theme_Cauldron(int t);
void __fastcall Theme_MurkyFountain(int t);
void __fastcall Theme_TearFountain(int t);
void __fastcall Theme_BrnCross(int t);
void __fastcall Theme_WeaponRack(int t);
void __cdecl UpdateL4Trans();
void __cdecl CreateThemeRooms();

/* rdata */

extern int ThemeGood[4];
extern int trm5x[25];
extern int trm5y[25];
extern int trm3x[9];
extern int trm3y[9];

#endif /* __THEMES_H__ */
//HEADER_GOES_HERE
#ifndef __TMSG_H__
#define __TMSG_H__

extern TMsg *sgpTimedMsgHead;

int __fastcall tmsg_get(unsigned char *pbMsg, char bLen);
void __fastcall tmsg_add(unsigned char *pbMsg, char bLen);
void __cdecl tmsg_cleanup();

#endif /* __TMSG_H__ */
//HEADER_GOES_HERE
#ifndef __TOWN_H__
#define __TOWN_H__

void __fastcall town_clear_upper_buf(int a1);
void __fastcall town_clear_low_buf(int y_related);
void __fastcall town_draw_clipped_e_flag(void *buffer, int x, int y, int sx, int sy);
void __fastcall town_draw_clipped_town(void *unused, int x, int y, int sx, int sy, int some_flag);
void __fastcall town_draw_lower(int x, int y, int sx, int sy, int a5, int some_flag);
void __fastcall town_draw_clipped_e_flag_2(void *buffer, int x, int y, int a4, int a5, int sx, int sy);
void __fastcall town_draw_clipped_town_2(int x, int y, int a3, int a4, int a5, int sx, int sy, int some_flag);
void __fastcall town_draw_lower_2(int x, int y, int sx, int sy, int a5, int a6, int some_flag);
void __fastcall town_draw_e_flag(void *buffer, int x, int y, int a4, int dir, int sx, int sy);
void __fastcall town_draw_town_all(void *buffer, int x, int y, int a4, int dir, int sx, int sy, int some_flag);
void __fastcall town_draw_upper(int x, int y, int sx, int sy, int a5, int a6, int some_flag);
void __fastcall T_DrawGame(int x, int y);
void __fastcall T_DrawZoom(int x, int y);
void __fastcall T_DrawView(int StartX, int StartY);
void __cdecl town_init_dpiece_defs_map();
void __fastcall T_FillSector(unsigned char *P3Tiles, unsigned char *pSector, int xi, int yi, int w, int h);
void __fastcall T_FillTile(unsigned char *P3Tiles, int xx, int yy, int t);
void __cdecl T_Pass3();
void __fastcall CreateTown(int entry);

#endif /* __TOWN_H__ */
//HEADER_GOES_HERE
#ifndef __TOWNERS_H__
#define __TOWNERS_H__

extern int storeflag; // weak
extern int sgnCowMsg; // weak
extern int numtowners; // idb
extern int sgdwCowClicks; // weak
extern int bannerflag; // weak // unused 0x6AAC28
extern int boyloadflag; // weak
extern void *pCowCels; // idb
extern TownerStruct towner[16];

int __fastcall GetActiveTowner(int t);
void __fastcall SetTownerGPtrs(void *pData, void **pAnim);
void __fastcall NewTownerAnim(int tnum, void *pAnim, int numFrames, int Delay);
void __fastcall InitTownerInfo(int i, int w, bool sel, int t, int x, int y, int ao, int tp);
void __fastcall InitQstSnds(int i);
void __cdecl InitSmith();
void __cdecl InitBarOwner();
void __cdecl InitTownDead();
void __cdecl InitWitch();
void __cdecl InitBarmaid();
void __cdecl InitBoy();
void __cdecl InitHealer();
void __cdecl InitTeller();
void __cdecl InitDrunk();
void __cdecl InitCows();
void __cdecl InitTowners();
void __cdecl FreeTownerGFX();
void __fastcall TownCtrlMsg(int i);
void __cdecl TownBlackSmith();
void __cdecl TownBarOwner();
void __cdecl TownDead();
void __cdecl TownHealer();
void __cdecl TownStory();
void __cdecl TownDrunk();
void __cdecl TownBoy();
void __cdecl TownWitch();
void __cdecl TownBarMaid();
void __cdecl TownCow();
void __cdecl ProcessTowners();
ItemStruct *__fastcall PlrHasItem(int pnum, int item, int *i);
void __fastcall TownerTalk(int t);
void __fastcall TalkToTowner(int p, int t);
void __fastcall CowSFX(int pnum);

/* data */

extern int snSFX[3][3];

/* rdata */

extern char AnimOrder[6][148];
extern int TownCowX[3];
extern int TownCowY[3];
extern int TownCowDir[3];
extern int cowoffx[8];
extern int cowoffy[8];
extern QuestTalkData Qtalklist[11];
extern int CowPlaying;

#endif /* __TOWNERS_H__ */
//HEADER_GOES_HERE
#ifndef __TRACK_H__
#define __TRACK_H__

extern bool sgbIsScrolling; // weak
extern int track_cpp_init_value; // weak
extern int sgdwLastWalk; // weak
extern bool sgbIsWalking; // weak

void __cdecl track_cpp_init();
void __cdecl track_process();
void __fastcall track_repeat_walk(bool rep);
bool __cdecl track_isscrolling();

/* data */

extern int track_inf; // weak

#endif /* __TRACK_H__ */
//HEADER_GOES_HERE
#ifndef __TRIGS_H__
#define __TRIGS_H__

extern int trigflag[5];
extern TriggerStruct trigs[5];
extern int TWarpFrom; // weak

void __cdecl InitNoTriggers();
void __cdecl InitTownTriggers();
void __cdecl InitL1Triggers();
void __cdecl InitL2Triggers();
void __cdecl InitL3Triggers();
void __cdecl InitL4Triggers();
void __cdecl InitSKingTriggers();
void __cdecl InitSChambTriggers();
void __cdecl InitPWaterTriggers();
void __cdecl InitVPTriggers();
unsigned char __cdecl ForceTownTrig();
unsigned char __cdecl ForceL1Trig();
unsigned char __cdecl ForceL2Trig();
unsigned char __cdecl ForceL3Trig();
unsigned char __cdecl ForceL4Trig();
void __cdecl Freeupstairs();
unsigned char __cdecl ForceSKingTrig();
unsigned char __cdecl ForceSChambTrig();
unsigned char __cdecl ForcePWaterTrig();
void __cdecl CheckTrigForce();
void __cdecl CheckTriggers();

/* rdata */

extern int TownDownList[11];
extern int TownWarp1List[13];
extern int L1UpList[12];
extern int L1DownList[10];
extern int L2UpList[3];
extern int L2DownList[5];
extern int L2TWarpUpList[3];
extern int L3UpList[15];
extern int L3DownList[9];
extern int L3TWarpUpList[14];
extern int L4UpList[4];
extern int L4DownList[6];
extern int L4TWarpUpList[4];
extern int L4PentaList[33];

#endif /* __TRIGS_H__ */
//HEADER_GOES_HERE
#ifndef __WAVE_H__
#define __WAVE_H__

extern int wave_cpp_init_value; // weak
//int dword_6ABB9C; // weak

void __cdecl wave_cpp_init();
bool __fastcall WCloseFile(void *file);
int __fastcall WGetFileSize(HANDLE hsFile, unsigned long *a2);
void __fastcall WGetFileArchive(HANDLE hsFile, int *a2, char *dwInitParam);
int __fastcall WOpenFile(char *dwInitParam, HANDLE *phsFile, int a3);
char __fastcall WReadFile(HANDLE hsFile, char *buf, int a3);
int __fastcall WSetFilePointer(HANDLE file1, int offset, HANDLE file2, int whence);
int __fastcall LoadWaveFormat(HANDLE hsFile, WAVEFORMATEX *pwfx);
void *__fastcall AllocateMemFile(HANDLE hsFile, MEMFILE *pMemFile, unsigned int a3);
void __fastcall FreeMemFile(MEMFILE *pMemFile);
int __fastcall ReadWaveFile(MEMFILE *pMemFile, WAVEFORMATEX *pwfx, int *a3);
int __fastcall ReadMemFile(MEMFILE *pMemFile, void *lpBuf, size_t a3);
void __fastcall FillMemFile(MEMFILE *pMemFile);
int __fastcall SeekMemFile(MEMFILE *pMemFile, unsigned int lDist, int dwMethod);
int __fastcall ReadWaveSection(MEMFILE *pMemFile, int a2, int *a3);
void *__fastcall LoadWaveFile(HANDLE hsFile, WAVEFORMATEX *pwfx, int *a3);
void __fastcall j_engine_mem_free(void *ptr);

/* data */

extern int wave_inf; // weak

#endif /* __WAVE_H__ */
//HEADER_GOES_HERE
#ifndef __WORLD_H__
#define __WORLD_H__

void __fastcall drawTopArchesUpperScreen(void *a1);
void __fastcall drawBottomArchesUpperScreen(void *a1, int a2);
void __fastcall drawUpperScreen(void *a1);
void __fastcall drawTopArchesLowerScreen(void *a1);
void __fastcall drawBottomArchesLowerScreen(void *a1, int a2);
void __fastcall drawLowerScreen(void *a1);
void __fastcall world_draw_black_tile(char *dst_buf);

/* rdata */

extern int world_4B325C;
extern unsigned char world_4B3260[5];
extern int world_4B3265;
extern int world_4B3269[5];
extern unsigned int tile_draw_masks[3][32];
extern int world_4B33FD[48];
extern int world_4B34BD[17];
extern int world_4B3501[17];

#endif /* __WORLD_H__ */
